# ðŸŽ¯ Complete Interview Questions Database - 250+ Questions

## ðŸ“Š Database Overview

**Total Questions**: 250+  
**Categories**: 12  
**Difficulty Levels**: Basic (40%), Medium (35%), Hard (25%)  
**Experience Range**: 0-12 years  
**For 8 Years Experience**: 180+ relevant questions  

---

# â˜• JAVA PROGRAMMING (50 Questions)

## Java Core Basics (15 Questions)

### Q1: What are the main features of Java?
**Difficulty**: Basic | **Experience**: 0-2, 3-5  
**Companies**: All companies  
**Answer**: Platform independent, Object-oriented, Simple, Secure, Robust, Multithreaded, Architecture neutral, Portable, High performance, Dynamic, Distributed
**Follow-up**: What is JVM? Explain JDK vs JRE vs JVM

---

### Q2: Explain JVM, JRE, and JDK
**Difficulty**: Basic | **Experience**: 0-2, 3-5  
**Companies**: TCS, Infosys, Wipro, Cognizant  
**Answer**: 
- **JVM** (Java Virtual Machine): Executes Java bytecode, provides runtime environment
- **JRE** (Java Runtime Environment): JVM + libraries needed to run Java applications
- **JDK** (Java Development Kit): JRE + development tools (compiler, debugger)
**Code**:
```java
// Java program execution flow
Source Code (.java) 
  â†“ javac compiler
Bytecode (.class)
  â†“ JVM
Machine Code
  â†“
Execution
```
**Follow-up**: How does Java achieve platform independence? What is bytecode?

---

### Q3: What is the difference between JDK 8, JDK 11, and JDK 17?
**Difficulty**: Medium | **Experience**: 3-5, 6-8  
**Companies**: Google, Amazon, Microsoft  
**Answer**:
- **JDK 8** (2014): Lambda expressions, Stream API, Optional, Default methods, Method references
- **JDK 11** (2018 LTS): Local variable syntax, HTTP Client, String methods (isBlank, lines, strip), Files methods
- **JDK 17** (2021 LTS): Sealed classes, Pattern matching for switch, Records, Text blocks
**Follow-up**: What are LTS versions? Why should we upgrade?

---

### Q4: Explain access modifiers in Java
**Difficulty**: Basic | **Experience**: 0-2, 3-5, 6-8  
**Companies**: All companies  
**Answer**:
- **public**: Accessible from anywhere
- **protected**: Accessible within package and subclasses
- **default**: Accessible within package only
- **private**: Accessible within class only
**Code**:
```java
public class AccessDemo {
    public int publicVar;        // Anywhere
    protected int protectedVar;  // Package + subclasses
    int defaultVar;              // Package only
    private int privateVar;      // Class only
}
```
**Follow-up**: Can we have private constructor? What is its use?

---

### Q5: What is the difference between final, finally, and finalize?
**Difficulty**: Medium | **Experience**: 3-5, 6-8  
**Companies**: Amazon, Flipkart, Paytm  
**Answer**:
- **final**: Keyword to make variable constant, prevent method overriding, prevent class inheritance
- **finally**: Block that always executes after try-catch (cleanup code)
- **finalize()**: Method called by garbage collector before object destruction (deprecated in Java 9)
**Code**:
```java
// final
final int MAX = 100;
final class FinalClass { }
final void method() { }

// finally
try {
    // code
} catch (Exception e) {
    // handle
} finally {
    // cleanup - always executes
}

// finalize
@Override
protected void finalize() throws Throwable {
    // cleanup before GC (deprecated)
}
```
**Follow-up**: When does finally not execute? What replaced finalize()?

---

### Q6: Explain static keyword in Java
**Difficulty**: Medium | **Experience**: 3-5, 6-8  
**Companies**: Google, Microsoft, Oracle  
**Answer**: Static belongs to class, not instance. Loaded at class loading time. Can be: variable, method, block, nested class. Accessed without object.
**Code**:
```java
public class StaticDemo {
    static int count = 0;           // Static variable
    
    static {                        // Static block
        System.out.println("Loaded");
    }
    
    static void display() {         // Static method
        System.out.println("Count: " + count);
    }
    
    static class Inner {            // Static nested class
    }
}

// Usage
StaticDemo.count++;
StaticDemo.display();
```
**Follow-up**: Can we override static methods? Why main() is static?

---

### Q7: What is the difference between this and super keywords?
**Difficulty**: Basic | **Experience**: 0-2, 3-5  
**Companies**: Infosys, TCS, HCL  
**Answer**:
- **this**: Refers to current class instance, used to access instance variables/methods, call current class constructor
- **super**: Refers to parent class, used to access parent class variables/methods, call parent constructor
**Code**:
```java
class Parent {
    int x = 10;
    Parent() { System.out.println("Parent constructor"); }
    void display() { System.out.println("Parent"); }
}

class Child extends Parent {
    int x = 20;
    
    Child() {
        super();  // Call parent constructor
        this.x = 30;  // Current class variable
    }
    
    void display() {
        super.display();  // Parent method
        System.out.println("This x: " + this.x);    // 30
        System.out.println("Super x: " + super.x);  // 10
    }
}
```
**Follow-up**: Can we use this() and super() together? What is constructor chaining?

---

### Q8: Explain wrapper classes and autoboxing/unboxing
**Difficulty**: Medium | **Experience**: 3-5, 6-8  
**Companies**: Amazon, Adobe, Salesforce  
**Answer**: Wrapper classes convert primitives to objects. Autoboxing: automatic primitive to wrapper conversion. Unboxing: automatic wrapper to primitive conversion.
**Code**:
```java
// Wrapper classes
int primitive = 10;
Integer wrapper = Integer.valueOf(10);  // Manual boxing

// Autoboxing (Java 5+)
Integer auto = 10;  // int â†’ Integer automatically

// Unboxing
int value = auto;   // Integer â†’ int automatically

// Why wrapper classes?
ArrayList<Integer> list = new ArrayList<>();  // Can't use ArrayList<int>
list.add(5);  // Autoboxing

// Wrapper methods
Integer.parseInt("123");
Integer.toString(100);
Integer.compare(5, 10);
```
**Follow-up**: What is the difference between Integer.valueOf() and new Integer()? What is Integer cache?

---

### Q9: What is type casting in Java? Explain implicit vs explicit casting
**Difficulty**: Basic | **Experience**: 0-2, 3-5  
**Companies**: Cognizant, Capgemini, Accenture  
**Answer**:
- **Implicit (Widening)**: Smaller to larger type, automatic, no data loss
- **Explicit (Narrowing)**: Larger to smaller type, manual, potential data loss
**Code**:
```java
// Implicit casting (Widening) - Automatic
int i = 100;
long l = i;      // int â†’ long
double d = l;    // long â†’ double

// Explicit casting (Narrowing) - Manual
double d2 = 100.99;
long l2 = (long) d2;   // double â†’ long (loses .99)
int i2 = (int) l2;     // long â†’ int

// Object casting
Object obj = "Hello";
String str = (String) obj;  // Downcasting

// ClassCastException
Object num = 123;
String s = (String) num;  // Runtime error\!
```
**Follow-up**: What is ClassCastException? How to check before casting? (instanceof)

---

### Q10: What is var keyword in Java 10+?
**Difficulty**: Medium | **Experience**: 6-8, 9-12  
**Companies**: Google, Microsoft, Thoughtworks  
**Answer**: Local variable type inference. Compiler infers type from right side. Only for local variables, not for fields, parameters, or return types.
**Code**:
```java
// Java 10+ var keyword
var list = new ArrayList<String>();  // Inferred as ArrayList<String>
var map = new HashMap<String, Integer>();
var count = 10;  // Inferred as int
var name = "John";  // Inferred as String

// Cannot use var for
// var field;  // Error - fields
// public var method(var param)  // Error - parameters/return

// Best practices
var goodExample = getUserList();  // Clear from method name
var bad = get();  // Unclear type
```
**Follow-up**: What are the limitations of var? When should you NOT use it?

---

## Java OOP Concepts (10 Questions)

### Q11: What is constructor? Types of constructors?
**Difficulty**: Basic | **Experience**: 0-2, 3-5  
**Companies**: All companies  
**Answer**: Special method to initialize objects. Types: Default (no-arg), Parameterized, Copy constructor.
**Code**:
```java
public class Employee {
    String name;
    int id;
    
    // Default constructor
    public Employee() {
        this.name = "Unknown";
        this.id = 0;
    }
    
    // Parameterized constructor
    public Employee(String name, int id) {
        this.name = name;
        this.id = id;
    }
    
    // Copy constructor
    public Employee(Employee emp) {
        this.name = emp.name;
        this.id = emp.id;
    }
}
```
**Follow-up**: Can constructor be private? What is constructor overloading? What is constructor chaining?

---

### Q12: What is the difference between abstract class and interface in Java 8+?
**Difficulty**: Medium | **Experience**: 3-5, 6-8, 9-12  
**Companies**: Google, Amazon, Microsoft, Adobe  
**Answer**:
**Abstract Class**: Can have constructor, instance variables, concrete methods, abstract methods, any access modifiers. Single inheritance.
**Interface**: No constructor (Java 8+: default & static methods), variables are public static final, multiple inheritance.
**Code**:
```java
// Abstract class
abstract class Animal {
    String name;  // Instance variable
    
    public Animal(String name) {  // Constructor
        this.name = name;
    }
    
    abstract void sound();  // Abstract method
    
    void sleep() {  // Concrete method
        System.out.println(name + " is sleeping");
    }
}

// Interface (Java 8+)
interface Flyable {
    int MAX_ALTITUDE = 10000;  // public static final
    
    void fly();  // Abstract method
    
    default void land() {  // Default method (Java 8+)
        System.out.println("Landing...");
    }
    
    static void checkWeather() {  // Static method (Java 8+)
        System.out.println("Weather OK");
    }
}

class Bird extends Animal implements Flyable {
    public Bird(String name) {
        super(name);
    }
    
    @Override
    void sound() {
        System.out.println("Chirp");
    }
    
    @Override
    public void fly() {
        System.out.println(name + " is flying");
    }
}
```
**Follow-up**: When to use abstract class vs interface? What are functional interfaces?

---

### Q13: What is polymorphism? Explain with real example
**Difficulty**: Medium | **Experience**: 3-5, 6-8  
**Companies**: Flipkart, Amazon, Walmart Labs  
**Answer**: Poly = many, morphism = forms. Ability of object to take many forms. Types: Compile-time (overloading), Runtime (overriding).
**Code**:
```java
// Runtime Polymorphism (Real Example)
interface PaymentMethod {
    void pay(double amount);
}

class CreditCard implements PaymentMethod {
    @Override
    public void pay(double amount) {
        System.out.println("Paid $" + amount + " via Credit Card");
    }
}

class UPI implements PaymentMethod {
    @Override
    public void pay(double amount) {
        System.out.println("Paid $" + amount + " via UPI");
    }
}

class PayPal implements PaymentMethod {
    @Override
    public void pay(double amount) {
        System.out.println("Paid $" + amount + " via PayPal");
    }
}

// Usage
public class PaymentProcessor {
    public void processPayment(PaymentMethod method, double amount) {
        method.pay(amount);  // Polymorphism - decides at runtime
    }
    
    public static void main(String[] args) {
        PaymentProcessor processor = new PaymentProcessor();
        
        processor.processPayment(new CreditCard(), 100);
        processor.processPayment(new UPI(), 200);
        processor.processPayment(new PayPal(), 300);
    }
}
```
**Follow-up**: What is dynamic method dispatch? Can we achieve polymorphism without inheritance?

---

### Q14: What is encapsulation? Why is it important?
**Difficulty**: Basic | **Experience**: 0-2, 3-5  
**Companies**: TCS, Infosys, Cognizant  
**Answer**: Wrapping data and methods together, hiding internal details. Achieved using private variables and public getter/setter methods. Benefits: Data hiding, flexibility, reusability, testing.
**Code**:
```java
public class BankAccount {
    private double balance;  // Private - encapsulated
    private String accountNumber;
    
    public BankAccount(String accountNumber) {
        this.accountNumber = accountNumber;
        this.balance = 0.0;
    }
    
    // Getter
    public double getBalance() {
        return balance;
    }
    
    // Setter with validation
    public void deposit(double amount) {
        if (amount > 0) {
            this.balance += amount;
        } else {
            throw new IllegalArgumentException("Amount must be positive");
        }
    }
    
    public void withdraw(double amount) {
        if (amount > 0 && amount <= balance) {
            this.balance -= amount;
        } else {
            throw new IllegalArgumentException("Invalid amount");
        }
    }
}

// Usage
BankAccount account = new BankAccount("1234");
account.deposit(1000);
// account.balance = -500;  // Error - cannot access directly
account.withdraw(200);
System.out.println(account.getBalance());  // 800
```
**Follow-up**: What is data hiding? What are JavaBeans?

---

### Q15: Explain inheritance types in Java
**Difficulty**: Medium | **Experience**: 3-5, 6-8  
**Companies**: Capgemini, HCL, Tech Mahindra  
**Answer**: 
- **Single**: Class extends one class
- **Multilevel**: Class extends class which extends another class
- **Hierarchical**: Multiple classes extend one class
- **Multiple**: Not supported in Java for classes (supported via interfaces)
- **Hybrid**: Combination (not supported for classes)
**Code**:
```java
// Single Inheritance
class Animal {
    void eat() { System.out.println("Eating"); }
}
class Dog extends Animal {
    void bark() { System.out.println("Barking"); }
}

// Multilevel Inheritance
class GrandParent {
    void show() { System.out.println("GrandParent"); }
}
class Parent extends GrandParent {
    void display() { System.out.println("Parent"); }
}
class Child extends Parent {
    void print() { System.out.println("Child"); }
}

// Hierarchical Inheritance
class Shape {
    void draw() { System.out.println("Drawing"); }
}
class Circle extends Shape { }
class Rectangle extends Shape { }

// Multiple Inheritance (via interfaces)
interface Printable {
    void print();
}
interface Showable {
    void show();
}
class Document implements Printable, Showable {
    public void print() { System.out.println("Printing"); }
    public void show() { System.out.println("Showing"); }
}
```
**Follow-up**: Why doesn't Java support multiple inheritance for classes? What is diamond problem?

---

## Java Collections Framework (15 Questions)

### Q16: Explain the difference between ArrayList and LinkedList
**Difficulty**: Medium | **Experience**: 3-5, 6-8
**Companies**: Amazon, Google, Microsoft, Flipkart
**Answer**: ArrayList uses dynamic array internally with random access (O(1)), better for retrieval. LinkedList uses doubly-linked list with sequential access (O(n)), better for insertion/deletion at ends. ArrayList has less memory overhead; LinkedList stores data + two pointers per node.
**Code**:
```java
// ArrayList - backed by array
List<String> arrayList = new ArrayList<>();
arrayList.add("A");           // O(1) - amortized
arrayList.get(0);              // O(1) - random access
arrayList.add(0, "B");         // O(n) - shift elements

// LinkedList - doubly linked nodes
List<String> linkedList = new LinkedList<>();
linkedList.add("A");           // O(1) - add at end
linkedList.get(0);             // O(n) - traverse from head
linkedList.addFirst("B");      // O(1) - add at beginning

// Performance comparison
// Use ArrayList for: Random access, iterations, less memory
// Use LinkedList for: Frequent insertions/deletions at ends
```
**Follow-up**: What is the initial capacity of ArrayList? What happens when it exceeds capacity? (grows by 50% - new capacity = old * 1.5)

---

### Q17: How does HashMap work internally in Java?
**Difficulty**: Hard | **Experience**: 3-5, 6-8, 9-12
**Companies**: Google, Amazon, Microsoft, Adobe, Uber, Flipkart
**Answer**: HashMap uses array of buckets (Node<K,V>[]). When put(key, value): calculates hash using key.hashCode(), applies hash function to get bucket index, stores key-value in that bucket. If collision occurs, uses linked list (Java 7) or linked list + red-black tree (Java 8+ when bucket size > 8). Get operation: hash key â†’ find bucket â†’ traverse list/tree â†’ compare keys using equals().
**Code**:
```java
// HashMap internal structure (simplified)
class HashMap<K, V> {
    Node<K,V>[] table;  // Array of buckets
    int size;
    float loadFactor = 0.75f;  // Rehash at 75% capacity

    static class Node<K,V> {
        final int hash;
        final K key;
        V value;
        Node<K,V> next;  // For collision - linked list
    }

    // Put operation
    public V put(K key, V value) {
        int hash = hash(key);           // Calculate hash
        int index = hash & (n - 1);     // Get bucket index
        // Check if key exists, else add new node
        // If bucket size > 8, convert to TreeNode (Java 8+)
    }

    // Hash function (Java 8)
    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
}

// Usage
Map<String, Integer> map = new HashMap<>();
map.put("John", 25);  // hash("John") â†’ index â†’ store

// Collision example
Map<Integer, String> collisionMap = new HashMap<>(2);
collisionMap.put(1, "A");   // bucket 1
collisionMap.put(17, "B");  // also bucket 1 (collision) â†’ linked list
```
**Follow-up**: What is load factor? When does rehashing occur? Why is HashMap not thread-safe? What is the difference between HashMap and ConcurrentHashMap?

---

### Q18: What is the difference between HashMap and ConcurrentHashMap?
**Difficulty**: Hard | **Experience**: 6-8, 9-12
**Companies**: Google, Amazon, Microsoft, Uber, LinkedIn
**Answer**: HashMap is not thread-safe; ConcurrentHashMap is thread-safe. HashMap allows one null key; ConcurrentHashMap doesn't allow null keys/values. HashMap locks entire map if synchronized externally; ConcurrentHashMap uses segment-level locking (Java 7) or CAS operations (Java 8+) for better concurrency. ConcurrentHashMap provides fail-safe iterators.
**Code**:
```java
// HashMap - NOT thread-safe
Map<String, Integer> hashMap = new HashMap<>();
hashMap.put("A", 1);
hashMap.put(null, 2);  // Allowed

// Problem in multithreading
Thread t1 = new Thread(() -> hashMap.put("B", 2));
Thread t2 = new Thread(() -> hashMap.put("C", 3));
// Can cause ConcurrentModificationException or data corruption

// ConcurrentHashMap - Thread-safe
Map<String, Integer> concurrentMap = new ConcurrentHashMap<>();
concurrentMap.put("A", 1);
// concurrentMap.put(null, 2);  // NullPointerException

// Safe in multithreading
Thread t3 = new Thread(() -> concurrentMap.put("B", 2));
Thread t4 = new Thread(() -> concurrentMap.put("C", 3));
// Thread-safe operations

// Atomic operations in ConcurrentHashMap
concurrentMap.putIfAbsent("D", 4);
concurrentMap.computeIfAbsent("E", k -> k.length());
concurrentMap.merge("A", 5, Integer::sum);  // 1 + 5 = 6

// Synchronized HashMap (alternative, but less performant)
Map<String, Integer> syncMap = Collections.synchronizedMap(new HashMap<>());
```
**Follow-up**: What is segment locking? How does CAS (Compare-And-Swap) work in ConcurrentHashMap? When should you use ConcurrentHashMap vs synchronized HashMap?

---

### Q19: Explain the difference between HashSet, LinkedHashSet, and TreeSet
**Difficulty**: Medium | **Experience**: 3-5, 6-8
**Companies**: Flipkart, Paytm, Amazon, Adobe
**Answer**:
- **HashSet**: Unordered, uses HashMap internally, O(1) add/remove/contains, allows one null
- **LinkedHashSet**: Maintains insertion order, uses linked list + hash table, O(1) operations, slightly slower than HashSet
- **TreeSet**: Sorted order (natural or comparator), uses Red-Black tree, O(log n) operations, no nulls
**Code**:
```java
// HashSet - Unordered, fastest
Set<String> hashSet = new HashSet<>();
hashSet.add("Dog");
hashSet.add("Cat");
hashSet.add("Bird");
System.out.println(hashSet);  // [Dog, Bird, Cat] - random order

// LinkedHashSet - Insertion order maintained
Set<String> linkedHashSet = new LinkedHashSet<>();
linkedHashSet.add("Dog");
linkedHashSet.add("Cat");
linkedHashSet.add("Bird");
System.out.println(linkedHashSet);  // [Dog, Cat, Bird] - insertion order

// TreeSet - Sorted order
Set<String> treeSet = new TreeSet<>();
treeSet.add("Dog");
treeSet.add("Cat");
treeSet.add("Bird");
System.out.println(treeSet);  // [Bird, Cat, Dog] - alphabetical

// TreeSet with custom comparator
Set<String> reverseSet = new TreeSet<>(Comparator.reverseOrder());
reverseSet.addAll(Arrays.asList("Dog", "Cat", "Bird"));
System.out.println(reverseSet);  // [Dog, Cat, Bird] - reverse

// Performance comparison
// HashSet: Best for add/remove/contains when order doesn't matter
// LinkedHashSet: When you need insertion order
// TreeSet: When you need sorted data
```
**Follow-up**: How does HashSet ensure uniqueness? What is the internal implementation of TreeSet? Can TreeSet have null values?

---

### Q20: What is the difference between Comparable and Comparator?
**Difficulty**: Medium | **Experience**: 3-5, 6-8
**Companies**: TCS, Infosys, Amazon, Cognizant
**Answer**: Comparable provides single natural ordering using compareTo() method (in the same class). Comparator provides multiple custom orderings using compare() method (external class). Comparable is in java.lang; Comparator is in java.util. Use Comparable for default sorting; Comparator for custom sorting without modifying original class.
**Code**:
```java
// Comparable - Natural ordering (inside the class)
class Employee implements Comparable<Employee> {
    String name;
    int id;
    int salary;

    @Override
    public int compareTo(Employee other) {
        return this.id - other.id;  // Sort by ID (natural order)
    }
}

// Usage of Comparable
List<Employee> employees = new ArrayList<>();
employees.add(new Employee("John", 2, 50000));
employees.add(new Employee("Jane", 1, 60000));
Collections.sort(employees);  // Uses compareTo() - sorts by ID

// Comparator - Custom ordering (external)
class NameComparator implements Comparator<Employee> {
    @Override
    public int compare(Employee e1, Employee e2) {
        return e1.name.compareTo(e2.name);  // Sort by name
    }
}

class SalaryComparator implements Comparator<Employee> {
    @Override
    public int compare(Employee e1, Employee e2) {
        return e1.salary - e2.salary;  // Sort by salary
    }
}

// Usage of Comparator
Collections.sort(employees, new NameComparator());     // Sort by name
Collections.sort(employees, new SalaryComparator());   // Sort by salary

// Java 8+ Lambda comparators
employees.sort((e1, e2) -> e1.name.compareTo(e2.name));
employees.sort(Comparator.comparing(Employee::getName));
employees.sort(Comparator.comparingInt(Employee::getSalary).reversed());

// Multiple criteria sorting
employees.sort(Comparator.comparing(Employee::getName)
                         .thenComparingInt(Employee::getSalary));
```
**Follow-up**: Can a class implement both Comparable and Comparator? What is the contract of compareTo()? What should compareTo() return?

---

### Q21: Explain Iterator, ListIterator, and Enumeration
**Difficulty**: Medium | **Experience**: 3-5, 6-8
**Companies**: Capgemini, HCL, Tech Mahindra
**Answer**:
- **Enumeration**: Legacy (Vector, Hashtable), only forward, read-only, methods: hasMoreElements(), nextElement()
- **Iterator**: Universal (all collections), forward only, can remove, fail-fast, methods: hasNext(), next(), remove()
- **ListIterator**: For List only, bidirectional, can add/remove/modify, methods: hasNext(), next(), hasPrevious(), previous(), add(), set(), remove()
**Code**:
```java
List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C", "D"));

// Iterator - Forward only, can remove
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    String element = iterator.next();
    System.out.println(element);
    if (element.equals("B")) {
        iterator.remove();  // Remove B from list
    }
}
// list is now [A, C, D]

// ListIterator - Bidirectional, can add/modify/remove
ListIterator<String> listIterator = list.listIterator();

// Forward traversal
while (listIterator.hasNext()) {
    System.out.println(listIterator.next());
    listIterator.add("X");  // Add after current element
}

// Backward traversal
while (listIterator.hasPrevious()) {
    String prev = listIterator.previous();
    System.out.println(prev);
    listIterator.set("Modified");  // Modify current element
}

// Enumeration (Legacy - avoid if possible)
Vector<String> vector = new Vector<>(Arrays.asList("A", "B", "C"));
Enumeration<String> enumeration = vector.elements();
while (enumeration.hasMoreElements()) {
    System.out.println(enumeration.nextElement());
    // Cannot remove - read-only
}

// Fail-fast behavior
List<String> list2 = new ArrayList<>(Arrays.asList("A", "B", "C"));
Iterator<String> it = list2.iterator();
while (it.hasNext()) {
    System.out.println(it.next());
    list2.add("D");  // ConcurrentModificationException - fail-fast
}
```
**Follow-up**: What is fail-fast vs fail-safe? How does ConcurrentModificationException occur? How to avoid it?

---

### Q22: What is the difference between fail-fast and fail-safe iterators?
**Difficulty**: Medium | **Experience**: 6-8, 9-12
**Companies**: Amazon, Microsoft, Uber
**Answer**:
- **Fail-fast**: Throws ConcurrentModificationException if collection is modified during iteration. Works on original collection. Examples: ArrayList, HashMap iterators. Uses modCount to detect changes.
- **Fail-safe**: Doesn't throw exception; works on cloned copy of collection. May not reflect latest changes. Examples: ConcurrentHashMap, CopyOnWriteArrayList. Higher memory usage.
**Code**:
```java
// Fail-fast Iterator
List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C"));
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    System.out.println(iterator.next());
    list.add("D");  // ConcurrentModificationException
}

// Proper way with fail-fast
Iterator<String> iterator2 = list.iterator();
while (iterator2.hasNext()) {
    String element = iterator2.next();
    if (element.equals("B")) {
        iterator2.remove();  // Use iterator's remove, not list.remove()
    }
}

// Fail-safe Iterator (ConcurrentHashMap)
ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
map.put("A", 1);
map.put("B", 2);
map.put("C", 3);

Iterator<String> safeIterator = map.keySet().iterator();
while (safeIterator.hasNext()) {
    String key = safeIterator.next();
    System.out.println(key);
    map.put("D", 4);  // No exception - fail-safe
}

// Fail-safe with CopyOnWriteArrayList
List<String> safeList = new CopyOnWriteArrayList<>(Arrays.asList("A", "B", "C"));
Iterator<String> safeListIterator = safeList.iterator();
while (safeListIterator.hasNext()) {
    System.out.println(safeListIterator.next());
    safeList.add("D");  // No exception - works on snapshot
}
// But safeListIterator won't see "D" - it's iterating on copy

// modCount mechanism (internal)
class ArrayList {
    private int modCount = 0;  // Modification count

    public boolean add(E e) {
        modCount++;  // Increment on modification
        // add logic
    }

    private class Itr implements Iterator {
        int expectedModCount = modCount;

        public E next() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
            // next logic
        }
    }
}
```
**Follow-up**: When would you use fail-safe over fail-fast? What is the performance impact of CopyOnWriteArrayList?

---

### Q23: Explain HashMap vs Hashtable vs ConcurrentHashMap
**Difficulty**: Hard | **Experience**: 6-8, 9-12
**Companies**: Google, Amazon, Adobe, Uber
**Answer**:
- **HashMap**: Not synchronized, allows null key/value, fast, fail-fast iterators, introduced Java 1.2
- **Hashtable**: Synchronized (method-level locking), no nulls, slower, legacy (Java 1.0), fail-safe enumeration
- **ConcurrentHashMap**: Thread-safe with better concurrency (segment locking/CAS), no nulls, fail-safe, best for concurrent access
**Code**:
```java
// HashMap - Fast but not thread-safe
Map<String, Integer> hashMap = new HashMap<>();
hashMap.put(null, 1);    // Allowed
hashMap.put("A", null);  // Allowed
hashMap.put("B", 2);
// Not safe for concurrent access

// Hashtable - Thread-safe but slow (entire map locked)
Map<String, Integer> hashtable = new Hashtable<>();
// hashtable.put(null, 1);    // NullPointerException
// hashtable.put("A", null);  // NullPointerException
hashtable.put("B", 2);
// Every operation locks the entire table

// ConcurrentHashMap - Thread-safe with fine-grained locking
Map<String, Integer> concurrentMap = new ConcurrentHashMap<>();
// concurrentMap.put(null, 1);    // NullPointerException
// concurrentMap.put("A", null);  // NullPointerException
concurrentMap.put("B", 2);
concurrentMap.putIfAbsent("C", 3);
concurrentMap.compute("B", (k, v) -> v + 1);  // Atomic operation

// Performance comparison in multithreading
ExecutorService executor = Executors.newFixedThreadPool(10);

// HashMap with external synchronization - SLOW
Map<String, Integer> syncMap = Collections.synchronizedMap(new HashMap<>());
for (int i = 0; i < 100; i++) {
    final int key = i;
    executor.submit(() -> syncMap.put("Key" + key, key));
}

// ConcurrentHashMap - FAST
Map<String, Integer> concMap = new ConcurrentHashMap<>();
for (int i = 0; i < 100; i++) {
    final int key = i;
    executor.submit(() -> concMap.put("Key" + key, key));
}

executor.shutdown();

// Comparison table
/*
Feature              | HashMap  | Hashtable | ConcurrentHashMap
---------------------|----------|-----------|------------------
Thread-safe          | No       | Yes       | Yes
Null key             | Yes (1)  | No        | No
Null value           | Yes      | No        | No
Performance          | Fast     | Slow      | Fast (concurrent)
Locking              | None     | Full map  | Segment/CAS
Iteration            | Fail-fast| Fail-safe | Fail-safe
Legacy               | No       | Yes       | No
*/
```
**Follow-up**: Why doesn't ConcurrentHashMap allow nulls? How does segment locking work? What is the default concurrency level?

---

### Q24: What is the difference between ArrayList and Vector?
**Difficulty**: Basic | **Experience**: 0-2, 3-5, 6-8
**Companies**: TCS, Infosys, Wipro, Cognizant
**Answer**:
- **ArrayList**: Not synchronized, fast, grows by 50% when capacity exceeded, fail-fast iterators
- **Vector**: Synchronized (thread-safe), slower, grows by 100% (doubles), legacy, fail-safe enumeration available
Both are dynamically sized arrays implementing List interface.
**Code**:
```java
// ArrayList - Not synchronized, faster
List<String> arrayList = new ArrayList<>();
arrayList.add("A");
arrayList.add("B");
// Not thread-safe

// Vector - Synchronized, slower
List<String> vector = new Vector<>();
vector.add("A");
vector.add("B");
// Thread-safe, every method is synchronized

// Growth strategy
// ArrayList: newCapacity = oldCapacity + (oldCapacity >> 1)  // +50%
// Vector:    newCapacity = oldCapacity * 2                   // +100%

// Example: Starting capacity 10
// ArrayList: 10 â†’ 15 â†’ 22 â†’ 33
// Vector:    10 â†’ 20 â†’ 40 â†’ 80

// Performance comparison
List<Integer> al = new ArrayList<>();
List<Integer> vec = new Vector<>();

long start = System.nanoTime();
for (int i = 0; i < 100000; i++) {
    al.add(i);
}
long alTime = System.nanoTime() - start;

start = System.nanoTime();
for (int i = 0; i < 100000; i++) {
    vec.add(i);
}
long vecTime = System.nanoTime() - start;
// ArrayList is significantly faster

// If you need thread-safe list
List<String> syncList = Collections.synchronizedList(new ArrayList<>());
// Or use CopyOnWriteArrayList for concurrent access
List<String> concurrentList = new CopyOnWriteArrayList<>();
```
**Follow-up**: Why is Vector considered legacy? When would you still use Vector? What's the alternative to Vector for thread-safety?

---

### Q25: Explain the Queue interface and its implementations
**Difficulty**: Medium | **Experience**: 3-5, 6-8
**Companies**: Amazon, Google, Microsoft
**Answer**: Queue is FIFO data structure. Implementations:
- **LinkedList**: General-purpose queue
- **PriorityQueue**: Elements ordered by priority (natural/comparator), not thread-safe
- **ArrayDeque**: Resizable array, faster than LinkedList, no capacity restrictions
- **ArrayBlockingQueue**: Bounded blocking queue for producer-consumer
- **LinkedBlockingQueue**: Optionally bounded blocking queue
**Code**:
```java
// Queue basic operations
Queue<String> queue = new LinkedList<>();
queue.offer("A");  // Add to queue (returns false if fails)
queue.add("B");    // Add to queue (throws exception if fails)
queue.peek();      // Get head without removing (returns null if empty)
queue.element();   // Get head without removing (throws exception if empty)
queue.poll();      // Remove and return head (returns null if empty)
queue.remove();    // Remove and return head (throws exception if empty)

// PriorityQueue - Min heap by default
Queue<Integer> priorityQueue = new PriorityQueue<>();
priorityQueue.offer(5);
priorityQueue.offer(1);
priorityQueue.offer(3);
System.out.println(priorityQueue.poll());  // 1 (smallest first)
System.out.println(priorityQueue.poll());  // 3
System.out.println(priorityQueue.poll());  // 5

// PriorityQueue with custom comparator (Max heap)
Queue<Integer> maxHeap = new PriorityQueue<>(Comparator.reverseOrder());
maxHeap.offer(5);
maxHeap.offer(1);
maxHeap.offer(3);
System.out.println(maxHeap.poll());  // 5 (largest first)

// ArrayDeque - Double-ended queue (faster than LinkedList)
Deque<String> deque = new ArrayDeque<>();
deque.addFirst("A");   // Add at front
deque.addLast("B");    // Add at end
deque.offerFirst("C");
deque.offerLast("D");
deque.removeFirst();   // Remove from front
deque.removeLast();    // Remove from end

// Blocking Queue for producer-consumer
BlockingQueue<Integer> blockingQueue = new ArrayBlockingQueue<>(5);

// Producer thread
new Thread(() -> {
    try {
        for (int i = 0; i < 10; i++) {
            blockingQueue.put(i);  // Blocks if queue is full
            System.out.println("Produced: " + i);
        }
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
}).start();

// Consumer thread
new Thread(() -> {
    try {
        for (int i = 0; i < 10; i++) {
            Integer value = blockingQueue.take();  // Blocks if queue is empty
            System.out.println("Consumed: " + value);
        }
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
}).start();
```
**Follow-up**: What is the difference between offer() and add()? When would you use ArrayDeque vs LinkedList? Explain producer-consumer pattern.

---

### Q26: What is the Collections utility class?
**Difficulty**: Basic | **Experience**: 3-5, 6-8
**Companies**: All companies
**Answer**: Collections is a utility class (java.util) with static methods for operating on collections. Provides methods for sorting, searching, reversing, synchronizing, and creating immutable collections. Note: Collections (utility class) â‰  Collection (interface).
**Code**:
```java
List<Integer> numbers = new ArrayList<>(Arrays.asList(5, 2, 8, 1, 9));

// Sorting
Collections.sort(numbers);                          // [1, 2, 5, 8, 9]
Collections.sort(numbers, Comparator.reverseOrder()); // [9, 8, 5, 2, 1]

// Reversing
Collections.reverse(numbers);                       // Reverse order

// Searching (binary search - list must be sorted first)
Collections.sort(numbers);
int index = Collections.binarySearch(numbers, 5);   // Returns index

// Min/Max
int min = Collections.min(numbers);
int max = Collections.max(numbers);

// Frequency
int freq = Collections.frequency(numbers, 5);       // Count occurrences

// Replace all
Collections.replaceAll(numbers, 5, 50);             // Replace 5 with 50

// Shuffle
Collections.shuffle(numbers);                       // Random order

// Fill
Collections.fill(numbers, 0);                       // Fill all with 0

// Copy
List<Integer> dest = new ArrayList<>(Arrays.asList(0, 0, 0, 0, 0));
Collections.copy(dest, Arrays.asList(1, 2, 3, 4, 5));

// Thread-safe wrappers
List<String> syncList = Collections.synchronizedList(new ArrayList<>());
Set<String> syncSet = Collections.synchronizedSet(new HashSet<>());
Map<String, Integer> syncMap = Collections.synchronizedMap(new HashMap<>());

// Immutable collections
List<String> immutableList = Collections.unmodifiableList(
    Arrays.asList("A", "B", "C")
);
// immutableList.add("D");  // UnsupportedOperationException

// Empty collections (immutable singletons - efficient)
List<String> emptyList = Collections.emptyList();
Set<String> emptySet = Collections.emptySet();
Map<String, Integer> emptyMap = Collections.emptyMap();

// Singleton collections (immutable)
List<String> singletonList = Collections.singletonList("Only");
Set<String> singletonSet = Collections.singleton("Only");
Map<String, Integer> singletonMap = Collections.singletonMap("Key", 1);

// N copies
List<String> copies = Collections.nCopies(5, "A");  // [A, A, A, A, A]

// Disjoint (no common elements?)
List<Integer> list1 = Arrays.asList(1, 2, 3);
List<Integer> list2 = Arrays.asList(4, 5, 6);
boolean disjoint = Collections.disjoint(list1, list2);  // true

// AddAll
List<String> list = new ArrayList<>();
Collections.addAll(list, "A", "B", "C", "D");
```
**Follow-up**: What's the difference between Collections.synchronizedList() and CopyOnWriteArrayList? Are immutable collections created by Collections really immutable?

---

### Q27: Explain WeakHashMap and when to use it
**Difficulty**: Hard | **Experience**: 6-8, 9-12
**Companies**: Google, Amazon, Microsoft
**Answer**: WeakHashMap uses weak references for keys. If a key has no strong references elsewhere, it can be garbage collected automatically. Useful for caching scenarios where you want entries to be removed automatically when keys are no longer in use. Prevents memory leaks.
**Code**:
```java
// WeakHashMap - Keys can be garbage collected
WeakHashMap<User, String> weakMap = new WeakHashMap<>();

User user1 = new User("John");
User user2 = new User("Jane");

weakMap.put(user1, "Data1");
weakMap.put(user2, "Data2");

System.out.println("Size: " + weakMap.size());  // 2

// Remove strong reference to user1
user1 = null;

// Suggest garbage collection
System.gc();
Thread.sleep(1000);

System.out.println("Size after GC: " + weakMap.size());  // 1
// user1 entry was removed automatically

// Regular HashMap comparison
HashMap<User, String> regularMap = new HashMap<>();
User user3 = new User("Bob");
regularMap.put(user3, "Data3");
user3 = null;  // Remove strong reference
System.gc();
Thread.sleep(1000);
System.out.println("HashMap size: " + regularMap.size());  // Still 1
// Entry NOT removed - HashMap holds strong reference to key

// Practical use case - Caching
class ImageCache {
    private WeakHashMap<String, BufferedImage> cache = new WeakHashMap<>();

    public BufferedImage getImage(String url) {
        if (cache.containsKey(url)) {
            return cache.get(url);
        }

        BufferedImage image = loadImageFromUrl(url);
        cache.put(url, image);
        return image;
    }

    // If no one is using the image, it will be garbage collected
    // automatically, freeing memory
}

// Another use case - Metadata storage
class MetadataStore {
    // Store metadata for objects without preventing their GC
    private WeakHashMap<Object, Map<String, String>> metadata =
        new WeakHashMap<>();

    public void setMetadata(Object obj, String key, String value) {
        metadata.computeIfAbsent(obj, k -> new HashMap<>())
                .put(key, value);
    }

    public String getMetadata(Object obj, String key) {
        Map<String, String> meta = metadata.get(obj);
        return meta != null ? meta.get(key) : null;
    }
    // When obj is GC'd, its metadata is automatically removed
}
```
**Follow-up**: What are weak references? What's the difference between WeakReference, SoftReference, and PhantomReference? When would you use IdentityHashMap?

---

### Q28: What is the difference between Collection and Collections?
**Difficulty**: Basic | **Experience**: 0-2, 3-5
**Companies**: TCS, Infosys, Wipro
**Answer**:
- **Collection**: Interface (java.util.Collection) - root interface of collection framework. Represents a group of objects.
- **Collections**: Utility class (java.util.Collections) - contains static methods for operations on collections (sort, search, synchronize, etc.)
**Code**:
```java
// Collection (Interface)
Collection<String> collection = new ArrayList<>();  // Interface type
collection.add("A");
collection.remove("A");
collection.size();

// List, Set, Queue all extend Collection interface
List<String> list = new ArrayList<>();       // Collection
Set<String> set = new HashSet<>();          // Collection
Queue<String> queue = new LinkedList<>();   // Collection

// Collections (Utility Class)
List<Integer> numbers = new ArrayList<>(Arrays.asList(5, 2, 8, 1));

Collections.sort(numbers);           // Static method to sort
Collections.reverse(numbers);        // Static method to reverse
Collections.shuffle(numbers);        // Static method to shuffle
int max = Collections.max(numbers);  // Static method for max

// Collections provides utility operations
List<String> syncList = Collections.synchronizedList(new ArrayList<>());
List<String> unmodList = Collections.unmodifiableList(list);
List<String> emptyList = Collections.emptyList();

// Collection methods (instance methods)
collection.isEmpty();
collection.contains("A");
collection.iterator();
collection.toArray();
collection.clear();

// Remember:
// Collection = Interface (what a collection IS)
// Collections = Utility Class (what you can DO with collections)
```
**Follow-up**: Can Map extend Collection? Why or why not? What other utility classes exist in Java?

---

### Q29: Explain the Map interface and its implementations
**Difficulty**: Medium | **Experience**: 3-5, 6-8
**Companies**: Amazon, Google, Microsoft, Flipkart
**Answer**: Map stores key-value pairs. Key is unique; value can be duplicate. Main implementations:
- **HashMap**: Unordered, O(1) operations, allows null key/value
- **LinkedHashMap**: Maintains insertion order, slightly slower
- **TreeMap**: Sorted by keys, O(log n) operations, no nulls
- **Hashtable**: Synchronized, legacy, no nulls
- **ConcurrentHashMap**: Thread-safe, no nulls
**Code**:
```java
// HashMap - Most commonly used
Map<String, Integer> hashMap = new HashMap<>();
hashMap.put("John", 25);
hashMap.put("Jane", 30);
hashMap.put(null, 35);       // Allowed
hashMap.put("Bob", null);    // Allowed
System.out.println(hashMap);  // Random order

// LinkedHashMap - Insertion order preserved
Map<String, Integer> linkedHashMap = new LinkedHashMap<>();
linkedHashMap.put("John", 25);
linkedHashMap.put("Jane", 30);
linkedHashMap.put("Bob", 35);
System.out.println(linkedHashMap);  // Insertion order: John, Jane, Bob

// TreeMap - Sorted by keys
Map<String, Integer> treeMap = new TreeMap<>();
treeMap.put("John", 25);
treeMap.put("Alice", 30);
treeMap.put("Bob", 35);
System.out.println(treeMap);  // Sorted: Alice, Bob, John

// Map operations
hashMap.get("John");                    // 25
hashMap.getOrDefault("Tom", 0);         // 0 (default)
hashMap.containsKey("John");            // true
hashMap.containsValue(25);              // true
hashMap.remove("John");                 // Remove entry
hashMap.put("Jane", 40);                // Update value

// Java 8+ Map methods
hashMap.putIfAbsent("Tom", 50);         // Add if key doesn't exist
hashMap.computeIfAbsent("Jerry", k -> k.length());
hashMap.computeIfPresent("Jane", (k, v) -> v + 10);
hashMap.merge("Bob", 5, Integer::sum);  // Merge values
hashMap.replace("John", 25, 26);        // Replace if value matches

// Iterating Map
// Method 1: Entry set
for (Map.Entry<String, Integer> entry : hashMap.entrySet()) {
    System.out.println(entry.getKey() + " : " + entry.getValue());
}

// Method 2: Key set
for (String key : hashMap.keySet()) {
    System.out.println(key + " : " + hashMap.get(key));
}

// Method 3: Values
for (Integer value : hashMap.values()) {
    System.out.println(value);
}

// Method 4: Java 8 forEach
hashMap.forEach((key, value) ->
    System.out.println(key + " : " + value)
);

// Method 5: Stream API
hashMap.entrySet().stream()
    .filter(e -> e.getValue() > 25)
    .forEach(e -> System.out.println(e));
```
**Follow-up**: How does put() work internally? What happens to existing value when you put() with same key? How to sort Map by values?

---

### Q30: What is CopyOnWriteArrayList and when to use it?
**Difficulty**: Hard | **Experience**: 6-8, 9-12
**Companies**: Google, Amazon, Uber, LinkedIn
**Answer**: Thread-safe variant of ArrayList. All mutative operations (add, set, remove) create a fresh copy of underlying array. Iterators work on snapshot, so never throw ConcurrentModificationException. Best for scenarios with many reads, few writes. High memory overhead due to copying.
**Code**:
```java
// CopyOnWriteArrayList - Thread-safe
List<String> cowList = new CopyOnWriteArrayList<>();
cowList.add("A");
cowList.add("B");
cowList.add("C");

// Safe iteration even with concurrent modifications
Iterator<String> iterator = cowList.iterator();
while (iterator.hasNext()) {
    String value = iterator.next();
    System.out.println(value);
    cowList.add("D");  // No ConcurrentModificationException
}
// But iterator won't see "D" - it's working on snapshot

// How it works internally (simplified)
class CopyOnWriteArrayList<E> {
    private volatile Object[] array;

    public boolean add(E e) {
        synchronized (lock) {
            Object[] oldArray = array;
            int len = oldArray.length;

            // Create new array with +1 size
            Object[] newArray = Arrays.copyOf(oldArray, len + 1);
            newArray[len] = e;

            // Replace reference atomically
            array = newArray;
        }
        return true;
    }

    public Iterator<E> iterator() {
        // Iterator works on snapshot (current array)
        return new COWIterator<>(array, 0);
    }
}

// Use case 1: Event listeners (many reads, rare writes)
class EventManager {
    private List<EventListener> listeners = new CopyOnWriteArrayList<>();

    public void addListener(EventListener listener) {
        listeners.add(listener);  // Rare operation
    }

    public void fireEvent(Event event) {
        // This happens frequently - safe with CopyOnWriteArrayList
        for (EventListener listener : listeners) {
            listener.onEvent(event);  // Iteration on snapshot
        }
    }
}

// Use case 2: Configuration that rarely changes
class ConfigManager {
    private List<String> allowedIPs = new CopyOnWriteArrayList<>();

    public void addAllowedIP(String ip) {
        allowedIPs.add(ip);  // Rare admin operation
    }

    public boolean isAllowed(String ip) {
        return allowedIPs.contains(ip);  // Frequent read
    }
}

// Comparison with synchronizedList
List<String> syncList = Collections.synchronizedList(new ArrayList<>());
// Requires external synchronization for iteration
synchronized (syncList) {
    Iterator<String> it = syncList.iterator();
    while (it.hasNext()) {
        System.out.println(it.next());
    }
}

// Performance consideration
// CopyOnWriteArrayList: O(n) for writes, O(1) for reads
// SynchronizedList: O(1) for writes, requires locking for iteration
```
**Follow-up**: What is the memory overhead of CopyOnWriteArrayList? When would you NOT use it? What's the alternative for write-heavy scenarios?

---

## Java Multithreading (7 Questions)

### Q31: How to create threads in Java?
**Difficulty**: Basic | **Experience**: 0-2, 3-5, 6-8
**Companies**: All companies
**Answer**: Three ways to create threads:
1. **Extend Thread class** - Override run() method
2. **Implement Runnable interface** - Implement run(), pass to Thread
3. **Implement Callable interface** - Returns result, can throw exceptions, used with ExecutorService
**Code**:
```java
// Method 1: Extend Thread class
class MyThread extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println(Thread.currentThread().getName() + ": " + i);
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

// Usage
MyThread t1 = new MyThread();
t1.start();  // Don't call run() directly

// Method 2: Implement Runnable (Preferred - allows extending other class)
class MyRunnable implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println(Thread.currentThread().getName() + ": " + i);
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

// Usage
Thread t2 = new Thread(new MyRunnable());
t2.start();

// Method 3: Lambda expression (Java 8+)
Thread t3 = new Thread(() -> {
    for (int i = 0; i < 5; i++) {
        System.out.println(Thread.currentThread().getName() + ": " + i);
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
});
t3.start();

// Method 4: Callable interface (returns result)
class MyCallable implements Callable<Integer> {
    @Override
    public Integer call() throws Exception {
        int sum = 0;
        for (int i = 1; i <= 10; i++) {
            sum += i;
        }
        return sum;
    }
}

// Usage with ExecutorService
ExecutorService executor = Executors.newSingleThreadExecutor();
Future<Integer> future = executor.submit(new MyCallable());
Integer result = future.get();  // Blocking call - waits for result
System.out.println("Result: " + result);  // 55
executor.shutdown();

// Anonymous class
Thread t4 = new Thread(new Runnable() {
    @Override
    public void run() {
        System.out.println("Anonymous runnable");
    }
});
t4.start();
```
**Follow-up**: Why is Runnable preferred over extending Thread? What's the difference between start() and run()? What happens if you call start() twice?

---

### Q32: Explain thread lifecycle in Java
**Difficulty**: Medium | **Experience**: 3-5, 6-8
**Companies**: Amazon, Microsoft, Oracle
**Answer**: Thread has 6 states (Thread.State enum):
1. **NEW** - Thread created but not started
2. **RUNNABLE** - Running or ready to run (waiting for CPU)
3. **BLOCKED** - Waiting for monitor lock
4. **WAITING** - Waiting indefinitely for another thread (wait(), join())
5. **TIMED_WAITING** - Waiting for specified time (sleep(), wait(timeout))
6. **TERMINATED** - Thread completed execution
**Code**:
```java
class ThreadLifecycleDemo {
    public static void main(String[] args) throws InterruptedException {
        Object lock = new Object();

        Thread thread = new Thread(() -> {
            System.out.println("State inside run: " +
                Thread.currentThread().getState());  // RUNNABLE

            synchronized (lock) {
                try {
                    // TIMED_WAITING
                    Thread.sleep(2000);

                    // WAITING
                    lock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        // 1. NEW state
        System.out.println("After creation: " + thread.getState());  // NEW

        // 2. RUNNABLE state
        thread.start();
        Thread.sleep(100);  // Give time to run
        System.out.println("After start: " + thread.getState());  // RUNNABLE

        // 3. TIMED_WAITING state
        Thread.sleep(500);
        System.out.println("During sleep: " + thread.getState());  // TIMED_WAITING

        // 4. WAITING state
        Thread.sleep(2000);
        System.out.println("During wait: " + thread.getState());  // WAITING

        // 5. BLOCKED state demonstration
        Thread t1 = new Thread(() -> {
            synchronized (lock) {
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e) {}
            }
        });

        Thread t2 = new Thread(() -> {
            synchronized (lock) {  // Will be BLOCKED waiting for lock
                System.out.println("T2 got lock");
            }
        });

        t1.start();
        Thread.sleep(100);
        t2.start();
        Thread.sleep(100);
        System.out.println("T2 state: " + t2.getState());  // BLOCKED

        // Wake up waiting thread
        synchronized (lock) {
            lock.notify();
        }

        thread.join();  // Wait for thread to complete

        // 6. TERMINATED state
        System.out.println("After completion: " + thread.getState());  // TERMINATED
    }
}

// Thread state transitions
/*
NEW
  â†“ start()
RUNNABLE â†â†’ CPU Scheduler
  â†“ synchronized block (lock held by other thread)
BLOCKED
  â†“ acquires lock
RUNNABLE
  â†“ sleep(ms) / wait(ms) / join(ms)
TIMED_WAITING
  â†“ time expires
RUNNABLE
  â†“ wait() / join()
WAITING
  â†“ notify() / notifyAll() / other thread completes
RUNNABLE
  â†“ run() method completes
TERMINATED
*/
```
**Follow-up**: Can a thread go from TERMINATED to RUNNABLE? What's the difference between BLOCKED and WAITING? Can you restart a terminated thread?

---

### Q33: What is synchronization? Explain synchronized keyword
**Difficulty**: Medium | **Experience**: 3-5, 6-8, 9-12
**Companies**: Google, Amazon, Microsoft, Adobe
**Answer**: Synchronization prevents thread interference and memory consistency errors when multiple threads access shared resources. synchronized keyword provides mutex (mutual exclusion) lock on object/class. Can be applied to: methods (instance/static) and blocks. Only one thread can execute synchronized code at a time.
**Code**:
```java
// Problem without synchronization
class Counter {
    private int count = 0;

    public void increment() {
        count++;  // Not atomic: read, increment, write
    }

    public int getCount() {
        return count;
    }
}

// Multiple threads incrementing
Counter counter = new Counter();
Thread t1 = new Thread(() -> {
    for (int i = 0; i < 1000; i++) counter.increment();
});
Thread t2 = new Thread(() -> {
    for (int i = 0; i < 1000; i++) counter.increment();
});
t1.start();
t2.start();
t1.join();
t2.join();
System.out.println(counter.getCount());  // Less than 2000 - race condition

// Solution 1: Synchronized method
class SyncCounter {
    private int count = 0;

    public synchronized void increment() {
        count++;  // Only one thread at a time
    }

    public synchronized int getCount() {
        return count;
    }
}

// Solution 2: Synchronized block (more granular)
class SyncBlockCounter {
    private int count = 0;
    private Object lock = new Object();

    public void increment() {
        synchronized (lock) {  // Lock on specific object
            count++;
        }
    }

    public int getCount() {
        synchronized (lock) {
            return count;
        }
    }
}

// Solution 3: Class-level synchronization (static)
class StaticSyncCounter {
    private static int count = 0;

    public static synchronized void increment() {
        count++;  // Locks on Class object
    }

    // Equivalent to:
    public static void incrementAlt() {
        synchronized (StaticSyncCounter.class) {
            count++;
        }
    }
}

// Synchronized on different locks (both can run in parallel)
class MultiLock {
    private int count1 = 0;
    private int count2 = 0;
    private Object lock1 = new Object();
    private Object lock2 = new Object();

    public void increment1() {
        synchronized (lock1) {  // Lock 1
            count1++;
        }
    }

    public void increment2() {
        synchronized (lock2) {  // Lock 2 - different lock
            count2++;
        }
    }
}

// Real-world example: Bank account
class BankAccount {
    private double balance = 0;

    public synchronized void deposit(double amount) {
        System.out.println(Thread.currentThread().getName() +
            " depositing " + amount);
        balance += amount;
        System.out.println("Balance after deposit: " + balance);
    }

    public synchronized void withdraw(double amount) {
        if (balance >= amount) {
            System.out.println(Thread.currentThread().getName() +
                " withdrawing " + amount);
            balance -= amount;
            System.out.println("Balance after withdrawal: " + balance);
        } else {
            System.out.println("Insufficient balance");
        }
    }

    public synchronized double getBalance() {
        return balance;
    }
}
```
**Follow-up**: What is a monitor in Java? What happens if synchronized method calls another synchronized method? Can two threads execute two different synchronized methods simultaneously?

---

### Q34: Explain ThreadLocal in detail with example
**Difficulty**: Hard | **Experience**: 6-8, 9-12
**Companies**: Google, Amazon, Microsoft, Adobe, Uber
**Answer**: ThreadLocal provides thread-local variables. Each thread has its own, independently initialized copy of the variable. Useful for maintaining per-thread context (like user session, database connection, date formatter). Common in web applications for storing request-specific data. Must be careful to avoid memory leaks (call remove()).
**Code**:
```java
// ThreadLocal basics
class ThreadLocalDemo {
    // Each thread has its own copy
    private static ThreadLocal<Integer> threadLocal = ThreadLocal.withInitial(() -> 1);

    public static void main(String[] args) {
        // Thread 1
        Thread t1 = new Thread(() -> {
            System.out.println(Thread.currentThread().getName() +
                " initial: " + threadLocal.get());  // 1
            threadLocal.set(100);
            System.out.println(Thread.currentThread().getName() +
                " after set: " + threadLocal.get());  // 100
        }, "Thread-1");

        // Thread 2
        Thread t2 = new Thread(() -> {
            System.out.println(Thread.currentThread().getName() +
                " initial: " + threadLocal.get());  // 1 (independent copy)
            threadLocal.set(200);
            System.out.println(Thread.currentThread().getName() +
                " after set: " + threadLocal.get());  // 200
        }, "Thread-2");

        t1.start();
        t2.start();
    }
}

// Real-world example 1: WebDriver for Selenium (parallel execution)
class DriverManager {
    private static ThreadLocal<WebDriver> driver = new ThreadLocal<>();

    public static WebDriver getDriver() {
        if (driver.get() == null) {
            driver.set(new ChromeDriver());  // Each thread gets own driver
        }
        return driver.get();
    }

    public static void quitDriver() {
        if (driver.get() != null) {
            driver.get().quit();
            driver.remove();  // Important: prevent memory leak
        }
    }
}

// Usage in test
@Test
public void testParallel() {
    WebDriver driver = DriverManager.getDriver();  // Thread-safe
    driver.get("https://example.com");
    // Each thread has its own driver instance
    DriverManager.quitDriver();
}

// Real-world example 2: User context in web application
class UserContext {
    private static ThreadLocal<User> currentUser = new ThreadLocal<>();

    public static void setUser(User user) {
        currentUser.set(user);
    }

    public static User getUser() {
        return currentUser.get();
    }

    public static void clear() {
        currentUser.remove();  // Must call after request completes
    }
}

// In servlet filter
public void doFilter(ServletRequest request, ServletResponse response) {
    try {
        User user = authenticateUser(request);
        UserContext.setUser(user);  // Store in ThreadLocal

        chain.doFilter(request, response);  // Process request

        // Anywhere in application
        User currentUser = UserContext.getUser();  // Get current user
    } finally {
        UserContext.clear();  // Clean up - prevents memory leak
    }
}

// Real-world example 3: Date formatter (not thread-safe)
class DateUtils {
    // SimpleDateFormat is NOT thread-safe
    private static ThreadLocal<SimpleDateFormat> formatter =
        ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyy-MM-dd"));

    public static String format(Date date) {
        return formatter.get().format(date);  // Thread-safe
    }

    public static Date parse(String dateStr) throws ParseException {
        return formatter.get().parse(dateStr);  // Thread-safe
    }
}

// Real-world example 4: Database connection per thread
class ConnectionManager {
    private static ThreadLocal<Connection> connection = new ThreadLocal<>();

    public static Connection getConnection() throws SQLException {
        if (connection.get() == null) {
            connection.set(DriverManager.getConnection(DB_URL, USER, PASS));
        }
        return connection.get();
    }

    public static void closeConnection() throws SQLException {
        if (connection.get() != null) {
            connection.get().close();
            connection.remove();
        }
    }
}

// Memory leak example (BAD - don't do this)
class ThreadPoolExample {
    private static ThreadLocal<List<String>> data = new ThreadLocal<>();

    public void process() {
        List<String> list = new ArrayList<>();
        list.add("data");
        data.set(list);
        // Forgot to call data.remove()
        // In thread pool, thread is reused, memory never freed
    }
}
```
**Follow-up**: How does ThreadLocal work internally? What is memory leak risk with ThreadLocal? When should you call remove()?

---

### Q35: What is deadlock? How to prevent it?
**Difficulty**: Hard | **Experience**: 6-8, 9-12
**Companies**: Google, Amazon, Microsoft
**Answer**: Deadlock occurs when two or more threads wait for each other to release locks, causing all to wait indefinitely. Conditions for deadlock: Mutual exclusion, Hold and wait, No preemption, Circular wait. Prevention: Avoid nested locks, lock ordering, lock timeout, deadlock detection.
**Code**:
```java
// Deadlock example
class DeadlockDemo {
    private static Object lock1 = new Object();
    private static Object lock2 = new Object();

    public static void main(String[] args) {
        // Thread 1: locks lock1 then lock2
        Thread t1 = new Thread(() -> {
            synchronized (lock1) {
                System.out.println("Thread 1: Holding lock1...");
                try { Thread.sleep(100); } catch (InterruptedException e) {}

                System.out.println("Thread 1: Waiting for lock2...");
                synchronized (lock2) {
                    System.out.println("Thread 1: Holding lock1 & lock2");
                }
            }
        });

        // Thread 2: locks lock2 then lock1 (opposite order - causes deadlock)
        Thread t2 = new Thread(() -> {
            synchronized (lock2) {
                System.out.println("Thread 2: Holding lock2...");
                try { Thread.sleep(100); } catch (InterruptedException e) {}

                System.out.println("Thread 2: Waiting for lock1...");
                synchronized (lock1) {
                    System.out.println("Thread 2: Holding lock2 & lock1");
                }
            }
        });

        t1.start();
        t2.start();
        // DEADLOCK: t1 waits for lock2, t2 waits for lock1
    }
}

// Solution 1: Lock ordering (both threads acquire locks in same order)
class LockOrderingSolution {
    private static Object lock1 = new Object();
    private static Object lock2 = new Object();

    public static void main(String[] args) {
        // Thread 1: lock1 then lock2
        Thread t1 = new Thread(() -> {
            synchronized (lock1) {
                System.out.println("Thread 1: Holding lock1");
                synchronized (lock2) {
                    System.out.println("Thread 1: Holding lock1 & lock2");
                }
            }
        });

        // Thread 2: SAME ORDER - lock1 then lock2
        Thread t2 = new Thread(() -> {
            synchronized (lock1) {
                System.out.println("Thread 2: Holding lock1");
                synchronized (lock2) {
                    System.out.println("Thread 2: Holding lock1 & lock2");
                }
            }
        });

        t1.start();
        t2.start();
        // No deadlock - consistent ordering
    }
}

// Solution 2: Lock timeout (using ReentrantLock)
class LockTimeoutSolution {
    private static Lock lock1 = new ReentrantLock();
    private static Lock lock2 = new ReentrantLock();

    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            try {
                if (lock1.tryLock(1000, TimeUnit.MILLISECONDS)) {
                    try {
                        System.out.println("Thread 1: Holding lock1");

                        if (lock2.tryLock(1000, TimeUnit.MILLISECONDS)) {
                            try {
                                System.out.println("Thread 1: Holding both locks");
                            } finally {
                                lock2.unlock();
                            }
                        } else {
                            System.out.println("Thread 1: Couldn't get lock2");
                        }
                    } finally {
                        lock1.unlock();
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        t1.start();
        // Similar for t2
    }
}

// Solution 3: Avoid nested locks
class AvoidNestedLocks {
    private int balance = 1000;

    public synchronized void withdraw(int amount) {
        balance -= amount;
        // Don't call another synchronized method here
    }

    public synchronized void deposit(int amount) {
        balance += amount;
        // Don't call another synchronized method here
    }
}

// Real-world example: Bank transfer (potential deadlock)
class BankAccount {
    private int balance = 1000;
    private int accountNumber;

    public BankAccount(int accountNumber) {
        this.accountNumber = accountNumber;
    }

    // BAD: Can cause deadlock
    public synchronized void transferBad(BankAccount target, int amount) {
        synchronized (target) {  // Nested lock - deadlock possible
            this.balance -= amount;
            target.balance += amount;
        }
    }

    // GOOD: Lock ordering based on account number
    public void transferGood(BankAccount target, int amount) {
        BankAccount first = this.accountNumber < target.accountNumber ? this : target;
        BankAccount second = this.accountNumber < target.accountNumber ? target : this;

        synchronized (first) {
            synchronized (second) {
                this.balance -= amount;
                target.balance += amount;
            }
        }
    }
}
```
**Follow-up**: How to detect deadlock in production? What tools can help? What is livelock? How is it different from deadlock?

---

### Q36: Explain wait(), notify(), and notifyAll()
**Difficulty**: Hard | **Experience**: 6-8, 9-12
**Companies**: Google, Amazon, Microsoft
**Answer**: These methods are used for inter-thread communication. Must be called inside synchronized block. wait() releases lock and waits; notify() wakes one waiting thread; notifyAll() wakes all waiting threads. Defined in Object class, not Thread.
**Code**:
```java
// Producer-Consumer problem
class ProducerConsumerDemo {
    private static final int MAX_SIZE = 5;
    private LinkedList<Integer> queue = new LinkedList<>();

    // Producer
    public void produce() throws InterruptedException {
        int value = 0;
        while (true) {
            synchronized (this) {
                // Wait if queue is full
                while (queue.size() == MAX_SIZE) {
                    System.out.println("Queue is full, producer waiting...");
                    wait();  // Releases lock and waits
                }

                System.out.println("Produced: " + value);
                queue.add(value++);

                notify();  // Notify consumer

                Thread.sleep(1000);
            }
        }
    }

    // Consumer
    public void consume() throws InterruptedException {
        while (true) {
            synchronized (this) {
                // Wait if queue is empty
                while (queue.isEmpty()) {
                    System.out.println("Queue is empty, consumer waiting...");
                    wait();  // Releases lock and waits
                }

                int value = queue.removeFirst();
                System.out.println("Consumed: " + value);

                notify();  // Notify producer

                Thread.sleep(1000);
            }
        }
    }

    public static void main(String[] args) {
        ProducerConsumerDemo pc = new ProducerConsumerDemo();

        Thread producer = new Thread(() -> {
            try {
                pc.produce();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        Thread consumer = new Thread(() -> {
            try {
                pc.consume();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        producer.start();
        consumer.start();
    }
}

// notify() vs notifyAll() example
class NotifyVsNotifyAll {
    public synchronized void notifyOneThread() {
        System.out.println("Notifying one thread");
        notify();  // Wakes up ONE arbitrary waiting thread
    }

    public synchronized void notifyAllThreads() {
        System.out.println("Notifying all threads");
        notifyAll();  // Wakes up ALL waiting threads
    }

    public synchronized void waitMethod() throws InterruptedException {
        System.out.println(Thread.currentThread().getName() + " waiting");
        wait();
        System.out.println(Thread.currentThread().getName() + " resumed");
    }

    public static void main(String[] args) throws InterruptedException {
        NotifyVsNotifyAll obj = new NotifyVsNotifyAll();

        // Start 3 waiting threads
        for (int i = 0; i < 3; i++) {
            new Thread(() -> {
                try {
                    obj.waitMethod();
                } catch (InterruptedException e) {}
            }, "Thread-" + i).start();
        }

        Thread.sleep(1000);

        obj.notifyOneThread();  // Only ONE thread resumes
        Thread.sleep(1000);

        obj.notifyAllThreads();  // Remaining threads resume
    }
}

// Important rules
class WaitNotifyRules {
    private Object lock = new Object();

    public void demonstrateRules() {
        // Rule 1: Must be called inside synchronized block
        try {
            lock.wait();  // IllegalMonitorStateException
        } catch (IllegalMonitorStateException e) {
            System.out.println("wait() must be inside synchronized");
        } catch (InterruptedException e) {}

        // Rule 2: wait() releases the lock
        synchronized (lock) {
            try {
                System.out.println("Before wait - holding lock");
                lock.wait();  // Releases lock temporarily
                System.out.println("After wait - reacquired lock");
            } catch (InterruptedException e) {}
        }

        // Rule 3: Use while, not if (handle spurious wakeups)
        synchronized (lock) {
            while (condition) {  // GOOD: while loop
                try {
                    lock.wait();
                } catch (InterruptedException e) {}
            }
        }

        synchronized (lock) {
            if (condition) {  // BAD: if statement
                try {
                    lock.wait();
                } catch (InterruptedException e) {}
            }
        }
    }
}
```
**Follow-up**: Why must wait() be called in a loop? What is spurious wakeup? Why are these methods in Object class, not Thread class?

---

### Q37: What is ExecutorService and thread pool?
**Difficulty**: Medium | **Experience**: 6-8, 9-12
**Companies**: Google, Amazon, Microsoft, Adobe
**Answer**: ExecutorService provides thread pool management. Thread pool reuses fixed number of threads to execute tasks, avoiding overhead of creating/destroying threads. Types: FixedThreadPool (fixed size), CachedThreadPool (grows as needed), SingleThreadExecutor (single thread), ScheduledThreadPool (delayed/periodic tasks).
**Code**:
```java
// Basic ExecutorService usage
public class ExecutorServiceDemo {
    public static void main(String[] args) {
        // Create thread pool with 3 threads
        ExecutorService executor = Executors.newFixedThreadPool(3);

        // Submit 10 tasks
        for (int i = 0; i < 10; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println("Task " + taskId +
                    " executed by " + Thread.currentThread().getName());
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {}
            });
        }

        // Shutdown executor
        executor.shutdown();  // No new tasks accepted, completes existing

        try {
            if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
                executor.shutdownNow();  // Force shutdown
            }
        } catch (InterruptedException e) {
            executor.shutdownNow();
        }
    }
}

// Different types of thread pools
class ThreadPoolTypes {
    public static void main(String[] args) {
        // 1. FixedThreadPool - Fixed number of threads
        ExecutorService fixed = Executors.newFixedThreadPool(5);
        // Use case: Known number of concurrent tasks

        // 2. CachedThreadPool - Creates threads as needed, reuses if available
        ExecutorService cached = Executors.newCachedThreadPool();
        // Use case: Many short-lived tasks

        // 3. SingleThreadExecutor - Single worker thread
        ExecutorService single = Executors.newSingleThreadExecutor();
        // Use case: Tasks must execute sequentially

        // 4. ScheduledThreadPool - For delayed/periodic tasks
        ScheduledExecutorService scheduled =
            Executors.newScheduledThreadPool(2);

        // Schedule task after 5 seconds delay
        scheduled.schedule(() ->
            System.out.println("Delayed task"), 5, TimeUnit.SECONDS);

        // Schedule task with fixed rate (every 3 seconds)
        scheduled.scheduleAtFixedRate(() ->
            System.out.println("Periodic task"), 0, 3, TimeUnit.SECONDS);

        // Schedule task with fixed delay (3 seconds after previous completes)
        scheduled.scheduleWithFixedDelay(() ->
            System.out.println("Fixed delay task"), 0, 3, TimeUnit.SECONDS);
    }
}

// Callable and Future (tasks that return results)
class CallableFutureDemo {
    public static void main(String[] args) throws Exception {
        ExecutorService executor = Executors.newFixedThreadPool(2);

        // Submit Callable (returns result)
        Future<Integer> future1 = executor.submit(() -> {
            Thread.sleep(2000);
            return 100;
        });

        Future<Integer> future2 = executor.submit(() -> {
            Thread.sleep(1000);
            return 200;
        });

        // Do other work while tasks execute
        System.out.println("Tasks submitted, doing other work...");

        // Get results (blocking calls)
        Integer result1 = future1.get();  // Waits if not complete
        Integer result2 = future2.get();

        System.out.println("Results: " + result1 + ", " + result2);

        // Check status
        System.out.println("Is done: " + future1.isDone());
        System.out.println("Is cancelled: " + future1.isCancelled());

        // Cancel a task
        Future<Integer> future3 = executor.submit(() -> {
            Thread.sleep(10000);
            return 300;
        });
        future3.cancel(true);  // Interrupt if running

        executor.shutdown();
    }
}

// Real-world example: Parallel test execution
class ParallelTestExecution {
    public void runTestsInParallel(List<String> testCases) {
        int threadCount = 5;
        ExecutorService executor = Executors.newFixedThreadPool(threadCount);

        List<Future<TestResult>> futures = new ArrayList<>();

        // Submit all test cases
        for (String testCase : testCases) {
            Future<TestResult> future = executor.submit(() -> {
                return executeTest(testCase);
            });
            futures.add(future);
        }

        // Collect results
        for (Future<TestResult> future : futures) {
            try {
                TestResult result = future.get(5, TimeUnit.MINUTES);
                System.out.println("Test result: " + result);
            } catch (TimeoutException e) {
                System.out.println("Test timed out");
                future.cancel(true);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        executor.shutdown();
    }

    private TestResult executeTest(String testCase) {
        // Execute test and return result
        return new TestResult(testCase, "PASSED");
    }
}

// Custom ThreadPoolExecutor
class CustomThreadPool {
    public static void main(String[] args) {
        // More control over thread pool configuration
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            2,           // corePoolSize
            5,           // maximumPoolSize
            60,          // keepAliveTime
            TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(10),  // workQueue
            new ThreadPoolExecutor.CallerRunsPolicy()  // rejectionHandler
        );

        // Submit tasks
        for (int i = 0; i < 20; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println("Task " + taskId);
            });
        }

        executor.shutdown();
    }
}
```
**Follow-up**: What happens when you submit more tasks than thread pool size? What are rejection policies? What's the difference between shutdown() and shutdownNow()?

---

## Java Exception Handling (5 Questions)

### Q38: What is the difference between checked and unchecked exceptions?
**Difficulty**: Basic | **Experience**: 0-2, 3-5, 6-8
**Companies**: All companies
**Answer**:
- **Checked exceptions**: Compile-time exceptions, must be handled or declared, extend Exception class (except RuntimeException). Examples: IOException, SQLException, ClassNotFoundException
- **Unchecked exceptions**: Runtime exceptions, not checked at compile-time, extend RuntimeException or Error. Examples: NullPointerException, ArrayIndexOutOfBoundsException, ArithmeticException
**Code**:
```java
// Checked exceptions - Must handle or declare
class CheckedExceptionDemo {
    // Must declare "throws" or handle with try-catch
    public void readFile() throws IOException {
        FileReader file = new FileReader("test.txt");  // Checked exception
        // Compiler forces you to handle
    }

    // Handling checked exception
    public void readFileSafe() {
        try {
            FileReader file = new FileReader("test.txt");
        } catch (IOException e) {
            System.out.println("File not found: " + e.getMessage());
        }
    }

    // Multiple checked exceptions
    public void connectToDatabase() throws SQLException, ClassNotFoundException {
        Class.forName("com.mysql.jdbc.Driver");  // ClassNotFoundException
        Connection conn = DriverManager.getConnection(url);  // SQLException
    }
}

// Unchecked exceptions - No need to declare or handle
class UncheckedExceptionDemo {
    public void divideNumbers(int a, int b) {
        int result = a / b;  // ArithmeticException if b = 0
        // No need to declare or catch
    }

    public void accessArray() {
        int[] arr = new int[5];
        int value = arr[10];  // ArrayIndexOutOfBoundsException
        // No compile-time check
    }

    public void useObject() {
        String str = null;
        int length = str.length();  // NullPointerException
        // No compile-time check
    }

    // You CAN handle unchecked exceptions if you want
    public void handleUnchecked() {
        try {
            int result = 10 / 0;
        } catch (ArithmeticException e) {
            System.out.println("Cannot divide by zero");
        }
    }
}

// Exception hierarchy
/*
Object
  â†“
Throwable
  â†“
  â”œâ”€â”€ Error (Unchecked - OutOfMemoryError, StackOverflowError)
  â””â”€â”€ Exception
        â”œâ”€â”€ RuntimeException (Unchecked)
        â”‚     â”œâ”€â”€ NullPointerException
        â”‚     â”œâ”€â”€ ArrayIndexOutOfBoundsException
        â”‚     â”œâ”€â”€ ArithmeticException
        â”‚     â””â”€â”€ IllegalArgumentException
        â””â”€â”€ Checked Exceptions
              â”œâ”€â”€ IOException
              â”œâ”€â”€ SQLException
              â”œâ”€â”€ ClassNotFoundException
              â””â”€â”€ InterruptedException
*/

// Real-world example
class WebDriverDemo {
    // Checked exception
    public void takeScreenshot() throws IOException {
        File screenshot = ((TakesScreenshot) driver).getScreenshotAs(OutputType.FILE);
        FileUtils.copyFile(screenshot, new File("screenshot.png"));
        // IOException is checked - must handle
    }

    // Unchecked exception
    public void clickElement(By locator) {
        driver.findElement(locator).click();
        // NoSuchElementException is unchecked - no need to declare
    }
}

// When to use which?
// Checked: For recoverable conditions (file not found, DB connection failure)
// Unchecked: For programming errors (null pointer, index out of bounds)
```
**Follow-up**: Should you catch Exception or specific exception? What are Error class exceptions? Can you convert checked to unchecked exception?

---

### Q39: Explain try-catch-finally and try-with-resources
**Difficulty**: Medium | **Experience**: 3-5, 6-8
**Companies**: Amazon, Google, Microsoft
**Answer**: try-catch-finally: try contains code that may throw exception, catch handles exception, finally always executes (cleanup). try-with-resources (Java 7+): Automatically closes resources that implement AutoCloseable, more concise than finally. Resources are closed in reverse order of creation.
**Code**:
```java
// Traditional try-catch-finally
class TraditionalTryCatch {
    public void readFile() {
        FileReader reader = null;
        try {
            reader = new FileReader("file.txt");
            int data = reader.read();
            // Process data
        } catch (IOException e) {
            System.out.println("Error: " + e.getMessage());
        } finally {
            // Always executes - even if exception occurs or return statement
            if (reader != null) {
                try {
                    reader.close();  // Must close manually
                } catch (IOException e) {
                    System.out.println("Error closing: " + e.getMessage());
                }
            }
        }
    }
}

// Try-with-resources (Java 7+) - Cleaner
class TryWithResources {
    public void readFile() {
        // Resources automatically closed
        try (FileReader reader = new FileReader("file.txt");
             BufferedReader bufferedReader = new BufferedReader(reader)) {

            String line = bufferedReader.readLine();
            // Process line

        } catch (IOException e) {
            System.out.println("Error: " + e.getMessage());
        }
        // No finally needed - resources closed automatically
    }
}

// Multiple resources in try-with-resources
class MultipleResources {
    public void copyFile(String source, String destination) {
        try (FileInputStream in = new FileInputStream(source);
             FileOutputStream out = new FileOutputStream(destination)) {

            byte[] buffer = new byte[1024];
            int length;
            while ((length = in.read(buffer)) > 0) {
                out.write(buffer, 0, length);
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
        // Both streams closed automatically in reverse order: out then in
    }
}

// Multiple catch blocks
class MultipleCatch {
    public void processData() {
        try {
            String data = readFromFile();
            int number = Integer.parseInt(data);
            int result = 100 / number;

        } catch (FileNotFoundException e) {
            // Specific exception first
            System.out.println("File not found");
        } catch (NumberFormatException e) {
            System.out.println("Invalid number format");
        } catch (ArithmeticException e) {
            System.out.println("Division by zero");
        } catch (IOException e) {
            // More general exception
            System.out.println("IO error");
        } catch (Exception e) {
            // Most general exception last
            System.out.println("Unknown error");
        }
    }
}

// Multi-catch (Java 7+) - Catch multiple exceptions in one block
class MultiCatchBlock {
    public void processData() {
        try {
            // Some code
        } catch (IOException | SQLException e) {
            // Handle both exceptions the same way
            System.out.println("Error: " + e.getMessage());
            // e is final in multi-catch
        }
    }
}

// Finally block behaviors
class FinallyBehavior {
    public int testFinally() {
        try {
            return 1;  // Finally still executes before return
        } finally {
            System.out.println("Finally executed");  // Prints before return
        }
    }

    public int testFinallyOverride() {
        try {
            return 1;
        } finally {
            return 2;  // BAD: Overrides return value - avoid this
        }
        // Returns 2, not 1
    }

    public void testFinallyWithException() {
        try {
            throw new RuntimeException("Exception in try");
        } finally {
            System.out.println("Finally executes even with exception");
        }
    }

    // Finally doesn't execute only in these cases:
    // 1. System.exit()
    // 2. JVM crash
    // 3. Thread death
    public void finallyNotExecuted() {
        try {
            System.exit(0);  // JVM terminates
        } finally {
            System.out.println("This won't execute");
        }
    }
}

// Custom resource with AutoCloseable
class MyResource implements AutoCloseable {
    public MyResource() {
        System.out.println("Resource opened");
    }

    public void doSomething() {
        System.out.println("Using resource");
    }

    @Override
    public void close() {
        System.out.println("Resource closed");
    }
}

// Usage
try (MyResource resource = new MyResource()) {
    resource.doSomething();
}  // close() called automatically

// Real-world Selenium example
class SeleniumExample {
    public void testWithTryFinally() {
        WebDriver driver = null;
        try {
            driver = new ChromeDriver();
            driver.get("https://example.com");
            // Test steps
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (driver != null) {
                driver.quit();  // Always quit
            }
        }
    }
}
```
**Follow-up**: What happens if both try and finally throw exceptions? Which exception is propagated? Can you have try without catch? try without finally?

---

### Q40: What is throw vs throws?
**Difficulty**: Basic | **Experience**: 0-2, 3-5
**Companies**: TCS, Infosys, Cognizant
**Answer**:
- **throw**: Keyword used to explicitly throw an exception in code. Followed by exception object. Used inside method body.
- **throws**: Keyword used in method signature to declare that method may throw exceptions. Followed by exception class names. Multiple exceptions separated by comma.
**Code**:
```java
// throws - Declare exceptions in method signature
class ThrowsExample {
    // Declares that this method might throw IOException
    public void readFile(String filename) throws IOException {
        FileReader file = new FileReader(filename);
        // If file not found, IOException is thrown
    }

    // Multiple exceptions
    public void connectDatabase(String url)
            throws SQLException, ClassNotFoundException {
        Class.forName("com.mysql.jdbc.Driver");
        DriverManager.getConnection(url);
    }

    // Calling method must handle or declare
    public void caller() {
        try {
            readFile("test.txt");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // Or propagate exception
    public void callerPropagating() throws IOException {
        readFile("test.txt");  // Pass exception to caller
    }
}

// throw - Explicitly throw exception
class ThrowExample {
    // Throw checked exception
    public void validateAge(int age) throws InvalidAgeException {
        if (age < 18) {
            throw new InvalidAgeException("Age must be 18 or above");
            // throw keyword + new exception object
        }
        System.out.println("Valid age");
    }

    // Throw unchecked exception (no need to declare)
    public void divide(int a, int b) {
        if (b == 0) {
            throw new ArithmeticException("Cannot divide by zero");
        }
        int result = a / b;
    }

    // Re-throwing exception
    public void processFile() throws IOException {
        try {
            FileReader file = new FileReader("test.txt");
        } catch (IOException e) {
            System.out.println("Error occurred");
            throw e;  // Re-throw to caller
        }
    }

    // Throwing different exception
    public void processData() throws CustomException {
        try {
            // Some code
        } catch (IOException e) {
            throw new CustomException("Data processing failed", e);
            // Wrap original exception
        }
    }
}

// Real-world example: Form validation
class UserRegistration {
    public void registerUser(String email, String password)
            throws ValidationException {  // throws in signature

        // throw to signal validation errors
        if (email == null || email.isEmpty()) {
            throw new ValidationException("Email is required");
        }

        if (!email.contains("@")) {
            throw new ValidationException("Invalid email format");
        }

        if (password == null || password.length() < 8) {
            throw new ValidationException("Password must be at least 8 characters");
        }

        // Registration logic
    }
}

// Real-world Selenium example
class SeleniumValidation {
    private WebDriver driver;

    // throws - declare exception
    public void navigateToPage(String url) throws IllegalArgumentException {
        if (url == null || url.isEmpty()) {
            // throw - explicitly throw exception
            throw new IllegalArgumentException("URL cannot be null or empty");
        }
        driver.get(url);
    }

    public void clickElement(By locator) throws ElementNotFoundException {
        try {
            driver.findElement(locator).click();
        } catch (NoSuchElementException e) {
            // Wrap and throw custom exception
            throw new ElementNotFoundException(
                "Element not found: " + locator, e
            );
        }
    }
}

// Comparison table
/*
Feature         | throw                    | throws
----------------|--------------------------|---------------------------
Purpose         | Throw exception          | Declare exceptions
Location        | Inside method body       | Method signature
Followed by     | Exception object         | Exception class name(s)
Multiple        | One per statement        | Multiple with comma
Example         | throw new Exception()    | throws IOException, SQLException
*/
```
**Follow-up**: Can you throw multiple exceptions with single throw? Can a method throw exception but not declare it? What happens if you don't handle declared exception?

---

### Q41: How to create custom exceptions?
**Difficulty**: Medium | **Experience**: 3-5, 6-8
**Companies**: Amazon, Google, Microsoft
**Answer**: Create custom exception by extending Exception (checked) or RuntimeException (unchecked). Add constructors: default, with message, with cause, with both. Follow naming convention: end with "Exception". Make it immutable and serializable. Include meaningful error messages.
**Code**:
```java
// Custom checked exception
class InvalidTestDataException extends Exception {
    // Constructor with message
    public InvalidTestDataException(String message) {
        super(message);
    }

    // Constructor with message and cause
    public InvalidTestDataException(String message, Throwable cause) {
        super(message, cause);
    }

    // Constructor with cause
    public InvalidTestDataException(Throwable cause) {
        super(cause);
    }

    // Default constructor
    public InvalidTestDataException() {
        super("Invalid test data");
    }
}

// Custom unchecked exception
class ElementNotFoundException extends RuntimeException {
    private String locator;

    public ElementNotFoundException(String message) {
        super(message);
    }

    public ElementNotFoundException(String message, String locator) {
        super(message);
        this.locator = locator;
    }

    public ElementNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }

    public String getLocator() {
        return locator;
    }
}

// Using custom exceptions
class TestDataManager {
    public void loadTestData(String filename) throws InvalidTestDataException {
        if (filename == null || filename.isEmpty()) {
            throw new InvalidTestDataException("Filename cannot be null or empty");
        }

        try {
            // Load data from file
            FileReader reader = new FileReader(filename);
        } catch (FileNotFoundException e) {
            throw new InvalidTestDataException(
                "Test data file not found: " + filename, e
            );
        }
    }
}

class PageObjectBase {
    protected WebDriver driver;

    protected WebElement findElement(By locator) {
        try {
            return driver.findElement(locator);
        } catch (NoSuchElementException e) {
            throw new ElementNotFoundException(
                "Element not found on page",
                locator.toString()
            );
        }
    }
}

// Real-world example: Framework exceptions
// Base exception for framework
abstract class FrameworkException extends RuntimeException {
    public FrameworkException(String message) {
        super(message);
    }

    public FrameworkException(String message, Throwable cause) {
        super(message, cause);
    }
}

// Specific framework exceptions
class ConfigurationException extends FrameworkException {
    public ConfigurationException(String message) {
        super(message);
    }
}

class TestExecutionException extends FrameworkException {
    private String testName;

    public TestExecutionException(String message, String testName) {
        super(message);
        this.testName = testName;
    }

    public TestExecutionException(String message, String testName, Throwable cause) {
        super(message, cause);
        this.testName = testName;
    }

    public String getTestName() {
        return testName;
    }
}

class PageLoadException extends FrameworkException {
    private String url;
    private int timeout;

    public PageLoadException(String message, String url, int timeout) {
        super(message);
        this.url = url;
        this.timeout = timeout;
    }

    @Override
    public String getMessage() {
        return super.getMessage() +
               " [URL: " + url + ", Timeout: " + timeout + "s]";
    }
}

// Usage in framework
class ConfigManager {
    public void loadConfig(String configFile) {
        if (!new File(configFile).exists()) {
            throw new ConfigurationException(
                "Configuration file not found: " + configFile
            );
        }
    }
}

class TestRunner {
    public void executeTest(String testName) {
        try {
            // Test execution logic
        } catch (Exception e) {
            throw new TestExecutionException(
                "Test execution failed",
                testName,
                e
            );
        }
    }
}

class BasePage {
    protected WebDriver driver;

    public void waitForPageLoad(String url, int timeout) {
        try {
            new WebDriverWait(driver, Duration.ofSeconds(timeout))
                .until(ExpectedConditions.urlToBe(url));
        } catch (TimeoutException e) {
            throw new PageLoadException(
                "Page did not load within timeout",
                url,
                timeout
            );
        }
    }
}

// API Testing custom exceptions
class APIException extends RuntimeException {
    private int statusCode;
    private String endpoint;

    public APIException(String message, int statusCode, String endpoint) {
        super(message);
        this.statusCode = statusCode;
        this.endpoint = endpoint;
    }

    @Override
    public String getMessage() {
        return super.getMessage() +
               " [Status: " + statusCode + ", Endpoint: " + endpoint + "]";
    }
}

class APIClient {
    public Response sendRequest(String endpoint) {
        Response response = RestAssured.get(endpoint);

        if (response.getStatusCode() >= 400) {
            throw new APIException(
                "API request failed",
                response.getStatusCode(),
                endpoint
            );
        }

        return response;
    }
}

// Best practices for custom exceptions
/*
1. Extend Exception (checked) or RuntimeException (unchecked) appropriately
2. Provide multiple constructors
3. Follow naming convention: *Exception
4. Include meaningful messages
5. Add relevant context (fields, getters)
6. Override getMessage() if needed for formatted output
7. Make immutable (final class, final fields)
8. Document with JavaDoc
9. Declare serialVersionUID if serializable
*/
```
**Follow-up**: When to create checked vs unchecked custom exception? Should custom exceptions be serializable? How to design exception hierarchy?

---

### Q42: What is exception chaining?
**Difficulty**: Medium | **Experience**: 6-8, 9-12
**Companies**: Google, Amazon, Microsoft
**Answer**: Exception chaining (nested exceptions) allows you to preserve original cause when throwing new exception. Use constructor that accepts Throwable cause parameter. getCause() retrieves original exception. Useful for wrapping low-level exceptions in high-level exceptions while preserving stack trace.
**Code**:
```java
// Basic exception chaining
class ExceptionChainingDemo {
    public void method1() throws CustomException {
        try {
            method2();
        } catch (SQLException e) {
            // Wrap SQLException in CustomException
            throw new CustomException("Database operation failed", e);
            // Original exception preserved as cause
        }
    }

    public void method2() throws SQLException {
        // Simulate database error
        throw new SQLException("Connection timeout");
    }

    public static void main(String[] args) {
        try {
            new ExceptionChainingDemo().method1();
        } catch (CustomException e) {
            System.out.println("Exception: " + e.getMessage());
            System.out.println("Caused by: " + e.getCause().getMessage());

            // Print full stack trace (shows chain)
            e.printStackTrace();
        }
    }
}

// Real-world example: Framework exception chaining
class DataReader {
    public Map<String, String> readTestData(String filename)
            throws TestDataException {
        try {
            // Try to read JSON file
            return parseJSON(filename);
        } catch (FileNotFoundException e) {
            // Wrap in TestDataException
            throw new TestDataException(
                "Test data file not found: " + filename, e
            );
        } catch (JSONException e) {
            // Wrap in TestDataException
            throw new TestDataException(
                "Invalid JSON format in: " + filename, e
            );
        }
    }

    private Map<String, String> parseJSON(String filename)
            throws FileNotFoundException, JSONException {
        // JSON parsing logic
        throw new FileNotFoundException();  // Simulated
    }
}

// Multiple levels of exception chaining
class MultiLevelChaining {
    // Layer 1: Data access layer
    public void databaseQuery() throws SQLException {
        throw new SQLException("Connection failed");
    }

    // Layer 2: Service layer
    public void userService() throws ServiceException {
        try {
            databaseQuery();
        } catch (SQLException e) {
            throw new ServiceException("User service failed", e);
        }
    }

    // Layer 3: Controller layer
    public void handleRequest() throws RequestException {
        try {
            userService();
        } catch (ServiceException e) {
            throw new RequestException("Request processing failed", e);
        }
    }

    // Client code
    public static void main(String[] args) {
        try {
            new MultiLevelChaining().handleRequest();
        } catch (RequestException e) {
            // Traverse exception chain
            Throwable cause = e;
            while (cause != null) {
                System.out.println("Exception: " + cause.getClass().getName() +
                                   " - " + cause.getMessage());
                cause = cause.getCause();
            }

            // Output:
            // RequestException - Request processing failed
            // ServiceException - User service failed
            // SQLException - Connection failed
        }
    }
}

// Selenium/API framework example
class FrameworkExceptionChaining {
    private WebDriver driver;

    // Low-level method
    public WebElement findElement(By locator) throws ElementException {
        try {
            return driver.findElement(locator);
        } catch (NoSuchElementException e) {
            throw new ElementException(
                "Element not found: " + locator, e
            );
        } catch (StaleElementReferenceException e) {
            throw new ElementException(
                "Element is stale: " + locator, e
            );
        }
    }

    // Mid-level method
    public void clickElement(By locator) throws PageException {
        try {
            WebElement element = findElement(locator);
            element.click();
        } catch (ElementException e) {
            throw new PageException(
                "Failed to click element", e
            );
        } catch (WebDriverException e) {
            throw new PageException(
                "WebDriver error during click", e
            );
        }
    }

    // High-level method
    public void performLogin(String username, String password)
            throws TestException {
        try {
            clickElement(By.id("username"));
            clickElement(By.id("submit"));
        } catch (PageException e) {
            throw new TestException(
                "Login test failed", e
            );
        }
    }
}

// initCause() method
class InitCauseExample {
    public void demonstrateInitCause() throws CustomException {
        CustomException exception = new CustomException("High-level error");

        try {
            // Some code that throws exception
            throw new IOException("Low-level error");
        } catch (IOException e) {
            exception.initCause(e);  // Set cause after construction
            throw exception;
        }
    }
}

// Suppressed exceptions (try-with-resources)
class SuppressedExceptionsDemo {
    public void demonstrateSuppressed() {
        try (MyResource resource = new MyResource()) {
            throw new RuntimeException("Exception in try block");
        }
        // If close() also throws exception, it's added as "suppressed"
    }

    static class MyResource implements AutoCloseable {
        @Override
        public void close() {
            throw new RuntimeException("Exception in close()");
        }
    }

    public static void main(String[] args) {
        try {
            new SuppressedExceptionsDemo().demonstrateSuppressed();
        } catch (RuntimeException e) {
            System.out.println("Main exception: " + e.getMessage());

            // Get suppressed exceptions
            Throwable[] suppressed = e.getSuppressed();
            for (Throwable t : suppressed) {
                System.out.println("Suppressed: " + t.getMessage());
            }
        }
    }
}

// Utility method to print exception chain
class ExceptionUtils {
    public static void printExceptionChain(Throwable throwable) {
        int level = 0;
        Throwable cause = throwable;

        while (cause != null) {
            System.out.println("  ".repeat(level) +
                cause.getClass().getSimpleName() + ": " +
                cause.getMessage());

            // Print suppressed exceptions
            for (Throwable suppressed : cause.getSuppressed()) {
                System.out.println("  ".repeat(level + 1) +
                    "Suppressed: " + suppressed.getMessage());
            }

            cause = cause.getCause();
            level++;
        }
    }

    public static Throwable getRootCause(Throwable throwable) {
        Throwable cause = throwable;
        while (cause.getCause() != null) {
            cause = cause.getCause();
        }
        return cause;
    }
}
```
**Follow-up**: What is the benefit of exception chaining? How to get root cause? What are suppressed exceptions? When are they used?

---

## Java 8+ Features (8 Questions)

### Q43: What are lambda expressions? Explain with examples
**Difficulty**: Medium | **Experience**: 3-5, 6-8, 9-12
**Companies**: Google, Amazon, Microsoft, Adobe
**Answer**: Lambda expressions (Java 8+) provide clear and concise way to represent functional interface using an expression. Syntax: `(parameters) -> expression` or `(parameters) -> { statements; }`. Enable functional programming in Java. Used with functional interfaces (single abstract method). Reduce boilerplate code.
**Code**:
```java
// Before lambdas (Java 7) - Verbose
Runnable runnable = new Runnable() {
    @Override
    public void run() {
        System.out.println("Hello World");
    }
};
new Thread(runnable).start();

// With lambda (Java 8+) - Concise
Runnable runnableLambda = () -> System.out.println("Hello World");
new Thread(runnableLambda).start();

// Even more concise
new Thread(() -> System.out.println("Hello World")).start();

// Lambda syntax variations
// 1. No parameters
Runnable r1 = () -> System.out.println("No parameters");

// 2. One parameter (parentheses optional)
Consumer<String> c1 = (String s) -> System.out.println(s);
Consumer<String> c2 = s -> System.out.println(s);  // Type inferred

// 3. Multiple parameters
BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;

// 4. Multiple statements (need braces and return)
BiFunction<Integer, Integer, Integer> multiply = (a, b) -> {
    int result = a * b;
    System.out.println("Result: " + result);
    return result;
};

// Real-world examples
// 1. Sorting with Comparator
List<String> names = Arrays.asList("John", "Alice", "Bob");

// Before lambda
Collections.sort(names, new Comparator<String>() {
    @Override
    public int compare(String s1, String s2) {
        return s1.compareTo(s2);
    }
});

// With lambda
Collections.sort(names, (s1, s2) -> s1.compareTo(s2));

// Even shorter with method reference
Collections.sort(names, String::compareTo);
names.sort(String::compareTo);

// 2. Filtering collections
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

// Get even numbers using lambda
List<Integer> evenNumbers = numbers.stream()
    .filter(n -> n % 2 == 0)
    .collect(Collectors.toList());
// [2, 4, 6, 8, 10]

// 3. forEach with lambda
numbers.forEach(n -> System.out.println(n));
numbers.forEach(System.out::println);  // Method reference

// 4. Map transformation
List<String> upperNames = names.stream()
    .map(name -> name.toUpperCase())
    .collect(Collectors.toList());

// 5. Custom functional interface
@FunctionalInterface
interface Calculator {
    int calculate(int a, int b);
}

Calculator add = (a, b) -> a + b;
Calculator subtract = (a, b) -> a - b;
Calculator multiply = (a, b) -> a * b;
Calculator divide = (a, b) -> a / b;

System.out.println(add.calculate(10, 5));       // 15
System.out.println(subtract.calculate(10, 5));  // 5

// 6. Button click handler (if using JavaFX)
button.setOnAction(event -> {
    System.out.println("Button clicked");
    // Handle click
});

// 7. Selenium WebDriver with lambda
List<WebElement> elements = driver.findElements(By.cssSelector(".item"));
elements.forEach(element -> {
    System.out.println(element.getText());
    element.click();
});

// 8. API testing with lambda
List<String> endpoints = Arrays.asList("/users", "/posts", "/comments");
endpoints.forEach(endpoint -> {
    Response response = RestAssured.get(endpoint);
    System.out.println(endpoint + ": " + response.getStatusCode());
});

// 9. Parallel test execution with lambda
List<String> testCases = Arrays.asList("Test1", "Test2", "Test3");
testCases.parallelStream().forEach(testCase -> {
    // Run test
    System.out.println("Executing: " + testCase);
});

// 10. Common functional interfaces
// Predicate<T> - takes T, returns boolean
Predicate<Integer> isEven = n -> n % 2 == 0;
System.out.println(isEven.test(4));  // true

// Function<T, R> - takes T, returns R
Function<String, Integer> stringLength = s -> s.length();
System.out.println(stringLength.apply("Hello"));  // 5

// Consumer<T> - takes T, returns void
Consumer<String> printer = s -> System.out.println(s);
printer.accept("Hello");

// Supplier<T> - takes nothing, returns T
Supplier<Double> randomValue = () -> Math.random();
System.out.println(randomValue.get());

// BiFunction<T, U, R> - takes T and U, returns R
BiFunction<String, String, String> concat = (s1, s2) -> s1 + s2;
System.out.println(concat.apply("Hello", "World"));
```
**Follow-up**: What is a functional interface? Can lambda access local variables? What are effectively final variables? What is method reference?

---

### Q44: What is Stream API? Explain with examples
**Difficulty**: Medium | **Experience**: 3-5, 6-8, 9-12
**Companies**: Google, Amazon, Microsoft, Adobe, Flipkart
**Answer**: Stream API (Java 8+) processes collections in declarative way. Streams don't store data; they convey data from source through pipeline of operations. Two types of operations: Intermediate (filter, map, sorted - lazy, return stream) and Terminal (collect, forEach, reduce - eager, trigger processing). Streams can be sequential or parallel.
**Code**:
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

// 1. Filter - Select elements matching predicate
List<Integer> evenNumbers = numbers.stream()
    .filter(n -> n % 2 == 0)
    .collect(Collectors.toList());
// [2, 4, 6, 8, 10]

// 2. Map - Transform elements
List<Integer> squared = numbers.stream()
    .map(n -> n * n)
    .collect(Collectors.toList());
// [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

// 3. Filter + Map combined
List<Integer> evenSquares = numbers.stream()
    .filter(n -> n % 2 == 0)
    .map(n -> n * n)
    .collect(Collectors.toList());
// [4, 16, 36, 64, 100]

// 4. Sorted
List<Integer> sorted = numbers.stream()
    .sorted(Comparator.reverseOrder())
    .collect(Collectors.toList());

// 5. Distinct - Remove duplicates
List<Integer> duplicates = Arrays.asList(1, 2, 2, 3, 3, 4, 5);
List<Integer> unique = duplicates.stream()
    .distinct()
    .collect(Collectors.toList());

// 6. Limit and Skip
List<Integer> first3 = numbers.stream()
    .limit(3)
    .collect(Collectors.toList());  // [1, 2, 3]

List<Integer> skip5 = numbers.stream()
    .skip(5)
    .collect(Collectors.toList());  // [6, 7, 8, 9, 10]

// 7. forEach - Terminal operation
numbers.stream()
    .filter(n -> n % 2 == 0)
    .forEach(System.out::println);

// 8. count - Terminal operation
long count = numbers.stream()
    .filter(n -> n > 5)
    .count();  // 5

// 9. anyMatch, allMatch, noneMatch
boolean hasEven = numbers.stream().anyMatch(n -> n % 2 == 0);  // true
boolean allPositive = numbers.stream().allMatch(n -> n > 0);   // true
boolean noneNegative = numbers.stream().noneMatch(n -> n < 0); // true

// 10. findFirst, findAny
Optional<Integer> first = numbers.stream()
    .filter(n -> n > 5)
    .findFirst();  // Optional[6]

Optional<Integer> any = numbers.parallelStream()
    .filter(n -> n > 5)
    .findAny();    // Optional[any element > 5]

// 11. reduce - Aggregation
int sum = numbers.stream()
    .reduce(0, (a, b) -> a + b);  // 55

int product = numbers.stream()
    .reduce(1, (a, b) -> a * b);

Optional<Integer> max = numbers.stream()
    .reduce(Integer::max);

// 12. min, max
Optional<Integer> min = numbers.stream().min(Integer::compareTo);
Optional<Integer> max2 = numbers.stream().max(Integer::compareTo);

// 13. Collectors
List<Integer> list = numbers.stream().collect(Collectors.toList());
Set<Integer> set = numbers.stream().collect(Collectors.toSet());

String joined = numbers.stream()
    .map(String::valueOf)
    .collect(Collectors.joining(", "));  // "1, 2, 3, 4..."

// 14. groupingBy
List<String> names = Arrays.asList("John", "Jane", "Jack", "Bob", "Alice");
Map<Integer, List<String>> byLength = names.stream()
    .collect(Collectors.groupingBy(String::length));
// {3=[Bob], 4=[John, Jane, Jack], 5=[Alice]}

// 15. partitioningBy
Map<Boolean, List<Integer>> partitioned = numbers.stream()
    .collect(Collectors.partitioningBy(n -> n % 2 == 0));
// {false=[1,3,5,7,9], true=[2,4,6,8,10]}

// 16. flatMap - Flatten nested structures
List<List<Integer>> nested = Arrays.asList(
    Arrays.asList(1, 2),
    Arrays.asList(3, 4),
    Arrays.asList(5, 6)
);
List<Integer> flattened = nested.stream()
    .flatMap(List::stream)
    .collect(Collectors.toList());
// [1, 2, 3, 4, 5, 6]

// 17. peek - Debugging
List<Integer> result = numbers.stream()
    .filter(n -> n % 2 == 0)
    .peek(n -> System.out.println("Filtered: " + n))
    .map(n -> n * 2)
    .peek(n -> System.out.println("Mapped: " + n))
    .collect(Collectors.toList());

// 18. Parallel streams
List<Integer> parallelResult = numbers.parallelStream()
    .filter(n -> n % 2 == 0)
    .map(n -> n * n)
    .collect(Collectors.toList());

// 19. Real-world example: Employee processing
class Employee {
    String name;
    int age;
    double salary;
    String department;
}

List<Employee> employees = getEmployees();

// Get names of employees in IT dept with salary > 50000
List<String> itHighEarners = employees.stream()
    .filter(e -> e.department.equals("IT"))
    .filter(e -> e.salary > 50000)
    .map(Employee::getName)
    .sorted()
    .collect(Collectors.toList());

// Average salary by department
Map<String, Double> avgSalaryByDept = employees.stream()
    .collect(Collectors.groupingBy(
        Employee::getDepartment,
        Collectors.averagingDouble(Employee::getSalary)
    ));

// 20. Selenium example: Process web elements
List<WebElement> elements = driver.findElements(By.cssSelector(".item"));
List<String> texts = elements.stream()
    .filter(WebElement::isDisplayed)
    .map(WebElement::getText)
    .filter(text -> !text.isEmpty())
    .collect(Collectors.toList());

// 21. API Testing example: Process responses
List<String> endpoints = Arrays.asList("/users", "/posts", "/comments");
List<Integer> statusCodes = endpoints.stream()
    .map(endpoint -> RestAssured.get(endpoint))
    .map(Response::getStatusCode)
    .filter(code -> code >= 200 && code < 300)
    .collect(Collectors.toList());

// Stream creation methods
Stream<String> stream1 = Stream.of("a", "b", "c");
Stream<Integer> stream2 = Stream.iterate(0, n -> n + 2).limit(10);
Stream<Double> stream3 = Stream.generate(Math::random).limit(5);
IntStream range = IntStream.range(1, 10);  // 1 to 9
IntStream rangeClosed = IntStream.rangeClosed(1, 10);  // 1 to 10
```
**Follow-up**: What's difference between intermediate and terminal operations? What is lazy evaluation? Can you reuse streams? What's difference between stream() and parallelStream()?

---

### Q45: What is Optional class? Why use it?
**Difficulty**: Medium | **Experience**: 6-8, 9-12
**Companies**: Google, Amazon, Microsoft, Adobe
**Answer**: Optional is a container object (Java 8+) that may or may not contain a non-null value. Helps avoid NullPointerException. Forces explicit handling of absence of value. Better than returning null. Methods: of(), ofNullable(), empty(), isPresent(), ifPresent(), orElse(), orElseGet(), orElseThrow(), map(), flatMap(), filter().
**Code**:
```java
// Creating Optional
Optional<String> optional1 = Optional.of("Hello");           // Value must not be null
Optional<String> optional2 = Optional.ofNullable("Hello");   // Value can be null
Optional<String> optional3 = Optional.ofNullable(null);      // Empty optional
Optional<String> optional4 = Optional.empty();               // Empty optional

// Optional.of() with null throws NullPointerException
// Optional<String> error = Optional.of(null);  // NPE

// Checking if value is present
if (optional1.isPresent()) {
    System.out.println(optional1.get());
}

// Better way - ifPresent with lambda
optional1.ifPresent(value -> System.out.println(value));
optional1.ifPresent(System.out::println);

// Providing default values
String value1 = optional3.orElse("Default");              // "Default"
String value2 = optional1.orElse("Default");              // "Hello"

String value3 = optional3.orElseGet(() -> "Generated");   // Lazy evaluation
String value4 = optional3.orElseThrow(() ->
    new IllegalArgumentException("Value not present"));

// Java 9+ - ifPresentOrElse
optional1.ifPresentOrElse(
    value -> System.out.println("Present: " + value),
    () -> System.out.println("Not present")
);

// Java 9+ - or() - provide alternative Optional
Optional<String> result = optional3.or(() -> Optional.of("Alternative"));

// Transforming Optional - map()
Optional<String> upper = optional1.map(String::toUpperCase);  // Optional["HELLO"]

Optional<Integer> length = optional1.map(String::length);     // Optional[5]

// flatMap - when mapping function returns Optional
Optional<String> opt = Optional.of("hello");
Optional<String> result2 = opt.flatMap(s -> Optional.of(s.toUpperCase()));

// filter - keep value only if matches predicate
Optional<String> filtered = optional1.filter(s -> s.length() > 3);

// Real-world example: Repository pattern
class UserRepository {
    public Optional<User> findById(Long id) {
        User user = database.findUser(id);
        return Optional.ofNullable(user);  // Might be null
    }
}

// Without Optional (old way - bad)
User user = userRepository.findUser(id);
if (user != null) {
    System.out.println(user.getName());
} else {
    System.out.println("User not found");
}

// With Optional (new way - good)
Optional<User> userOpt = userRepository.findById(id);
userOpt.ifPresent(user -> System.out.println(user.getName()));

String userName = userOpt
    .map(User::getName)
    .orElse("Unknown");

// Chaining Optional operations
String email = userRepository.findById(id)
    .map(User::getEmail)
    .filter(e -> e.contains("@"))
    .map(String::toLowerCase)
    .orElse("no-email@example.com");

// Avoiding nested nulls
class Address {
    private String city;
    public Optional<String> getCity() {
        return Optional.ofNullable(city);
    }
}

class User {
    private Address address;
    public Optional<Address> getAddress() {
        return Optional.ofNullable(address);
    }
}

// Old way - nested null checks (bad)
String city = null;
if (user != null) {
    if (user.getAddress() != null) {
        if (user.getAddress().getCity() != null) {
            city = user.getAddress().getCity();
        }
    }
}

// With Optional (good)
Optional<User> userOpt2 = Optional.ofNullable(user);
String city2 = userOpt2
    .flatMap(User::getAddress)
    .flatMap(Address::getCity)
    .orElse("Unknown");

// Selenium example: Finding element
public Optional<WebElement> findElementSafe(By locator) {
    try {
        return Optional.of(driver.findElement(locator));
    } catch (NoSuchElementException e) {
        return Optional.empty();
    }
}

// Usage
findElementSafe(By.id("button"))
    .ifPresent(WebElement::click);

String text = findElementSafe(By.id("message"))
    .map(WebElement::getText)
    .orElse("No message");

// API Testing example
public Optional<String> getResponseField(Response response, String field) {
    try {
        return Optional.ofNullable(response.jsonPath().getString(field));
    } catch (Exception e) {
        return Optional.empty();
    }
}

String userId = getResponseField(response, "data.user.id")
    .orElseThrow(() -> new AssertionError("User ID not found"));

// Stream with Optional (Java 9+)
List<Optional<String>> optionals = Arrays.asList(
    Optional.of("A"),
    Optional.empty(),
    Optional.of("B")
);

List<String> values = optionals.stream()
    .flatMap(Optional::stream)  // Java 9+
    .collect(Collectors.toList());  // [A, B]

// Common mistakes to avoid
// BAD: Don't do this
if (optional.isPresent()) {
    return optional.get();
} else {
    return "default";
}

// GOOD: Use orElse
return optional.orElse("default");

// BAD: Don't call get() without checking
String value = optional.get();  // NoSuchElementException if empty

// GOOD: Use orElse, orElseGet, or orElseThrow
String value5 = optional.orElse("default");
```
**Follow-up**: When should you use Optional? Should Optional be used as method parameter? What's difference between orElse() and orElseGet()? Can Optional contain null?

---

### Q46: What are method references?
**Difficulty**: Medium | **Experience**: 3-5, 6-8, 9-12
**Companies**: Google, Amazon, Microsoft
**Answer**: Method reference (Java 8+) is shorthand notation for lambda expression that calls a single method. Four types: Static method reference (ClassName::methodName), Instance method reference (object::methodName), Instance method of arbitrary object (ClassName::methodName), Constructor reference (ClassName::new). More readable than lambdas when just calling a method.
**Code**:
```java
List<String> names = Arrays.asList("John", "Alice", "Bob");

// 1. Static method reference (ClassName::methodName)
// Lambda
names.forEach(name -> System.out.println(name));

// Method reference - Static method
names.forEach(System.out::println);

// Example with Integer.parseInt
List<String> numbers = Arrays.asList("1", "2", "3");
List<Integer> integers = numbers.stream()
    .map(s -> Integer.parseInt(s))      // Lambda
    .collect(Collectors.toList());

List<Integer> integers2 = numbers.stream()
    .map(Integer::parseInt)              // Method reference
    .collect(Collectors.toList());

// 2. Instance method reference of particular object (object::methodName)
String prefix = "Hello ";
Function<String, String> greeter1 = name -> prefix.concat(name);  // Lambda
Function<String, String> greeter2 = prefix::concat;               // Method reference

System.out.println(greeter2.apply("World"));  // "Hello World"

// 3. Instance method reference of arbitrary object (ClassName::methodName)
// Lambda - calling method on the parameter
names.stream()
    .map(s -> s.toUpperCase())           // Lambda
    .forEach(System.out::println);

// Method reference
names.stream()
    .map(String::toUpperCase)            // Method reference
    .forEach(System.out::println);

// Sorting example
// Lambda
Collections.sort(names, (s1, s2) -> s1.compareTo(s2));

// Method reference
Collections.sort(names, String::compareTo);

// 4. Constructor reference (ClassName::new)
// Lambda
Supplier<ArrayList<String>> supplier1 = () -> new ArrayList<>();

// Method reference
Supplier<ArrayList<String>> supplier2 = ArrayList::new;

// With Function
Function<Integer, ArrayList<String>> func1 = size -> new ArrayList<>(size);
Function<Integer, ArrayList<String>> func2 = ArrayList::new;

List<String> list = func2.apply(10);

// Creating objects from stream
List<String> strings = Arrays.asList("John", "Alice", "Bob");
List<Person> persons = strings.stream()
    .map(name -> new Person(name))       // Lambda
    .collect(Collectors.toList());

List<Person> persons2 = strings.stream()
    .map(Person::new)                    // Constructor reference
    .collect(Collectors.toList());

// Real-world examples
// Example 1: Converting list of strings to integers
List<String> stringNumbers = Arrays.asList("1", "2", "3", "4", "5");

// Lambda
List<Integer> nums1 = stringNumbers.stream()
    .map(s -> Integer.valueOf(s))
    .collect(Collectors.toList());

// Method reference
List<Integer> nums2 = stringNumbers.stream()
    .map(Integer::valueOf)
    .collect(Collectors.toList());

// Example 2: Filtering and collecting
List<String> items = Arrays.asList("apple", "", "banana", "", "cherry");

// Lambda
List<String> nonEmpty1 = items.stream()
    .filter(s -> !s.isEmpty())
    .collect(Collectors.toList());

// Method reference (needs helper method)
List<String> nonEmpty2 = items.stream()
    .filter(((Predicate<String>) String::isEmpty).negate())
    .collect(Collectors.toList());

// Example 3: Selenium WebDriver
List<WebElement> elements = driver.findElements(By.cssSelector(".item"));

// Lambda
elements.forEach(element -> element.click());

// Method reference
elements.forEach(WebElement::click);

// Get all texts
List<String> texts1 = elements.stream()
    .map(element -> element.getText())    // Lambda
    .collect(Collectors.toList());

List<String> texts2 = elements.stream()
    .map(WebElement::getText)             // Method reference
    .collect(Collectors.toList());

// Example 4: Comparing with custom class
class Employee {
    String name;
    int salary;

    public String getName() { return name; }
    public int getSalary() { return salary; }
}

List<Employee> employees = getEmployees();

// Lambda
employees.sort((e1, e2) -> e1.getName().compareTo(e2.getName()));

// Method reference with Comparator
employees.sort(Comparator.comparing(Employee::getName));
employees.sort(Comparator.comparingInt(Employee::getSalary));

// Reverse order
employees.sort(Comparator.comparing(Employee::getName).reversed());

// Multiple criteria
employees.sort(Comparator.comparing(Employee::getName)
                         .thenComparingInt(Employee::getSalary));

// Example 5: Thread creation
// Lambda
Thread thread1 = new Thread(() -> System.out.println("Hello"));

// Method reference (if method exists)
Thread thread2 = new Thread(MyClass::myMethod);

// Example 6: API Testing
List<Response> responses = endpoints.stream()
    .map(endpoint -> RestAssured.get(endpoint))      // Lambda
    .collect(Collectors.toList());

List<Response> responses2 = endpoints.stream()
    .map(RestAssured::get)                           // Won't work directly
    .collect(Collectors.toList());

List<Integer> statusCodes = responses.stream()
    .map(response -> response.getStatusCode())       // Lambda
    .collect(Collectors.toList());

List<Integer> statusCodes2 = responses.stream()
    .map(Response::getStatusCode)                    // Method reference
    .collect(Collectors.toList());

// Array method reference
String[] array = {"apple", "banana", "cherry"};

// Lambda
Arrays.sort(array, (s1, s2) -> s1.compareTo(s2));

// Method reference
Arrays.sort(array, String::compareTo);

// Summary of method reference types:
/*
Type                           | Syntax              | Lambda Equivalent
-------------------------------|---------------------|----------------------------------
Static method                  | ClassName::method   | (args) -> ClassName.method(args)
Instance method of object      | obj::method         | (args) -> obj.method(args)
Instance method of class       | ClassName::method   | (obj, args) -> obj.method(args)
Constructor                    | ClassName::new      | (args) -> new ClassName(args)
Array constructor              | Type[]::new         | (size) -> new Type[size]
*/
```
**Follow-up**: Can you use method reference with multiple parameters? What's the performance difference between lambda and method reference? When to use lambda vs method reference?

---

### Q47: What are default methods in interfaces?
**Difficulty**: Medium | **Experience**: 3-5, 6-8
**Companies**: Amazon, Microsoft, Oracle
**Answer**: Default methods (Java 8+) allow interfaces to have method implementations. Use 'default' keyword. Enables adding new methods to interfaces without breaking existing implementations. Provides backward compatibility. Can be overridden by implementing class. Solves "diamond problem" - class implementation takes precedence over interface default.
**Code**:
```java
// Interface with default method
interface Vehicle {
    // Abstract method
    void start();

    // Default method (Java 8+)
    default void stop() {
        System.out.println("Vehicle stopped");
    }

    // Static method (Java 8+)
    static void info() {
        System.out.println("This is a vehicle");
    }
}

class Car implements Vehicle {
    @Override
    public void start() {
        System.out.println("Car started");
    }

    // Can optionally override default method
    @Override
    public void stop() {
        System.out.println("Car stopped with brakes");
    }
}

class Bike implements Vehicle {
    @Override
    public void start() {
        System.out.println("Bike started");
    }

    // Uses default stop() method - no override needed
}

// Usage
Car car = new Car();
car.start();  // Car started
car.stop();   // Car stopped with brakes

Bike bike = new Bike();
bike.start(); // Bike started
bike.stop();  // Vehicle stopped (default implementation)

Vehicle.info();  // This is a vehicle (static method)

// Real-world example: Adding to existing interface
interface List<E> {
    // Existing methods
    boolean add(E e);
    E get(int index);

    // Java 8 added default methods without breaking existing implementations
    default void forEach(Consumer<? super E> action) {
        for (E element : this) {
            action.accept(element);
        }
    }

    default Spliterator<E> spliterator() {
        return Spliterators.spliterator(this, 0);
    }

    default void sort(Comparator<? super E> c) {
        Object[] array = this.toArray();
        Arrays.sort(array, (Comparator) c);
        // ... update list
    }
}

// Multiple interfaces with default methods
interface Flyable {
    default void fly() {
        System.out.println("Flying");
    }
}

interface Swimmable {
    default void swim() {
        System.out.println("Swimming");
    }
}

// Class implementing both
class Duck implements Flyable, Swimmable {
    // Inherits both default methods
}

Duck duck = new Duck();
duck.fly();   // Flying
duck.swim();  // Swimming

// Diamond problem - Same method in multiple interfaces
interface Interface1 {
    default void print() {
        System.out.println("Interface1");
    }
}

interface Interface2 {
    default void print() {
        System.out.println("Interface2");
    }
}

// Must override to resolve conflict
class MyClass implements Interface1, Interface2 {
    @Override
    public void print() {
        // Must provide implementation
        Interface1.super.print();  // Call specific interface's default
        // Or provide own implementation
        System.out.println("MyClass");
    }
}

// Calling super interface default method
interface Shape {
    default void draw() {
        System.out.println("Drawing shape");
    }
}

class Circle implements Shape {
    @Override
    public void draw() {
        Shape.super.draw();  // Call default implementation
        System.out.println("Drawing circle");
    }
}

// Practical example: Logger interface
interface Logger {
    void log(String message);

    default void logInfo(String message) {
        log("[INFO] " + message);
    }

    default void logError(String message) {
        log("[ERROR] " + message);
    }

    default void logWarning(String message) {
        log("[WARNING] " + message);
    }
}

class ConsoleLogger implements Logger {
    @Override
    public void log(String message) {
        System.out.println(message);
    }

    // Inherits logInfo, logError, logWarning
}

// Usage
Logger logger = new ConsoleLogger();
logger.logInfo("Application started");     // [INFO] Application started
logger.logError("Error occurred");         // [ERROR] Error occurred

// Automation framework example
interface TestBase {
    WebDriver getDriver();

    default void navigateTo(String url) {
        getDriver().get(url);
    }

    default WebElement findElement(By locator) {
        return getDriver().findElement(locator);
    }

    default void click(By locator) {
        findElement(locator).click();
    }

    default void type(By locator, String text) {
        WebElement element = findElement(locator);
        element.clear();
        element.sendKeys(text);
    }

    default void waitForElement(By locator, int seconds) {
        new WebDriverWait(getDriver(), Duration.ofSeconds(seconds))
            .until(ExpectedConditions.presenceOfElementLocated(locator));
    }
}

class LoginTest implements TestBase {
    private WebDriver driver;

    @Override
    public WebDriver getDriver() {
        return driver;
    }

    // Can use all default methods
    public void testLogin() {
        navigateTo("https://example.com/login");
        type(By.id("username"), "user");
        type(By.id("password"), "pass");
        click(By.id("submit"));
    }
}

// Rules for default methods:
// 1. Class implementation takes precedence over interface default
// 2. More specific interface takes precedence
// 3. Must explicitly override if ambiguous
```
**Follow-up**: What's difference between default method and abstract method? Can we override static method from interface? How does Java resolve diamond problem?

---

### Q48: What are functional interfaces?
**Difficulty**: Medium | **Experience**: 3-5, 6-8, 9-12
**Companies**: Google, Amazon, Microsoft
**Answer**: Functional interface has exactly one abstract method (SAM - Single Abstract Method). Can have multiple default/static methods. Annotated with @FunctionalInterface (optional but recommended). Used as target for lambda expressions and method references. Built-in functional interfaces: Predicate<T>, Function<T,R>, Consumer<T>, Supplier<T>, BiFunction<T,U,R>, UnaryOperator<T>, BinaryOperator<T>.
**Code**:
```java
// Custom functional interface
@FunctionalInterface
interface Calculator {
    int calculate(int a, int b);  // Single abstract method

    // Can have default methods
    default int square(int n) {
        return calculate(n, n);
    }

    // Can have static methods
    static void printInfo() {
        System.out.println("Calculator interface");
    }
}

// Using lambda with functional interface
Calculator add = (a, b) -> a + b;
Calculator multiply = (a, b) -> a * b;

System.out.println(add.calculate(5, 3));       // 8
System.out.println(multiply.calculate(5, 3));  // 15
System.out.println(add.square(5));             // 25

// Built-in functional interfaces (java.util.function package)

// 1. Predicate<T> - takes T, returns boolean
Predicate<Integer> isEven = n -> n % 2 == 0;
Predicate<String> isEmpty = s -> s.isEmpty();
Predicate<String> isLong = s -> s.length() > 10;

System.out.println(isEven.test(4));    // true
System.out.println(isEmpty.test(""));  // true

// Predicate composition
Predicate<String> isNotEmpty = isEmpty.negate();
Predicate<String> isEmptyOrLong = isEmpty.or(isLong);
Predicate<String> isNotEmptyAndLong = isNotEmpty.and(isLong);

List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> evenNumbers = numbers.stream()
    .filter(isEven)
    .collect(Collectors.toList());

// 2. Function<T, R> - takes T, returns R
Function<String, Integer> stringLength = s -> s.length();
Function<Integer, Integer> square = n -> n * n;
Function<String, String> toUpper = s -> s.toUpperCase();

System.out.println(stringLength.apply("Hello"));  // 5
System.out.println(square.apply(5));              // 25

// Function composition
Function<String, Integer> lengthSquared = stringLength.andThen(square);
System.out.println(lengthSquared.apply("Hello"));  // 25 (5 * 5)

Function<Integer, String> squareThenString = square.andThen(Object::toString);

// 3. Consumer<T> - takes T, returns void
Consumer<String> print = s -> System.out.println(s);
Consumer<String> log = s -> logger.log(s);

print.accept("Hello World");

// Consumer chaining
Consumer<String> printAndLog = print.andThen(log);
printAndLog.accept("Message");

List<String> names = Arrays.asList("John", "Alice", "Bob");
names.forEach(print);  // Print each name

// 4. Supplier<T> - takes nothing, returns T
Supplier<String> helloSupplier = () -> "Hello";
Supplier<Double> randomSupplier = () -> Math.random();
Supplier<LocalDate> dateSupplier = LocalDate::now;

System.out.println(helloSupplier.get());  // Hello
System.out.println(randomSupplier.get()); // Random number
System.out.println(dateSupplier.get());   // Current date

// Lazy initialization with Supplier
class ExpensiveObject {
    public ExpensiveObject() {
        System.out.println("Creating expensive object");
    }
}

Supplier<ExpensiveObject> supplier = ExpensiveObject::new;
// Object not created yet
ExpensiveObject obj = supplier.get();  // Created only when needed

// 5. BiFunction<T, U, R> - takes T and U, returns R
BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;
BiFunction<String, String, String> concat = (s1, s2) -> s1 + s2;

System.out.println(add.apply(5, 3));           // 8
System.out.println(concat.apply("Hello", " World"));  // Hello World

// 6. BiConsumer<T, U> - takes T and U, returns void
BiConsumer<String, Integer> printWithIndex = (s, i) ->
    System.out.println(i + ": " + s);

printWithIndex.accept("Hello", 1);  // 1: Hello

Map<String, Integer> map = new HashMap<>();
map.put("John", 25);
map.put("Alice", 30);
map.forEach((key, value) -> System.out.println(key + ": " + value));

// 7. UnaryOperator<T> - special case of Function<T, T>
UnaryOperator<Integer> square = n -> n * n;
UnaryOperator<String> toUpper = s -> s.toUpperCase();

System.out.println(square.apply(5));        // 25
System.out.println(toUpper.apply("hello")); // HELLO

// 8. BinaryOperator<T> - special case of BiFunction<T, T, T>
BinaryOperator<Integer> multiply = (a, b) -> a * b;
BinaryOperator<String> concat = (s1, s2) -> s1 + s2;

System.out.println(multiply.apply(5, 3));  // 15

// Reduction with BinaryOperator
List<Integer> nums = Arrays.asList(1, 2, 3, 4, 5);
int sum = nums.stream()
    .reduce(0, (a, b) -> a + b);  // BinaryOperator
System.out.println(sum);  // 15

// Real-world examples
// Example 1: Validation framework
@FunctionalInterface
interface Validator<T> {
    boolean validate(T value);
}

Validator<String> emailValidator = email -> email.contains("@");
Validator<String> lengthValidator = s -> s.length() >= 8;
Validator<Integer> positiveValidator = n -> n > 0;

System.out.println(emailValidator.validate("test@test.com"));  // true

// Example 2: Retry mechanism
@FunctionalInterface
interface RetryableTask<T> {
    T execute() throws Exception;
}

public <T> T retryOnFailure(RetryableTask<T> task, int maxRetries) {
    for (int i = 0; i < maxRetries; i++) {
        try {
            return task.execute();
        } catch (Exception e) {
            if (i == maxRetries - 1) throw new RuntimeException(e);
        }
    }
    throw new RuntimeException("Failed after retries");
}

// Usage
String result = retryOnFailure(() -> {
    return driver.findElement(By.id("button")).getText();
}, 3);

// Example 3: Selenium Page Object with functional interfaces
class BasePage {
    protected WebDriver driver;

    protected WebElement find(By locator) {
        return driver.findElement(locator);
    }

    protected void performAction(Supplier<WebElement> elementSupplier,
                                 Consumer<WebElement> action) {
        WebElement element = elementSupplier.get();
        action.accept(element);
    }

    protected void click(By locator) {
        performAction(() -> find(locator), WebElement::click);
    }

    protected void type(By locator, String text) {
        performAction(() -> find(locator),
                     element -> element.sendKeys(text));
    }
}

// Example 4: API Testing with functional interfaces
class APITestHelper {
    public void testEndpoint(String endpoint,
                            Predicate<Response> validation,
                            Consumer<Response> onSuccess,
                            Consumer<Response> onFailure) {
        Response response = RestAssured.get(endpoint);

        if (validation.test(response)) {
            onSuccess.accept(response);
        } else {
            onFailure.accept(response);
        }
    }
}

// Usage
testEndpoint("/users",
    response -> response.getStatusCode() == 200,
    response -> System.out.println("Success: " + response.jsonPath().getString("data")),
    response -> System.out.println("Failed with: " + response.getStatusCode())
);

// Specialized functional interfaces for primitives
IntPredicate isEvenInt = n -> n % 2 == 0;
IntFunction<String> intToString = n -> "Number: " + n;
IntConsumer printInt = n -> System.out.println(n);
IntSupplier randomInt = () -> (int)(Math.random() * 100);
IntUnaryOperator squareInt = n -> n * n;
IntBinaryOperator addInt = (a, b) -> a + b;

// Similar for LongPredicate, DoublePredicate, etc.
```
**Follow-up**: Can functional interface have Object class methods? Why use @FunctionalInterface annotation? What's difference between Function and UnaryOperator? Can functional interface extend another interface?

---

### Q49: What are the new Date and Time APIs in Java 8?
**Difficulty**: Medium | **Experience**: 3-5, 6-8
**Companies**: Amazon, Microsoft, Oracle
**Answer**: Java 8 introduced java.time package (JSR-310) to replace old Date/Calendar APIs. Immutable and thread-safe. Key classes: LocalDate, LocalTime, LocalDateTime, ZonedDateTime, Instant, Duration, Period. DateTimeFormatter for formatting/parsing. Better API design with clear semantics. Timezone handling improved with ZonedDateTime.
**Code**:
```java
// 1. LocalDate - Date without time
LocalDate today = LocalDate.now();
LocalDate specificDate = LocalDate.of(2024, 12, 25);
LocalDate parseDate = LocalDate.parse("2024-12-25");

System.out.println(today);         // 2025-01-15
System.out.println(today.getYear());       // 2025
System.out.println(today.getMonth());      // JANUARY
System.out.println(today.getDayOfMonth()); // 15
System.out.println(today.getDayOfWeek());  // WEDNESDAY

// Date arithmetic
LocalDate tomorrow = today.plusDays(1);
LocalDate nextWeek = today.plusWeeks(1);
LocalDate nextMonth = today.plusMonths(1);
LocalDate nextYear = today.plusYears(1);

LocalDate yesterday = today.minusDays(1);

// 2. LocalTime - Time without date
LocalTime now = LocalTime.now();
LocalTime specificTime = LocalTime.of(14, 30, 0);
LocalTime parseTime = LocalTime.parse("14:30:00");

System.out.println(now);           // 10:30:45.123
System.out.println(now.getHour());     // 10
System.out.println(now.getMinute());   // 30

// Time arithmetic
LocalTime laterTime = now.plusHours(2);
LocalTime earlierTime = now.minusMinutes(30);

// 3. LocalDateTime - Date and time without timezone
LocalDateTime dateTime = LocalDateTime.now();
LocalDateTime specific = LocalDateTime.of(2024, 12, 25, 10, 30);
LocalDateTime combined = LocalDate.now().atTime(LocalTime.now());

System.out.println(dateTime);      // 2025-01-15T10:30:45.123

// 4. ZonedDateTime - Date, time with timezone
ZonedDateTime zonedNow = ZonedDateTime.now();
ZonedDateTime zonedUTC = ZonedDateTime.now(ZoneId.of("UTC"));
ZonedDateTime zonedIST = ZonedDateTime.now(ZoneId.of("Asia/Kolkata"));

System.out.println(zonedNow);      // 2025-01-15T10:30:45.123+05:30[Asia/Kolkata]

// Convert between timezones
ZonedDateTime istTime = zonedNow;
ZonedDateTime utcTime = istTime.withZoneSameInstant(ZoneId.of("UTC"));

// 5. Instant - Timestamp (epoch time)
Instant instant = Instant.now();
Instant epochStart = Instant.ofEpochSecond(0);
long epochSeconds = instant.getEpochSecond();

System.out.println(instant);       // 2025-01-15T05:00:45.123Z

// 6. Period - Date-based duration (days, months, years)
LocalDate startDate = LocalDate.of(2024, 1, 1);
LocalDate endDate = LocalDate.of(2025, 1, 15);

Period period = Period.between(startDate, endDate);
System.out.println(period);        // P1Y14D (1 year, 14 days)
System.out.println(period.getYears());  // 1
System.out.println(period.getDays());   // 14

// Create period
Period oneMonth = Period.ofMonths(1);
Period tenDays = Period.ofDays(10);

// 7. Duration - Time-based duration (hours, minutes, seconds)
LocalTime start = LocalTime.of(9, 0);
LocalTime end = LocalTime.of(17, 30);

Duration duration = Duration.between(start, end);
System.out.println(duration);      // PT8H30M
System.out.println(duration.toHours());    // 8
System.out.println(duration.toMinutes());  // 510

// Create duration
Duration twoHours = Duration.ofHours(2);
Duration thirtyMinutes = Duration.ofMinutes(30);

// 8. DateTimeFormatter - Formatting and parsing
DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy");
String formatted = today.format(formatter);
LocalDate parsed = LocalDate.parse("15/01/2025", formatter);

System.out.println(formatted);     // 15/01/2025

// Predefined formatters
DateTimeFormatter iso = DateTimeFormatter.ISO_DATE;
DateTimeFormatter custom = DateTimeFormatter.ofPattern("dd-MMM-yyyy HH:mm:ss");

LocalDateTime dt = LocalDateTime.now();
System.out.println(dt.format(custom));  // 15-Jan-2025 10:30:45

// 9. TemporalAdjusters - Complex date adjustments
LocalDate date = LocalDate.now();

LocalDate firstDayOfMonth = date.with(TemporalAdjusters.firstDayOfMonth());
LocalDate lastDayOfMonth = date.with(TemporalAdjusters.lastDayOfMonth());
LocalDate nextMonday = date.with(TemporalAdjusters.next(DayOfWeek.MONDAY));
LocalDate firstMonday = date.with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY));

// 10. Comparisons
LocalDate date1 = LocalDate.of(2024, 1, 1);
LocalDate date2 = LocalDate.of(2025, 1, 1);

boolean isBefore = date1.isBefore(date2);  // true
boolean isAfter = date1.isAfter(date2);    // false
boolean isEqual = date1.isEqual(date2);    // false

// 11. Real-world examples
// Example 1: Age calculation
public int calculateAge(LocalDate birthDate) {
    return Period.between(birthDate, LocalDate.now()).getYears();
}

// Example 2: Test execution timestamp
public class TestReport {
    private LocalDateTime startTime;
    private LocalDateTime endTime;

    public void startTest() {
        startTime = LocalDateTime.now();
    }

    public void endTest() {
        endTime = LocalDateTime.now();
    }

    public Duration getExecutionTime() {
        return Duration.between(startTime, endTime);
    }

    public String getFormattedTimestamp() {
        DateTimeFormatter formatter =
            DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        return startTime.format(formatter);
    }
}

// Example 3: Scheduling tests
public LocalDateTime getNextRunTime() {
    LocalDateTime now = LocalDateTime.now();

    // Schedule for next day at 9 AM
    LocalDateTime nextRun = now.plusDays(1)
                                .withHour(9)
                                .withMinute(0)
                                .withSecond(0);

    return nextRun;
}

// Example 4: Date range for reports
public List<LocalDate> getDateRange(LocalDate start, LocalDate end) {
    List<LocalDate> dates = new ArrayList<>();
    LocalDate current = start;

    while (!current.isAfter(end)) {
        dates.add(current);
        current = current.plusDays(1);
    }

    return dates;
}

// Example 5: Convert old Date to new API
Date oldDate = new Date();
Instant instant = oldDate.toInstant();
LocalDateTime newDateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault());

// Convert new API to old Date
LocalDateTime newDT = LocalDateTime.now();
Date oldDt = Date.from(newDT.atZone(ZoneId.systemDefault()).toInstant());

// Example 6: Working with different formats
String[] dateStrings = {
    "2025-01-15",           // ISO format
    "15/01/2025",           // Custom format
    "Jan 15, 2025",         // Custom format
    "15-Jan-2025 10:30:00"  // Custom datetime format
};

DateTimeFormatter[] formatters = {
    DateTimeFormatter.ISO_DATE,
    DateTimeFormatter.ofPattern("dd/MM/yyyy"),
    DateTimeFormatter.ofPattern("MMM dd, yyyy"),
    DateTimeFormatter.ofPattern("dd-MMM-yyyy HH:mm:ss")
};

// Parse with appropriate formatter
LocalDate date = LocalDate.parse(dateStrings[0], formatters[0]);

// Old vs New API comparison
/*
Old (Date/Calendar)              | New (java.time)
---------------------------------|--------------------------------
Mutable                          | Immutable
Not thread-safe                  | Thread-safe
Poor API design                  | Clean, fluent API
Month starts from 0              | Month starts from 1
Limited timezone support         | Excellent timezone support
No clear separation of concepts  | Clear separation (Date, Time, DateTime)
*/
```
**Follow-up**: Why was new Date/Time API introduced? How to convert between old and new Date APIs? What's difference between Period and Duration? Is the new API thread-safe?

---

### Q50: What are CompletableFuture and parallel programming features?
**Difficulty**: Hard | **Experience**: 6-8, 9-12
**Companies**: Google, Amazon, Microsoft, Uber
**Answer**: CompletableFuture (Java 8+) enables asynchronous programming and functional-style composition of async operations. Implements Future and CompletionStage. Supports chaining (thenApply, thenCompose), combining (thenCombine, allOf, anyOf), exception handling (exceptionally, handle). Non-blocking. Useful for parallel test execution, API calls, complex async workflows.
**Code**:
```java
// 1. Creating CompletableFuture
// Completed future with value
CompletableFuture<String> completed = CompletableFuture.completedFuture("Hello");

// Run async task (no return value)
CompletableFuture<Void> runAsync = CompletableFuture.runAsync(() -> {
    System.out.println("Running in: " + Thread.currentThread().getName());
    // Do work
});

// Supply async (returns value)
CompletableFuture<String> supplyAsync = CompletableFuture.supplyAsync(() -> {
    return "Result from async task";
});

// Get result (blocking)
String result = supplyAsync.get();  // Blocks until complete
String resultWithTimeout = supplyAsync.get(5, TimeUnit.SECONDS);

// 2. Chaining operations - thenApply (synchronous)
CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {
    return "Hello";
}).thenApply(s -> {
    return s.length();  // Transform result
}).thenApply(length -> {
    return length * 2;  // Further transformation
});

System.out.println(future.get());  // 10

// 3. thenApplyAsync (asynchronous)
CompletableFuture<String> asyncChain = CompletableFuture.supplyAsync(() -> {
    return "Hello";
}).thenApplyAsync(s -> {
    return s.toUpperCase();  // Runs in different thread
});

// 4. thenAccept - consume result (no return)
CompletableFuture.supplyAsync(() -> "Result")
    .thenAccept(result -> {
        System.out.println("Got: " + result);
    });

// 5. thenRun - run action after completion (ignores result)
CompletableFuture.supplyAsync(() -> "Result")
    .thenRun(() -> {
        System.out.println("Completed!");
    });

// 6. thenCompose - flat map (avoid nested futures)
CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> "User123");

CompletableFuture<String> composed = future1.thenCompose(userId -> {
    return CompletableFuture.supplyAsync(() -> "Email for " + userId);
});

// 7. thenCombine - combine two independent futures
CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> "Hello");
CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> "World");

CompletableFuture<String> combined = future1.thenCombine(future2, (s1, s2) -> {
    return s1 + " " + s2;
});

System.out.println(combined.get());  // Hello World

// 8. allOf - wait for all futures to complete
CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> "Task1");
CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> "Task2");
CompletableFuture<String> future3 = CompletableFuture.supplyAsync(() -> "Task3");

CompletableFuture<Void> allFutures = CompletableFuture.allOf(future1, future2, future3);

allFutures.join();  // Wait for all to complete

// Collect all results
List<String> results = Stream.of(future1, future2, future3)
    .map(CompletableFuture::join)
    .collect(Collectors.toList());

// 9. anyOf - complete when any future completes
CompletableFuture<Object> anyFuture = CompletableFuture.anyOf(future1, future2, future3);
Object firstResult = anyFuture.get();  // First completed result

// 10. Exception handling - exceptionally
CompletableFuture<String> futureWithError = CompletableFuture.supplyAsync(() -> {
    if (true) throw new RuntimeException("Error occurred");
    return "Success";
}).exceptionally(ex -> {
    System.out.println("Exception: " + ex.getMessage());
    return "Default value";
});

// 11. handle - handle both result and exception
CompletableFuture<String> handled = CompletableFuture.supplyAsync(() -> {
    return "Success";
}).handle((result, exception) -> {
    if (exception != null) {
        return "Error: " + exception.getMessage();
    }
    return result;
});

// 12. Real-world example: Parallel test execution
public class ParallelTestRunner {
    public void runTestsInParallel(List<String> testCases) {
        List<CompletableFuture<TestResult>> futures = testCases.stream()
            .map(testCase -> CompletableFuture.supplyAsync(() -> {
                return executeTest(testCase);
            }))
            .collect(Collectors.toList());

        // Wait for all tests to complete
        CompletableFuture<Void> allTests = CompletableFuture.allOf(
            futures.toArray(new CompletableFuture[0])
        );

        allTests.join();

        // Collect results
        List<TestResult> results = futures.stream()
            .map(CompletableFuture::join)
            .collect(Collectors.toList());

        generateReport(results);
    }

    private TestResult executeTest(String testCase) {
        // Execute test
        return new TestResult(testCase, "PASSED");
    }
}

// 13. Example: API testing with CompletableFuture
public class APITestSuite {
    public void testMultipleEndpoints() {
        List<String> endpoints = Arrays.asList(
            "/users",
            "/posts",
            "/comments"
        );

        // Test all endpoints in parallel
        List<CompletableFuture<Response>> futures = endpoints.stream()
            .map(endpoint -> CompletableFuture.supplyAsync(() -> {
                return RestAssured.get(endpoint);
            }))
            .collect(Collectors.toList());

        // Process results as they complete
        futures.forEach(future -> {
            future.thenAccept(response -> {
                System.out.println("Status: " + response.getStatusCode());
            });
        });

        // Wait for all
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();
    }
}

// 14. Example: Chaining API calls
public CompletableFuture<String> getUserDetails(String userId) {
    return CompletableFuture.supplyAsync(() -> {
        // Get user
        Response userResponse = RestAssured.get("/users/" + userId);
        return userResponse.jsonPath().getString("email");
    }).thenCompose(email -> {
        // Get user preferences based on email
        return CompletableFuture.supplyAsync(() -> {
            Response prefResponse = RestAssured.get("/preferences?email=" + email);
            return prefResponse.jsonPath().getString("theme");
        });
    });
}

// 15. Example: Timeout handling
CompletableFuture<String> futureWithTimeout = CompletableFuture.supplyAsync(() -> {
    // Long-running task
    Thread.sleep(10000);
    return "Result";
}).orTimeout(5, TimeUnit.SECONDS)  // Java 9+
  .exceptionally(ex -> {
    return "Timed out";
});

// 16. Example: Retry logic
public <T> CompletableFuture<T> retryAsync(
        Supplier<T> task, int maxRetries) {

    CompletableFuture<T> future = CompletableFuture.supplyAsync(task);

    for (int i = 0; i < maxRetries; i++) {
        future = future.exceptionally(ex -> {
            System.out.println("Retry attempt " + (i + 1));
            return task.get();
        });
    }

    return future;
}

// 17. Example: Combining multiple API responses
public CompletableFuture<UserProfile> getCompleteUserProfile(String userId) {
    CompletableFuture<User> userFuture =
        CompletableFuture.supplyAsync(() -> getUser(userId));

    CompletableFuture<List<Post>> postsFuture =
        CompletableFuture.supplyAsync(() -> getUserPosts(userId));

    CompletableFuture<List<Comment>> commentsFuture =
        CompletableFuture.supplyAsync(() -> getUserComments(userId));

    return userFuture.thenCombine(postsFuture, (user, posts) -> {
        return new UserProfile(user, posts);
    }).thenCombine(commentsFuture, (profile, comments) -> {
        profile.setComments(comments);
        return profile;
    });
}

// 18. Custom thread pool
ExecutorService executor = Executors.newFixedThreadPool(10);

CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    return "Task";
}, executor);  // Use custom executor

// Don't forget to shutdown
executor.shutdown();

// 19. Non-blocking waiting
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    Thread.sleep(2000);
    return "Done";
});

// Don't block - register callback
future.thenAccept(result -> {
    System.out.println("Result: " + result);
    // Continue with other work
});

// Continue with other work - non-blocking
System.out.println("Doing other work...");
```
**Follow-up**: What's difference between CompletableFuture and Future? When to use thenApply vs thenCompose? How to handle exceptions in async chains? What's difference between thenApply and thenApplyAsync?

---

# ðŸŒ SELENIUM WEBDRIVER (50 Questions)

## Selenium Architecture & Basics (5 Questions)

### Q51: Explain Selenium architecture and WebDriver working
**Difficulty**: Medium | **Experience**: 3-5, 6-8, 9-12
**Companies**: All companies
**Answer**: Selenium WebDriver follows client-server architecture. Components: 1) Language bindings (Java, Python, etc.) - provides API to write tests, 2) JSON Wire Protocol/W3C WebDriver Protocol - communication protocol between client and driver, 3) Browser Drivers (ChromeDriver, GeckoDriver) - browser-specific implementations, 4) Browsers - actual browser where tests execute. When you call driver.findElement(), language binding converts it to HTTP request â†’ Browser driver receives request â†’ Executes on browser â†’ Returns response â†’ Client receives result.
**Code**:
```java
// Selenium architecture flow
WebDriver driver = new ChromeDriver();  // 1. Creates ChromeDriver instance
driver.get("https://example.com");      // 2. Converts to HTTP POST request
                                        // 3. ChromeDriver talks to Chrome
                                        // 4. Chrome loads page
WebElement element = driver.findElement(By.id("btn"));  // 5. HTTP request to find element
element.click();                        // 6. HTTP request to click

// Behind the scenes (simplified):
// POST /session/{sessionId}/element
// {
//   "using": "id",
//   "value": "btn"
// }
// Response: {"element-6066-11e4-a52e-4f735466cecf": "element-id-123"}

// POST /session/{sessionId}/element/{elementId}/click

// Selenium 3 vs Selenium 4
// Selenium 3: Uses JSON Wire Protocol
// Selenium 4: Uses W3C WebDriver Protocol (standard)

// Different browser drivers
WebDriver chromeDriver = new ChromeDriver();
WebDriver firefoxDriver = new FirefoxDriver();
WebDriver edgeDriver = new EdgeDriver();
WebDriver safariDriver = new SafariDriver();

// Remote WebDriver
WebDriver remoteDriver = new RemoteWebDriver(
    new URL("http://localhost:4444"),
    new ChromeOptions()
);
```
**Follow-up**: What changed in Selenium 4? How does JSON Wire Protocol work? What is W3C WebDriver standard? How does RemoteWebDriver work?

---

### Q52: What are different types of locators? When to use which?
**Difficulty**: Medium | **Experience**: 3-5, 6-8
**Companies**: All companies
**Answer**: Selenium provides 8 locator strategies:
**Priority Order**: 1) ID (fastest, most reliable), 2) Name, 3) CSS Selector (fast, powerful), 4) XPath (flexible but slower), 5) LinkText/PartialLinkText (for links), 6) TagName (rarely used), 7) ClassName (limited use).
**Best Practices**: Prefer ID > CSS > XPath. Avoid absolute XPath. Use relative XPath with unique attributes. CSS is faster than XPath in most browsers.
**Code**:
```java
// 1. ID - Fastest, most reliable
WebElement element = driver.findElement(By.id("username"));

// 2. Name
WebElement element = driver.findElement(By.name("email"));

// 3. ClassName - Single class only
WebElement element = driver.findElement(By.className("btn-primary"));

// 4. TagName - Returns first matching tag
WebElement element = driver.findElement(By.tagName("button"));

// 5. LinkText - Exact text match for <a> tags
WebElement element = driver.findElement(By.linkText("Click Here"));

// 6. PartialLinkText - Partial text match
WebElement element = driver.findElement(By.partialLinkText("Click"));

// 7. CSS Selector - Fast and powerful
// ID
WebElement element = driver.findElement(By.cssSelector("#username"));
// Class
WebElement element = driver.findElement(By.cssSelector(".btn-primary"));
// Tag + attribute
WebElement element = driver.findElement(By.cssSelector("input[type='email']"));
// Multiple classes
WebElement element = driver.findElement(By.cssSelector(".btn.btn-primary"));
// Child selector
WebElement element = driver.findElement(By.cssSelector("div > button"));
// Descendant selector
WebElement element = driver.findElement(By.cssSelector("div button"));
// nth-child
WebElement element = driver.findElement(By.cssSelector("li:nth-child(2)"));
// Attribute contains
WebElement element = driver.findElement(By.cssSelector("[id*='submit']"));
// Attribute starts with
WebElement element = driver.findElement(By.cssSelector("[id^='user']"));
// Attribute ends with
WebElement element = driver.findElement(By.cssSelector("[id$='name']"));

// 8. XPath - Most flexible but slower
// Absolute XPath (BAD - brittle)
WebElement element = driver.findElement(
    By.xpath("/html/body/div[1]/form/input[1]")
);

// Relative XPath (GOOD)
// By attribute
WebElement element = driver.findElement(By.xpath("//input[@id='username']"));
// By text
WebElement element = driver.findElement(By.xpath("//button[text()='Submit']"));
// By partial text
WebElement element = driver.findElement(
    By.xpath("//button[contains(text(),'Sub')]")
);
// By attribute contains
WebElement element = driver.findElement(
    By.xpath("//input[contains(@id,'user')]")
);
// By attribute starts-with
WebElement element = driver.findElement(
    By.xpath("//input[starts-with(@id,'user')]")
);
// Multiple conditions (AND)
WebElement element = driver.findElement(
    By.xpath("//input[@type='text' and @name='email']")
);
// Multiple conditions (OR)
WebElement element = driver.findElement(
    By.xpath("//input[@type='text' or @type='email']")
);
// Parent navigation
WebElement element = driver.findElement(
    By.xpath("//button[@id='submit']/parent::form")
);
// Following sibling
WebElement element = driver.findElement(
    By.xpath("//label[@for='username']/following-sibling::input")
);
// Preceding sibling
WebElement element = driver.findElement(
    By.xpath("//button[@type='submit']/preceding-sibling::input")
);
// Ancestor
WebElement element = driver.findElement(
    By.xpath("//input[@id='username']/ancestor::form")
);
// Index-based
WebElement element = driver.findElement(
    By.xpath("(//input[@type='text'])[2]")
);

// Dynamic XPath strategies
// 1. When ID changes dynamically: id="user_123" â†’ id="user_456"
WebElement element = driver.findElement(
    By.xpath("//input[starts-with(@id,'user_')]")
);

// 2. When part is static: id="submit_btn_xyz"
WebElement element = driver.findElement(
    By.xpath("//button[contains(@id,'submit_btn')]")
);

// 3. By visible text
WebElement element = driver.findElement(
    By.xpath("//button[normalize-space()='Submit']")
);

// Performance comparison
// ID: 1ms (fastest)
// CSS: 2-3ms
// XPath: 5-10ms (slowest)

// Best practices
// âœ… GOOD
By locator = By.id("username");  // Use ID if available
By locator = By.cssSelector("#username");  // CSS for complex scenarios
By locator = By.xpath("//input[@data-test-id='username']");  // XPath when needed

// âŒ BAD
By locator = By.xpath("/html/body/div[1]/form/input[1]");  // Absolute XPath
By locator = By.xpath("//input[1]");  // Index-based without context
By locator = By.tagName("input");  // Too generic
```
**Follow-up**: CSS vs XPath - which is faster? How to handle dynamic IDs? What are XPath axes? How to write robust locators?

---

### Q53: Explain different types of waits in Selenium
**Difficulty**: Medium | **Experience**: 3-5, 6-8, 9-12
**Companies**: Amazon, Google, Microsoft, Flipkart
**Answer**: Three types of waits:
1. **Implicit Wait**: Global wait applied to all findElement calls. Once set, applicable for entire driver lifetime. Not recommended for modern frameworks.
2. **Explicit Wait**: Wait for specific condition on specific element. More flexible and preferred. Uses WebDriverWait with ExpectedConditions.
3. **Fluent Wait**: Advanced explicit wait with polling interval and exceptions to ignore. Most customizable.
**Best Practice**: Use Explicit waits. Avoid mixing implicit and explicit waits.
**Code**:
```java
// 1. Implicit Wait (NOT RECOMMENDED)
driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));
// Applied globally to all findElement calls
// If element found in 2 seconds, proceeds immediately
// If not found, waits up to 10 seconds
WebElement element = driver.findElement(By.id("username"));  // Uses implicit wait

// 2. Explicit Wait (RECOMMENDED)
WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));

// Wait for element to be visible
WebElement element = wait.until(
    ExpectedConditions.visibilityOfElementLocated(By.id("username"))
);

// Wait for element to be clickable
WebElement button = wait.until(
    ExpectedConditions.elementToBeClickable(By.id("submit"))
);

// Wait for element to be present (in DOM, may not be visible)
WebElement element = wait.until(
    ExpectedConditions.presenceOfElementLocated(By.id("hidden"))
);

// Wait for text to be present
wait.until(
    ExpectedConditions.textToBePresentInElementLocated(
        By.id("message"),
        "Success"
    )
);

// Wait for title
wait.until(ExpectedConditions.titleIs("Home Page"));
wait.until(ExpectedConditions.titleContains("Home"));

// Wait for URL
wait.until(ExpectedConditions.urlToBe("https://example.com/home"));
wait.until(ExpectedConditions.urlContains("home"));

// Wait for alert
wait.until(ExpectedConditions.alertIsPresent());

// Wait for frame and switch
wait.until(ExpectedConditions.frameToBeAvailableAndSwitchToIt("frameName"));

// Wait for element to be invisible
wait.until(
    ExpectedConditions.invisibilityOfElementLocated(By.id("loader"))
);

// Wait for element to be selected
wait.until(
    ExpectedConditions.elementToBeSelected(By.id("checkbox"))
);

// Wait for attribute to contain value
wait.until(
    ExpectedConditions.attributeContains(By.id("input"), "value", "test")
);

// Wait for staleness of element (element removed from DOM)
WebElement oldElement = driver.findElement(By.id("dynamic"));
// Page refresh or element replaced
wait.until(ExpectedConditions.stalenessOf(oldElement));

// Wait for number of windows
wait.until(ExpectedConditions.numberOfWindowsToBe(2));

// Wait for element selection state
wait.until(
    ExpectedConditions.elementSelectionStateToBe(By.id("checkbox"), true)
);

// 3. Fluent Wait (ADVANCED)
Wait<WebDriver> fluentWait = new FluentWait<>(driver)
    .withTimeout(Duration.ofSeconds(30))
    .pollingEvery(Duration.ofMillis(500))  // Check every 500ms
    .ignoring(NoSuchElementException.class)
    .ignoring(StaleElementReferenceException.class)
    .withMessage("Element not found after 30 seconds");

WebElement element = fluentWait.until(driver -> {
    return driver.findElement(By.id("dynamic-element"));
});

// Custom condition with Fluent Wait
WebElement element = fluentWait.until(new Function<WebDriver, WebElement>() {
    @Override
    public WebElement apply(WebDriver driver) {
        WebElement elem = driver.findElement(By.id("username"));
        if (elem.isDisplayed() && elem.isEnabled()) {
            return elem;
        }
        return null;
    }
});

// Lambda version
WebElement element = fluentWait.until(driver -> {
    WebElement elem = driver.findElement(By.id("username"));
    return (elem.isDisplayed() && elem.isEnabled()) ? elem : null;
});

// 4. Custom ExpectedCondition
public class CustomConditions {
    public static ExpectedCondition<Boolean> textToBePresentInElement(
            final By locator,
            final String text) {

        return new ExpectedCondition<Boolean>() {
            @Override
            public Boolean apply(WebDriver driver) {
                try {
                    String elementText = driver.findElement(locator).getText();
                    return elementText.contains(text);
                } catch (StaleElementReferenceException e) {
                    return false;
                }
            }

            @Override
            public String toString() {
                return String.format("text ('%s') to be present in element %s",
                    text, locator);
            }
        };
    }

    public static ExpectedCondition<Boolean> elementToBeClickableWithRetry(
            final By locator,
            final int maxRetries) {

        return new ExpectedCondition<Boolean>() {
            private int attempts = 0;

            @Override
            public Boolean apply(WebDriver driver) {
                try {
                    WebElement element = driver.findElement(locator);
                    if (element.isDisplayed() && element.isEnabled()) {
                        element.click();
                        return true;
                    }
                    return false;
                } catch (Exception e) {
                    attempts++;
                    if (attempts >= maxRetries) {
                        throw e;
                    }
                    return false;
                }
            }
        };
    }
}

// Usage
wait.until(CustomConditions.textToBePresentInElement(
    By.id("status"),
    "Complete"
));

// 5. Wait utility wrapper (Framework pattern)
public class WaitHelper {
    private WebDriver driver;
    private WebDriverWait wait;

    public WaitHelper(WebDriver driver, int timeoutInSeconds) {
        this.driver = driver;
        this.wait = new WebDriverWait(driver, Duration.ofSeconds(timeoutInSeconds));
    }

    public WebElement waitForElementVisible(By locator) {
        return wait.until(
            ExpectedConditions.visibilityOfElementLocated(locator)
        );
    }

    public WebElement waitForElementClickable(By locator) {
        return wait.until(
            ExpectedConditions.elementToBeClickable(locator)
        );
    }

    public void waitForElementInvisible(By locator) {
        wait.until(
            ExpectedConditions.invisibilityOfElementLocated(locator)
        );
    }

    public void waitForTextPresent(By locator, String text) {
        wait.until(
            ExpectedConditions.textToBePresentInElementLocated(locator, text)
        );
    }

    public WebElement waitForElementWithRetry(By locator, int maxRetries) {
        int attempts = 0;
        while (attempts < maxRetries) {
            try {
                return wait.until(
                    ExpectedConditions.visibilityOfElementLocated(locator)
                );
            } catch (TimeoutException e) {
                attempts++;
                if (attempts >= maxRetries) {
                    throw e;
                }
            }
        }
        throw new TimeoutException("Element not found after retries");
    }
}

// 6. Thread.sleep() (AVOID)
Thread.sleep(5000);  // BAD - always waits full 5 seconds
// Only use for debugging or when absolutely necessary

// Wait comparison
/*
Type              | Scope    | Flexibility | Performance | Recommended
------------------|----------|-------------|-------------|-------------
Implicit Wait     | Global   | Low         | Poor        | No
Explicit Wait     | Specific | High        | Good        | Yes
Fluent Wait       | Specific | Very High   | Good        | Yes (complex)
Thread.sleep()    | N/A      | None        | Worst       | Never
*/
```
**Follow-up**: Can you mix implicit and explicit waits? What happens if you do? How to create custom ExpectedConditions? What's polling interval in Fluent Wait?

---

### Q54: What is StaleElementReferenceException? How to handle it?
**Difficulty**: Medium | **Experience**: 3-5, 6-8, 9-12
**Companies**: Amazon, Google, Microsoft
**Answer**: StaleElementReferenceException occurs when element reference is no longer valid in DOM. Causes: 1) Page refresh, 2) Element removed and re-added to DOM, 3) AJAX updates, 4) Navigation to different page. Solutions: 1) Re-find element, 2) Use explicit wait with retry, 3) Use ExpectedConditions.refreshed(), 4) Avoid storing WebElement in variables (find when needed), 5) Use Fluent Wait ignoring stale exceptions.
**Code**:
```java
// Scenario causing StaleElementReferenceException
WebElement element = driver.findElement(By.id("dynamic"));
element.click();

// Page refreshes or element is replaced
driver.navigate().refresh();

// This throws StaleElementReferenceException
element.click();  // Element reference is now stale

// Solution 1: Re-find element
WebElement element = driver.findElement(By.id("dynamic"));
element.click();
// ... page changes ...
element = driver.findElement(By.id("dynamic"));  // Re-find
element.click();  // Works

// Solution 2: Use method to always find fresh element
public WebElement getElement(By locator) {
    return driver.findElement(locator);
}

// Usage
getElement(By.id("dynamic")).click();
// ... page changes ...
getElement(By.id("dynamic")).click();  // Always fresh

// Solution 3: Retry logic
public void clickWithRetry(By locator, int maxRetries) {
    int attempts = 0;
    while (attempts < maxRetries) {
        try {
            driver.findElement(locator).click();
            break;  // Success
        } catch (StaleElementReferenceException e) {
            attempts++;
            if (attempts >= maxRetries) {
                throw e;
            }
        }
    }
}

// Usage
clickWithRetry(By.id("dynamic"), 3);

// Solution 4: ExpectedConditions.refreshed()
WebElement element = driver.findElement(By.id("dynamic"));

// Wait for element to be refreshed and clickable
WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
WebElement freshElement = wait.until(
    ExpectedConditions.refreshed(
        ExpectedConditions.elementToBeClickable(By.id("dynamic"))
    )
);
freshElement.click();

// Solution 5: Fluent Wait ignoring stale exception
Wait<WebDriver> fluentWait = new FluentWait<>(driver)
    .withTimeout(Duration.ofSeconds(30))
    .pollingEvery(Duration.ofMillis(500))
    .ignoring(StaleElementReferenceException.class);

WebElement element = fluentWait.until(driver -> {
    return driver.findElement(By.id("dynamic"));
});
element.click();

// Solution 6: Generic retry wrapper
public <T> T retryOnStale(Supplier<T> action, int maxRetries) {
    int attempts = 0;
    while (attempts < maxRetries) {
        try {
            return action.get();
        } catch (StaleElementReferenceException e) {
            attempts++;
            if (attempts >= maxRetries) {
                throw e;
            }
        }
    }
    throw new RuntimeException("Should not reach here");
}

// Usage
String text = retryOnStale(() -> {
    return driver.findElement(By.id("dynamic")).getText();
}, 3);

// Solution 7: Page Object Pattern (Best Practice)
public class LoginPage {
    private WebDriver driver;

    // Don't store WebElement - store locator
    private By usernameLocator = By.id("username");
    private By passwordLocator = By.id("password");
    private By submitLocator = By.id("submit");

    // Find element when needed
    public void login(String user, String pass) {
        driver.findElement(usernameLocator).sendKeys(user);
        driver.findElement(passwordLocator).sendKeys(pass);
        driver.findElement(submitLocator).click();
    }
}

// âŒ BAD - Storing WebElement
public class LoginPage {
    @FindBy(id = "username")
    private WebElement username;  // Stale after page change

    public void enterUsername(String user) {
        username.sendKeys(user);  // May throw stale exception
    }
}

// âœ… GOOD - Using method to get fresh element
public class LoginPage {
    @FindBy(id = "username")
    private WebElement username;

    public WebElement getUsername() {
        return username;  // PageFactory re-finds element
    }

    public void enterUsername(String user) {
        getUsername().sendKeys(user);
    }
}

// Solution 8: Wait for staleness (element to be removed)
WebElement oldElement = driver.findElement(By.id("toBeReplaced"));
// Action that causes element to be replaced
driver.findElement(By.id("refresh")).click();
// Wait for old element to become stale
wait.until(ExpectedConditions.stalenessOf(oldElement));
// Now find new element
WebElement newElement = driver.findElement(By.id("toBeReplaced"));

// Real-world example: Dynamic table
public class DynamicTablePage {
    private WebDriver driver;
    private WebDriverWait wait;

    // Always find elements fresh
    private By tableLocator = By.id("dataTable");
    private By refreshButtonLocator = By.id("refresh");

    public List<String> getTableData() {
        return driver.findElements(By.cssSelector("#dataTable tr"))
            .stream()
            .map(WebElement::getText)
            .collect(Collectors.toList());
    }

    public void refreshAndGetData() {
        // Click refresh
        driver.findElement(refreshButtonLocator).click();

        // Wait for table to be refreshed (stale â†’ fresh)
        wait.until(ExpectedConditions.refreshed(
            ExpectedConditions.presenceOfElementLocated(tableLocator)
        ));

        // Get fresh data
        List<String> data = getTableData();
    }
}
```
**Follow-up**: When does StaleElementReferenceException occur? How does ExpectedConditions.refreshed() work? Should you store WebElement or locator? What's best practice for Page Objects?

---

### Q55: Explain Page Object Model (POM) implementation in detail
**Difficulty**: Medium | **Experience**: 3-5, 6-8, 9-12
**Companies**: All companies
**Answer**: Page Object Model is design pattern where each web page is represented as a class. Elements are defined as variables and user interactions as methods. Benefits: Code reusability, maintainability, readability, separation of test logic and page logic. Components: 1) Page Classes (locators + methods), 2) Test Classes (test logic), 3) Base Page (common methods). Selenium 4 discourages @FindBy in favor of By locators.
**Code**:
```java
// 1. Basic Page Object Model
public class LoginPage {
    private WebDriver driver;

    // Locators
    private By usernameLocator = By.id("username");
    private By passwordLocator = By.id("password");
    private By submitButtonLocator = By.id("submit");
    private By errorMessageLocator = By.className("error");

    // Constructor
    public LoginPage(WebDriver driver) {
        this.driver = driver;
    }

    // Page methods (actions)
    public void enterUsername(String username) {
        driver.findElement(usernameLocator).sendKeys(username);
    }

    public void enterPassword(String password) {
        driver.findElement(passwordLocator).sendKeys(password);
    }

    public void clickSubmit() {
        driver.findElement(submitButtonLocator).click();
    }

    public HomePage login(String username, String password) {
        enterUsername(username);
        enterPassword(password);
        clickSubmit();
        return new HomePage(driver);  // Return next page
    }

    public String getErrorMessage() {
        return driver.findElement(errorMessageLocator).getText();
    }

    public boolean isErrorDisplayed() {
        try {
            return driver.findElement(errorMessageLocator).isDisplayed();
        } catch (NoSuchElementException e) {
            return false;
        }
    }
}

// 2. Test class using POM
public class LoginTest {
    private WebDriver driver;
    private LoginPage loginPage;

    @BeforeMethod
    public void setup() {
        driver = new ChromeDriver();
        driver.get("https://example.com/login");
        loginPage = new LoginPage(driver);
    }

    @Test
    public void testValidLogin() {
        HomePage homePage = loginPage.login("user@test.com", "password123");
        Assert.assertTrue(homePage.isLogoutButtonDisplayed());
    }

    @Test
    public void testInvalidLogin() {
        loginPage.login("invalid@test.com", "wrong");
        Assert.assertTrue(loginPage.isErrorDisplayed());
        Assert.assertEquals(loginPage.getErrorMessage(), "Invalid credentials");
    }

    @AfterMethod
    public void teardown() {
        driver.quit();
    }
}

// 3. Base Page Pattern
public class BasePage {
    protected WebDriver driver;
    protected WebDriverWait wait;

    public BasePage(WebDriver driver) {
        this.driver = driver;
        this.wait = new WebDriverWait(driver, Duration.ofSeconds(10));
    }

    // Common methods for all pages
    protected WebElement waitForElement(By locator) {
        return wait.until(
            ExpectedConditions.visibilityOfElementLocated(locator)
        );
    }

    protected void click(By locator) {
        waitForElement(locator).click();
    }

    protected void type(By locator, String text) {
        WebElement element = waitForElement(locator);
        element.clear();
        element.sendKeys(text);
    }

    protected String getText(By locator) {
        return waitForElement(locator).getText();
    }

    protected boolean isDisplayed(By locator) {
        try {
            return driver.findElement(locator).isDisplayed();
        } catch (NoSuchElementException e) {
            return false;
        }
    }

    public String getTitle() {
        return driver.getTitle();
    }

    public String getCurrentUrl() {
        return driver.getCurrentUrl();
    }
}

// 4. Page extending BasePage
public class LoginPage extends BasePage {
    // Locators
    private By usernameLocator = By.id("username");
    private By passwordLocator = By.id("password");
    private By submitButtonLocator = By.id("submit");
    private By errorMessageLocator = By.className("error");

    public LoginPage(WebDriver driver) {
        super(driver);
    }

    // Using Base Page methods
    public HomePage login(String username, String password) {
        type(usernameLocator, username);
        type(passwordLocator, password);
        click(submitButtonLocator);
        return new HomePage(driver);
    }

    public String getErrorMessage() {
        return getText(errorMessageLocator);
    }
}

// 5. Fluent Page Object Model
public class LoginPage {
    private WebDriver driver;
    private By usernameLocator = By.id("username");
    private By passwordLocator = By.id("password");
    private By submitButtonLocator = By.id("submit");

    public LoginPage(WebDriver driver) {
        this.driver = driver;
    }

    // Fluent methods - return 'this'
    public LoginPage enterUsername(String username) {
        driver.findElement(usernameLocator).sendKeys(username);
        return this;
    }

    public LoginPage enterPassword(String password) {
        driver.findElement(passwordLocator).sendKeys(password);
        return this;
    }

    public HomePage clickSubmit() {
        driver.findElement(submitButtonLocator).click();
        return new HomePage(driver);
    }
}

// Usage - Method chaining
HomePage homePage = new LoginPage(driver)
    .enterUsername("user@test.com")
    .enterPassword("password123")
    .clickSubmit();

// 6. Page Factory Pattern (Less recommended in Selenium 4)
public class LoginPageFactory {
    private WebDriver driver;

    @FindBy(id = "username")
    private WebElement username;

    @FindBy(id = "password")
    private WebElement password;

    @FindBy(id = "submit")
    private WebElement submitButton;

    @FindBy(className = "error")
    private WebElement errorMessage;

    public LoginPageFactory(WebDriver driver) {
        this.driver = driver;
        PageFactory.initElements(driver, this);
    }

    public void login(String user, String pass) {
        username.sendKeys(user);
        password.sendKeys(pass);
        submitButton.click();
    }
}

// 7. Advanced: Page Component Pattern
public class Header {
    private WebDriver driver;
    private By logoLocator = By.id("logo");
    private By searchBoxLocator = By.id("search");
    private By userMenuLocator = By.id("userMenu");

    public Header(WebDriver driver) {
        this.driver = driver;
    }

    public void clickLogo() {
        driver.findElement(logoLocator).click();
    }

    public void search(String query) {
        driver.findElement(searchBoxLocator).sendKeys(query);
    }
}

public class HomePage extends BasePage {
    private Header header;

    public HomePage(WebDriver driver) {
        super(driver);
        this.header = new Header(driver);
    }

    public Header getHeader() {
        return header;
    }
}

// Usage
HomePage homePage = new HomePage(driver);
homePage.getHeader().search("Selenium");

// 8. Real-world framework structure
/*
src/main/java/
â”œâ”€â”€ pages/
â”‚   â”œâ”€â”€ BasePage.java
â”‚   â”œâ”€â”€ LoginPage.java
â”‚   â”œâ”€â”€ HomePage.java
â”‚   â””â”€â”€ components/
â”‚       â”œâ”€â”€ Header.java
â”‚       â””â”€â”€ Footer.java
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ WaitHelper.java
â”‚   â””â”€â”€ ElementHelper.java
â””â”€â”€ config/
    â””â”€â”€ Config.java

src/test/java/
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ BaseTest.java
â”‚   â”œâ”€â”€ LoginTest.java
â”‚   â””â”€â”€ HomeTest.java
â””â”€â”€ testdata/
    â””â”€â”€ TestData.java
*/

// 9. Best Practices
// âœ… GOOD
public class LoginPage {
    // 1. Store locators, not WebElements
    private By usernameLocator = By.id("username");

    // 2. Descriptive method names
    public HomePage loginAsValidUser(String username, String password) {
        // ...
    }

    // 3. Return page objects
    public HomePage login() {
        return new HomePage(driver);
    }

    // 4. Handle synchronization in page
    public void waitForPageLoad() {
        wait.until(ExpectedConditions.visibilityOfElementLocated(usernameLocator));
    }
}

// âŒ BAD
public class LoginPage {
    // Don't expose WebElements
    public WebElement getUsername() {
        return driver.findElement(By.id("username"));
    }

    // Don't return void for navigation actions
    public void clickLogin() {
        // Should return next page
    }

    // Don't put assertions in page objects
    public void verifyTitle() {
        Assert.assertEquals(driver.getTitle(), "Login");  // BAD
    }
}
```
**Follow-up**: What's difference between POM and Page Factory? Should you return page objects or void? Where should waits be implemented? What are page components?

---

## Handling Web Elements (5 Questions)

### Q56: How do you handle dropdowns in Selenium?
**Difficulty**: Basic | **Experience**: 0-2, 3-5, 6-8
**Companies**: All companies
**Answer**: Two types: 1) **Select dropdown** (HTML `<select>` tag) - Use Select class methods: selectByVisibleText(), selectByValue(), selectByIndex(), getOptions(), getAllSelectedOptions(), 2) **Non-select dropdown** (div/ul/li) - Use regular WebElement methods with waits. Select class doesn't work on custom dropdowns.
**Code**:
```java
// 1. Select Dropdown (HTML <select> tag)
WebElement dropdownElement = driver.findElement(By.id("country"));
Select dropdown = new Select(dropdownElement);

// Select by visible text
dropdown.selectByVisibleText("India");

// Select by value attribute
dropdown.selectByValue("IND");

// Select by index (0-based)
dropdown.selectByIndex(2);

// Get selected option
WebElement selectedOption = dropdown.getFirstSelectedOption();
String selectedText = selectedOption.getText();

// Get all options
List<WebElement> allOptions = dropdown.getOptions();
System.out.println("Total options: " + allOptions.size());

// Print all options
for (WebElement option : allOptions) {
    System.out.println(option.getText());
}

// Check if dropdown is multi-select
boolean isMultiple = dropdown.isMultiple();

// Multi-select dropdown
if (dropdown.isMultiple()) {
    dropdown.selectByVisibleText("Option1");
    dropdown.selectByVisibleText("Option2");
    dropdown.selectByVisibleText("Option3");

    // Get all selected options
    List<WebElement> selected = dropdown.getAllSelectedOptions();

    // Deselect options
    dropdown.deselectByVisibleText("Option2");
    dropdown.deselectByIndex(0);
    dropdown.deselectByValue("opt1");
    dropdown.deselectAll();  // Deselect all
}

// 2. Non-Select Dropdown (Custom dropdown - div/ul/li)
// Step 1: Click dropdown to open
driver.findElement(By.id("customDropdown")).click();

// Step 2: Wait for options to be visible
WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
wait.until(ExpectedConditions.visibilityOfElementLocated(
    By.xpath("//ul[@class='dropdown-menu']")
));

// Step 3: Click desired option
driver.findElement(By.xpath("//li[text()='India']")).click();

// Alternative: Using Actions class
Actions actions = new Actions(driver);
WebElement dropdown = driver.findElement(By.id("customDropdown"));
actions.moveToElement(dropdown).click().perform();
WebElement option = driver.findElement(By.xpath("//li[text()='India']"));
actions.moveToElement(option).click().perform();

// 3. Bootstrap Dropdown
driver.findElement(By.cssSelector(".dropdown-toggle")).click();
wait.until(ExpectedConditions.visibilityOfElementLocated(
    By.cssSelector(".dropdown-menu")
));
driver.findElement(By.xpath("//a[text()='Action']")).click();

// 4. Auto-suggest Dropdown (Search dropdown)
WebElement searchBox = driver.findElement(By.id("search"));
searchBox.sendKeys("Selenium");

// Wait for suggestions to appear
wait.until(ExpectedConditions.visibilityOfElementLocated(
    By.cssSelector(".suggestions")
));

// Select from suggestions
List<WebElement> suggestions = driver.findElements(
    By.cssSelector(".suggestions li")
);
for (WebElement suggestion : suggestions) {
    if (suggestion.getText().equals("Selenium WebDriver")) {
        suggestion.click();
        break;
    }
}

// 5. Dropdown utility class
public class DropdownHelper {
    private WebDriver driver;
    private WebDriverWait wait;

    public DropdownHelper(WebDriver driver) {
        this.driver = driver;
        this.wait = new WebDriverWait(driver, Duration.ofSeconds(10));
    }

    // Select dropdown
    public void selectByText(By locator, String text) {
        WebElement element = driver.findElement(locator);
        Select dropdown = new Select(element);
        dropdown.selectByVisibleText(text);
    }

    public void selectByValue(By locator, String value) {
        WebElement element = driver.findElement(locator);
        Select dropdown = new Select(element);
        dropdown.selectByValue(value);
    }

    // Custom dropdown
    public void selectCustomDropdown(By dropdownLocator,
                                     By optionsLocator,
                                     String optionText) {
        driver.findElement(dropdownLocator).click();
        wait.until(ExpectedConditions.visibilityOfElementLocated(optionsLocator));

        List<WebElement> options = driver.findElements(optionsLocator);
        for (WebElement option : options) {
            if (option.getText().equals(optionText)) {
                option.click();
                break;
            }
        }
    }

    // Get all dropdown options as List<String>
    public List<String> getAllOptions(By locator) {
        WebElement element = driver.findElement(locator);
        Select dropdown = new Select(element);
        return dropdown.getOptions().stream()
            .map(WebElement::getText)
            .collect(Collectors.toList());
    }
}

// Real-world example: Page Object with dropdown
public class RegistrationPage {
    private WebDriver driver;
    private DropdownHelper dropdownHelper;

    private By countryDropdown = By.id("country");
    private By stateDropdown = By.id("state");

    public RegistrationPage(WebDriver driver) {
        this.driver = driver;
        this.dropdownHelper = new DropdownHelper(driver);
    }

    public void selectCountry(String country) {
        dropdownHelper.selectByText(countryDropdown, country);
    }

    public void selectState(String state) {
        dropdownHelper.selectByText(stateDropdown, state);
    }

    public List<String> getAllCountries() {
        return dropdownHelper.getAllOptions(countryDropdown);
    }
}
```
**Follow-up**: How to select from multi-select dropdown? How to verify if option is selected? How to handle dynamic dropdowns? What if Select class doesn't work?

---

### Q57: How to handle alerts, prompts, and confirmations?
**Difficulty**: Basic | **Experience**: 0-2, 3-5, 6-8
**Companies**: All companies
**Answer**: Use driver.switchTo().alert() to handle JavaScript alerts. Three types: 1) **Alert** (OK button only), 2) **Confirm** (OK and Cancel), 3) **Prompt** (input text + OK/Cancel). Methods: accept() (click OK), dismiss() (click Cancel), getText() (get alert text), sendKeys() (enter text in prompt).
**Code**:
```java
// 1. Simple Alert (OK button only)
driver.findElement(By.id("alertBtn")).click();

// Switch to alert
Alert alert = driver.switchTo().alert();

// Get alert text
String alertText = alert.getText();
System.out.println("Alert text: " + alertText);

// Accept alert (click OK)
alert.accept();

// 2. Confirmation Alert (OK and Cancel buttons)
driver.findElement(By.id("confirmBtn")).click();

Alert confirm = driver.switchTo().alert();
String confirmText = confirm.getText();

// Accept (click OK)
confirm.accept();

// OR Dismiss (click Cancel)
confirm.dismiss();

// 3. Prompt Alert (input box + OK/Cancel)
driver.findElement(By.id("promptBtn")).click();

Alert prompt = driver.switchTo().alert();

// Enter text
prompt.sendKeys("Selenium WebDriver");

// Accept
prompt.accept();

// OR dismiss without entering text
prompt.dismiss();

// 4. Wait for alert to be present
WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
wait.until(ExpectedConditions.alertIsPresent());

Alert alert = driver.switchTo().alert();
alert.accept();

// 5. Handle alert with try-catch
try {
    Alert alert = driver.switchTo().alert();
    System.out.println("Alert present: " + alert.getText());
    alert.accept();
} catch (NoAlertPresentException e) {
    System.out.println("No alert present");
}

// 6. Alert utility class
public class AlertHelper {
    private WebDriver driver;
    private WebDriverWait wait;

    public AlertHelper(WebDriver driver) {
        this.driver = driver;
        this.wait = new WebDriverWait(driver, Duration.ofSeconds(10));
    }

    public void acceptAlert() {
        wait.until(ExpectedConditions.alertIsPresent());
        driver.switchTo().alert().accept();
    }

    public void dismissAlert() {
        wait.until(ExpectedConditions.alertIsPresent());
        driver.switchTo().alert().dismiss();
    }

    public String getAlertText() {
        wait.until(ExpectedConditions.alertIsPresent());
        return driver.switchTo().alert().getText();
    }

    public void acceptAlertIfPresent() {
        try {
            Alert alert = driver.switchTo().alert();
            alert.accept();
        } catch (NoAlertPresentException e) {
            // No alert present, continue
        }
    }

    public void enterTextInPrompt(String text) {
        wait.until(ExpectedConditions.alertIsPresent());
        Alert alert = driver.switchTo().alert();
        alert.sendKeys(text);
        alert.accept();
    }

    public boolean isAlertPresent() {
        try {
            driver.switchTo().alert();
            return true;
        } catch (NoAlertPresentException e) {
            return false;
        }
    }
}

// Usage in test
AlertHelper alertHelper = new AlertHelper(driver);

// Accept alert
driver.findElement(By.id("alertBtn")).click();
alertHelper.acceptAlert();

// Get alert text and dismiss
driver.findElement(By.id("confirmBtn")).click();
String text = alertHelper.getAlertText();
Alert alert = driver.switchTo().alert();
alert.dismiss();

// Enter text in prompt
driver.findElement(By.id("promptBtn")).click();
alertHelper.enterTextInPrompt("Test input");

// 7. Real-world scenario: Delete confirmation
public class ProductPage {
    private WebDriver driver;
    private AlertHelper alertHelper;

    private By deleteButton = By.id("delete");

    public ProductPage(WebDriver driver) {
        this.driver = driver;
        this.alertHelper = new AlertHelper(driver);
    }

    public void deleteProduct() {
        driver.findElement(deleteButton).click();
        // Wait for confirmation alert
        String alertText = alertHelper.getAlertText();
        if (alertText.contains("Are you sure")) {
            alertHelper.acceptAlert();
        }
    }

    public void cancelDelete() {
        driver.findElement(deleteButton).click();
        alertHelper.dismissAlert();
    }
}

// 8. Authentication alert (Not JavaScript - different approach)
// For HTTP Basic Auth
driver.get("https://username:password@example.com");

// OR using Alert (doesn't work for HTTP auth)
// Use ChromeOptions instead
ChromeOptions options = new ChromeOptions();
options.addArguments("--disable-blink-features=AutomationControlled");
WebDriver driver = new ChromeDriver(options);

// For authentication, pass credentials in URL
String username = "admin";
String password = "admin123";
String url = "https://example.com";
driver.get("https://" + username + ":" + password + "@" + url.substring(8));
```
**Follow-up**: Can you handle authentication alerts with Alert? How to check if alert is present? What's difference between alert and modal dialog? How to handle alerts in headless mode?

---

### Q58: How to handle frames and iframes?
**Difficulty**: Medium | **Experience**: 3-5, 6-8
**Companies**: Amazon, Microsoft, Flipkart
**Answer**: Frames/iframes are separate HTML documents embedded in page. Must switch to frame before interacting with elements inside it. Methods: switchTo().frame(index), switchTo().frame(nameOrId), switchTo().frame(WebElement), switchTo().defaultContent() (back to main page), switchTo().parentFrame() (back to parent frame).
**Code**:
```java
// 1. Switch to frame by index (0-based)
driver.switchTo().frame(0);  // First frame
driver.findElement(By.id("elementInFrame")).click();

// 2. Switch to frame by name or ID
driver.switchTo().frame("frameName");
driver.findElement(By.id("elementInFrame")).click();

driver.switchTo().frame("frameId");
driver.findElement(By.id("elementInFrame")).click();

// 3. Switch to frame by WebElement (RECOMMENDED)
WebElement frameElement = driver.findElement(By.id("myFrame"));
driver.switchTo().frame(frameElement);
driver.findElement(By.id("elementInFrame")).click();

// 4. Switch back to main content (default content)
driver.switchTo().defaultContent();
driver.findElement(By.id("elementInMainPage")).click();

// 5. Switch to parent frame (nested frames)
driver.switchTo().frame("parentFrame");
driver.switchTo().frame("childFrame");
// Now in child frame
driver.switchTo().parentFrame();  // Back to parent frame
driver.switchTo().defaultContent();  // Back to main page

// 6. Wait for frame to be available and switch
WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
wait.until(ExpectedConditions.frameToBeAvailableAndSwitchToIt("frameName"));
driver.findElement(By.id("elementInFrame")).click();

// Wait for frame by WebElement
WebElement frameElement = driver.findElement(By.id("myFrame"));
wait.until(ExpectedConditions.frameToBeAvailableAndSwitchToIt(frameElement));

// Wait for frame by locator
wait.until(ExpectedConditions.frameToBeAvailableAndSwitchToIt(
    By.id("myFrame")
));

// 7. Handle nested frames
// Main page â†’ Frame1 â†’ Frame2 â†’ Element
driver.switchTo().frame("frame1");  // Switch to frame1
driver.switchTo().frame("frame2");  // Switch to frame2 inside frame1
driver.findElement(By.id("element")).click();  // Click element in frame2
driver.switchTo().parentFrame();  // Back to frame1
driver.switchTo().defaultContent();  // Back to main page

// 8. Get total number of frames
int totalFrames = driver.findElements(By.tagName("iframe")).size();
System.out.println("Total frames: " + totalFrames);

// 9. Frame utility class
public class FrameHelper {
    private WebDriver driver;
    private WebDriverWait wait;

    public FrameHelper(WebDriver driver) {
        this.driver = driver;
        this.wait = new WebDriverWait(driver, Duration.ofSeconds(10));
    }

    public void switchToFrame(String frameNameOrId) {
        wait.until(ExpectedConditions.frameToBeAvailableAndSwitchToIt(frameNameOrId));
    }

    public void switchToFrame(int frameIndex) {
        driver.switchTo().frame(frameIndex);
    }

    public void switchToFrame(By frameLocator) {
        wait.until(ExpectedConditions.frameToBeAvailableAndSwitchToIt(frameLocator));
    }

    public void switchToFrameByElement(By frameLocator) {
        WebElement frameElement = wait.until(
            ExpectedConditions.presenceOfElementLocated(frameLocator)
        );
        driver.switchTo().frame(frameElement);
    }

    public void switchToDefaultContent() {
        driver.switchTo().defaultContent();
    }

    public void switchToParentFrame() {
        driver.switchTo().parentFrame();
    }

    public int getFrameCount() {
        return driver.findElements(By.tagName("iframe")).size();
    }

    public List<String> getAllFrameNames() {
        List<WebElement> frames = driver.findElements(By.tagName("iframe"));
        return frames.stream()
            .map(frame -> frame.getAttribute("name"))
            .filter(name -> name != null && !name.isEmpty())
            .collect(Collectors.toList());
    }
}

// Usage
FrameHelper frameHelper = new FrameHelper(driver);

frameHelper.switchToFrame("frameName");
driver.findElement(By.id("element")).click();
frameHelper.switchToDefaultContent();

// 10. Real-world example: WYSIWYG editor (usually in iframe)
public class EmailComposePage {
    private WebDriver driver;
    private FrameHelper frameHelper;

    private By editorFrame = By.cssSelector("iframe.editor");
    private By textArea = By.id("tinymce");

    public EmailComposePage(WebDriver driver) {
        this.driver = driver;
        this.frameHelper = new FrameHelper(driver);
    }

    public void typeInEditor(String text) {
        // Switch to editor frame
        frameHelper.switchToFrame(editorFrame);

        // Type in editor
        driver.findElement(textArea).sendKeys(text);

        // Switch back to main page
        frameHelper.switchToDefaultContent();
    }
}

// 11. Handle frame when frame ID is dynamic
// Find frame by other attributes
WebElement frame = driver.findElement(
    By.xpath("//iframe[contains(@src,'editor')]")
);
driver.switchTo().frame(frame);

// 12. Verify if element is in frame
public boolean isElementInFrame(By elementLocator) {
    try {
        driver.findElement(elementLocator);
        return false;  // Element in main content
    } catch (NoSuchElementException e) {
        // Check in frames
        List<WebElement> frames = driver.findElements(By.tagName("iframe"));
        for (int i = 0; i < frames.size(); i++) {
            driver.switchTo().frame(i);
            try {
                driver.findElement(elementLocator);
                driver.switchTo().defaultContent();
                return true;  // Element found in frame
            } catch (NoSuchElementException ex) {
                driver.switchTo().defaultContent();
            }
        }
        return false;
    }
}
```
**Follow-up**: What's difference between frame and iframe? How to switch between nested frames? How to find which frame contains element? Can you have multiple frames with same name?

---

### Q59: How to handle multiple windows and tabs?
**Difficulty**: Medium | **Experience**: 3-5, 6-8, 9-12
**Companies**: Google, Amazon, Microsoft
**Answer**: Use window handles to switch between windows/tabs. getWindowHandle() returns current window handle, getWindowHandles() returns all window handles. Use switchTo().window(handle) to switch. Close window with close(), quit() closes all windows. Store parent window handle before switching.
**Code**:
```java
// 1. Get current window handle
String parentWindow = driver.getWindowHandle();
System.out.println("Parent window: " + parentWindow);

// 2. Click link that opens new window/tab
driver.findElement(By.id("newWindowBtn")).click();

// 3. Get all window handles
Set<String> allWindows = driver.getWindowHandles();
System.out.println("Total windows: " + allWindows.size());

// 4. Switch to new window
for (String window : allWindows) {
    if (!window.equals(parentWindow)) {
        driver.switchTo().window(window);
        break;
    }
}

// Perform actions in new window
System.out.println("Child window title: " + driver.getTitle());
driver.findElement(By.id("childElement")).click();

// Close child window
driver.close();

// Switch back to parent window
driver.switchTo().window(parentWindow);

// 5. Handle multiple windows (more than 2)
String parent = driver.getWindowHandle();
driver.findElement(By.id("openMultiple")).click();

Set<String> windows = driver.getWindowHandles();
for (String window : windows) {
    if (!window.equals(parent)) {
        driver.switchTo().window(window);
        System.out.println("Title: " + driver.getTitle());

        // Perform action
        driver.findElement(By.id("element")).click();

        // Close this window
        driver.close();
    }
}

// Switch back to parent
driver.switchTo().window(parent);

// 6. Wait for new window to open
WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
String parent = driver.getWindowHandle();

driver.findElement(By.id("newWindow")).click();

// Wait until number of windows is 2
wait.until(ExpectedConditions.numberOfWindowsToBe(2));

// Switch to new window
for (String window : driver.getWindowHandles()) {
    if (!window.equals(parent)) {
        driver.switchTo().window(window);
        break;
    }
}

// 7. Window utility class
public class WindowHelper {
    private WebDriver driver;
    private WebDriverWait wait;

    public WindowHelper(WebDriver driver) {
        this.driver = driver;
        this.wait = new WebDriverWait(driver, Duration.ofSeconds(10));
    }

    public void switchToNewWindow() {
        String parentWindow = driver.getWindowHandle();
        Set<String> allWindows = driver.getWindowHandles();

        for (String window : allWindows) {
            if (!window.equals(parentWindow)) {
                driver.switchTo().window(window);
                break;
            }
        }
    }

    public void switchToWindowByTitle(String title) {
        Set<String> windows = driver.getWindowHandles();

        for (String window : windows) {
            driver.switchTo().window(window);
            if (driver.getTitle().equals(title)) {
                break;
            }
        }
    }

    public void switchToWindowByUrl(String url) {
        Set<String> windows = driver.getWindowHandles();

        for (String window : windows) {
            driver.switchTo().window(window);
            if (driver.getCurrentUrl().contains(url)) {
                break;
            }
        }
    }

    public void closeAllWindowsExcept(String parentWindow) {
        Set<String> windows = driver.getWindowHandles();

        for (String window : windows) {
            if (!window.equals(parentWindow)) {
                driver.switchTo().window(window);
                driver.close();
            }
        }

        driver.switchTo().window(parentWindow);
    }

    public void closeCurrentAndSwitchToParent(String parentWindow) {
        driver.close();
        driver.switchTo().window(parentWindow);
    }

    public int getWindowCount() {
        return driver.getWindowHandles().size();
    }

    public void waitForWindowCount(int expectedCount) {
        wait.until(ExpectedConditions.numberOfWindowsToBe(expectedCount));
    }

    public String getParentWindowHandle() {
        return driver.getWindowHandle();
    }
}

// Usage
WindowHelper windowHelper = new WindowHelper(driver);

String parent = windowHelper.getParentWindowHandle();
driver.findElement(By.id("newWindow")).click();

windowHelper.waitForWindowCount(2);
windowHelper.switchToNewWindow();

// Do actions in new window
driver.findElement(By.id("element")).click();

windowHelper.closeCurrentAndSwitchToParent(parent);

// 8. Real-world example: Social login (opens in new window)
public class LoginPage {
    private WebDriver driver;
    private WindowHelper windowHelper;

    private By googleLoginButton = By.id("googleLogin");
    private By emailInput = By.id("email");
    private By passwordInput = By.id("password");

    public LoginPage(WebDriver driver) {
        this.driver = driver;
        this.windowHelper = new WindowHelper(driver);
    }

    public HomePage loginWithGoogle(String email, String password) {
        String parentWindow = windowHelper.getParentWindowHandle();

        // Click Google login - opens new window
        driver.findElement(googleLoginButton).click();

        // Wait for new window
        windowHelper.waitForWindowCount(2);

        // Switch to Google login window
        windowHelper.switchToWindowByUrl("accounts.google.com");

        // Enter credentials
        driver.findElement(emailInput).sendKeys(email);
        driver.findElement(passwordInput).sendKeys(password);
        driver.findElement(By.id("submit")).click();

        // Wait for window to close (Google redirects back)
        windowHelper.waitForWindowCount(1);

        // Back to parent window
        driver.switchTo().window(parentWindow);

        return new HomePage(driver);
    }
}

// 9. Open new tab (JavaScript)
JavascriptExecutor js = (JavascriptExecutor) driver;
js.executeScript("window.open('https://example.com', '_blank');");

windowHelper.waitForWindowCount(2);
windowHelper.switchToNewWindow();

// 10. Switch to last opened window
Set<String> windows = driver.getWindowHandles();
String lastWindow = "";
for (String window : windows) {
    lastWindow = window;
}
driver.switchTo().window(lastWindow);

// 11. Get window handles as List (for indexed access)
List<String> windowList = new ArrayList<>(driver.getWindowHandles());
driver.switchTo().window(windowList.get(0));  // First window
driver.switchTo().window(windowList.get(1));  // Second window
```
**Follow-up**: What's difference between close() and quit()? How to switch to window by title? How to close all windows except parent? What's difference between window and tab?

---

### Q60: How to handle file upload and download?
**Difficulty**: Medium | **Experience**: 3-5, 6-8, 9-12
**Companies**: Amazon, Microsoft, Adobe
**Answer**: **File Upload**: If `<input type="file">`, use sendKeys() with file path. For non-standard upload, use AutoIT, Robot class, or sikuli. **File Download**: Set Chrome/Firefox preferences for download location. Verify download using File class. Cannot download directly with Selenium - browser downloads to specified folder.
**Code**:
```java
// 1. File Upload - Standard (input type="file")
WebElement uploadElement = driver.findElement(By.id("fileUpload"));
String filePath = "/path/to/file.txt";  // Absolute path
uploadElement.sendKeys(filePath);

// Platform-independent path
String projectPath = System.getProperty("user.dir");
String filePath = projectPath + "/testdata/file.pdf";
uploadElement.sendKeys(filePath);

// Multiple file upload (if supported)
String file1 = "/path/to/file1.txt";
String file2 = "/path/to/file2.txt";
uploadElement.sendKeys(file1 + "\n" + file2);

// 2. File Upload - Using Robot class (for Windows file dialog)
WebElement uploadButton = driver.findElement(By.id("upload"));
uploadButton.click();  // Opens file chooser dialog

// Use Robot class to handle OS dialog
Robot robot = new Robot();
StringSelection filePath = new StringSelection("C:\\file.txt");
Toolkit.getDefaultToolkit().getSystemClipboard().setContents(filePath, null);

// Press Ctrl+V to paste file path
robot.keyPress(KeyEvent.VK_CONTROL);
robot.keyPress(KeyEvent.VK_V);
robot.keyRelease(KeyEvent.VK_V);
robot.keyRelease(KeyEvent.VK_CONTROL);

// Press Enter to submit
robot.keyPress(KeyEvent.VK_ENTER);
robot.keyRelease(KeyEvent.VK_ENTER);

// 3. File Download - Chrome configuration
ChromeOptions options = new ChromeOptions();
Map<String, Object> prefs = new HashMap<>();

// Set download directory
String downloadPath = System.getProperty("user.dir") + "/downloads";
prefs.put("download.default_directory", downloadPath);
prefs.put("download.prompt_for_download", false);  // Disable prompt
prefs.put("plugins.always_open_pdf_externally", true);  // Auto download PDF

options.setExperimentalOption("prefs", prefs);
WebDriver driver = new ChromeDriver(options);

// Click download link
driver.findElement(By.id("downloadLink")).click();

// Wait for file to download
Thread.sleep(5000);  // Better: Use proper wait

// Verify file downloaded
File downloadedFile = new File(downloadPath + "/file.pdf");
Assert.assertTrue(downloadedFile.exists());

// 4. File Download - Firefox configuration
FirefoxOptions options = new FirefoxOptions();
FirefoxProfile profile = new FirefoxProfile();

String downloadPath = System.getProperty("user.dir") + "/downloads";
profile.setPreference("browser.download.folderList", 2);
profile.setPreference("browser.download.dir", downloadPath);
profile.setPreference("browser.download.useDownloadDir", true);
profile.setPreference("browser.helperApps.neverAsk.saveToDisk",
    "application/pdf,application/zip,application/octet-stream");
profile.setPreference("pdfjs.disabled", true);  // Disable PDF viewer

options.setProfile(profile);
WebDriver driver = new FirefoxDriver(options);

// 5. Wait for file download to complete
public boolean isFileDownloaded(String downloadPath, String fileName, int timeoutSeconds) {
    int elapsedTime = 0;
    File file = new File(downloadPath + "/" + fileName);

    while (elapsedTime < timeoutSeconds) {
        if (file.exists()) {
            return true;
        }
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        elapsedTime++;
    }
    return false;
}

// Usage
String downloadPath = System.getProperty("user.dir") + "/downloads";
driver.findElement(By.id("downloadBtn")).click();
boolean downloaded = isFileDownloaded(downloadPath, "report.pdf", 30);
Assert.assertTrue(downloaded, "File not downloaded");

// 6. File upload/download utility class
public class FileHelper {
    private WebDriver driver;
    private String downloadPath;

    public FileHelper(WebDriver driver) {
        this.driver = driver;
        this.downloadPath = System.getProperty("user.dir") + "/downloads";
    }

    // Upload file
    public void uploadFile(By uploadLocator, String fileName) {
        String filePath = System.getProperty("user.dir") + "/testdata/" + fileName;
        WebElement uploadElement = driver.findElement(uploadLocator);
        uploadElement.sendKeys(filePath);
    }

    // Verify file exists
    public boolean isFileExists(String fileName) {
        File file = new File(downloadPath + "/" + fileName);
        return file.exists();
    }

    // Wait for file download
    public boolean waitForFileDownload(String fileName, int timeoutSeconds) {
        int elapsed = 0;
        while (elapsed < timeoutSeconds) {
            if (isFileExists(fileName)) {
                return true;
            }
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            elapsed++;
        }
        return false;
    }

    // Delete downloaded file
    public void deleteFile(String fileName) {
        File file = new File(downloadPath + "/" + fileName);
        if (file.exists()) {
            file.delete();
        }
    }

    // Clear downloads folder
    public void clearDownloadsFolder() {
        File folder = new File(downloadPath);
        File[] files = folder.listFiles();
        if (files != null) {
            for (File file : files) {
                file.delete();
            }
        }
    }

    // Get file size
    public long getFileSize(String fileName) {
        File file = new File(downloadPath + "/" + fileName);
        return file.length();
    }

    // Read file content
    public String readFileContent(String fileName) throws IOException {
        File file = new File(downloadPath + "/" + fileName);
        return new String(Files.readAllBytes(file.toPath()));
    }
}

// Usage in test
FileHelper fileHelper = new FileHelper(driver);

// Upload
fileHelper.uploadFile(By.id("fileUpload"), "document.pdf");

// Download and verify
driver.findElement(By.id("downloadBtn")).click();
boolean downloaded = fileHelper.waitForFileDownload("report.pdf", 30);
Assert.assertTrue(downloaded);

// Cleanup
fileHelper.deleteFile("report.pdf");

// 7. Real-world example: Page Object with file operations
public class DocumentsPage {
    private WebDriver driver;
    private FileHelper fileHelper;

    private By uploadButton = By.id("upload");
    private By downloadButton = By.id("download");
    private By fileList = By.cssSelector(".file-list");

    public DocumentsPage(WebDriver driver) {
        this.driver = driver;
        this.fileHelper = new FileHelper(driver);
    }

    public void uploadDocument(String fileName) {
        fileHelper.uploadFile(uploadButton, fileName);
        // Wait for upload success message
        new WebDriverWait(driver, Duration.ofSeconds(10))
            .until(ExpectedConditions.visibilityOfElementLocated(
                By.xpath("//div[contains(text(),'Upload successful')]")
            ));
    }

    public void downloadDocument(String documentName) {
        driver.findElement(By.xpath(
            "//span[text()='" + documentName + "']/following-sibling::button"
        )).click();

        boolean downloaded = fileHelper.waitForFileDownload(documentName, 30);
        if (!downloaded) {
            throw new RuntimeException("Document download failed");
        }
    }

    public boolean isDocumentDownloaded(String documentName) {
        return fileHelper.isFileExists(documentName);
    }
}

// 8. AutoIT for file upload (advanced - requires AutoIT script)
// Create AutoIT script: FileUpload.au3
/*
ControlFocus("Open", "", "Edit1")
ControlSetText("Open", "", "Edit1", $CmdLine[1])
ControlClick("Open", "", "Button1")
*/
// Compile to FileUpload.exe

// Use in Java
driver.findElement(By.id("upload")).click();  // Opens dialog
Runtime.getRuntime().exec("path/to/FileUpload.exe C:\\file.txt");
```
**Follow-up**: How to handle non-standard file upload? How to verify file downloaded successfully? How to read downloaded file content? Can Selenium directly download file without browser?

---

## Actions Class & Advanced Interactions (5 Questions)

### Q61: Explain Actions class and its methods
**Difficulty**: Medium | **Experience**: 3-5, 6-8
**Companies**: All companies
**Answer**: Actions class provides advanced user interactions: mouse hover, drag-drop, right-click, double-click, keyboard actions, composite actions. Must call build().perform() or perform() to execute actions. Used when WebElement methods insufficient. Common methods: moveToElement(), click(), doubleClick(), contextClick(), dragAndDrop(), sendKeys(), keyDown(), keyUp().
**Code**:
```java
Actions actions = new Actions(driver);

// 1. Mouse Hover (Move to element)
WebElement element = driver.findElement(By.id("menu"));
actions.moveToElement(element).perform();

// Hover and click
actions.moveToElement(element).click().perform();

// 2. Right Click (Context Click)
WebElement element = driver.findElement(By.id("item"));
actions.contextClick(element).perform();

// 3. Double Click
WebElement element = driver.findElement(By.id("button"));
actions.doubleClick(element).perform();

// 4. Drag and Drop
WebElement source = driver.findElement(By.id("draggable"));
WebElement target = driver.findElement(By.id("droppable"));

// Method 1: dragAndDrop
actions.dragAndDrop(source, target).perform();

// Method 2: clickAndHold â†’ moveToElement â†’ release
actions.clickAndHold(source)
       .moveToElement(target)
       .release()
       .perform();

// Method 3: dragAndDropBy (by offset)
actions.dragAndDropBy(source, 100, 200).perform();  // x=100, y=200

// 5. Click and Hold
actions.clickAndHold(element).perform();
// Release later
actions.release().perform();

// 6. Move by offset
actions.moveByOffset(100, 200).click().perform();

// 7. Keyboard actions
// Press single key
actions.sendKeys(Keys.ENTER).perform();

// Press key combination
actions.keyDown(Keys.CONTROL).sendKeys("a").keyUp(Keys.CONTROL).perform();  // Ctrl+A

// Copy-Paste
actions.keyDown(Keys.CONTROL).sendKeys("c").keyUp(Keys.CONTROL).perform();  // Ctrl+C
actions.keyDown(Keys.CONTROL).sendKeys("v").keyUp(Keys.CONTROL).perform();  // Ctrl+V

// 8. Composite actions (chaining)
actions.moveToElement(element1)
       .click()
       .moveToElement(element2)
       .doubleClick()
       .moveToElement(element3)
       .contextClick()
       .perform();

// 9. Scroll to element
WebElement element = driver.findElement(By.id("bottom"));
actions.scrollToElement(element).perform();

// 10. Real-world examples

// Example 1: Hover menu
WebElement menu = driver.findElement(By.id("menu"));
WebElement submenu = driver.findElement(By.id("submenu"));

actions.moveToElement(menu).perform();  // Hover on menu
Thread.sleep(500);  // Wait for submenu to appear (use proper wait)
actions.moveToElement(submenu).click().perform();

// Example 2: Slider
WebElement slider = driver.findElement(By.cssSelector(".slider"));
actions.dragAndDropBy(slider, 100, 0).perform();  // Move slider right by 100px

// Example 3: Select multiple items (with Ctrl)
WebElement item1 = driver.findElement(By.id("item1"));
WebElement item2 = driver.findElement(By.id("item2"));
WebElement item3 = driver.findElement(By.id("item3"));

actions.keyDown(Keys.CONTROL)
       .click(item1)
       .click(item2)
       .click(item3)
       .keyUp(Keys.CONTROL)
       .perform();

// Example 4: Draw signature (drag in pattern)
WebElement canvas = driver.findElement(By.id("signatureCanvas"));
actions.clickAndHold(canvas)
       .moveByOffset(50, 0)
       .moveByOffset(0, 50)
       .moveByOffset(-50, 0)
       .release()
       .perform();

// 11. Actions utility class
public class ActionsHelper {
    private WebDriver driver;
    private Actions actions;

    public ActionsHelper(WebDriver driver) {
        this.driver = driver;
        this.actions = new Actions(driver);
    }

    public void hoverElement(WebElement element) {
        actions.moveToElement(element).perform();
    }

    public void hoverAndClick(WebElement element) {
        actions.moveToElement(element).click().perform();
    }

    public void doubleClick(WebElement element) {
        actions.doubleClick(element).perform();
    }

    public void rightClick(WebElement element) {
        actions.contextClick(element).perform();
    }

    public void dragAndDrop(WebElement source, WebElement target) {
        actions.dragAndDrop(source, target).perform();
    }

    public void moveSlider(WebElement slider, int xOffset) {
        actions.dragAndDropBy(slider, xOffset, 0).perform();
    }

    public void pressKeys(Keys... keys) {
        actions.sendKeys(keys).perform();
    }

    public void pressKeyCombo(Keys modifier, String key) {
        actions.keyDown(modifier)
               .sendKeys(key)
               .keyUp(modifier)
               .perform();
    }

    public void scrollToElement(WebElement element) {
        actions.scrollToElement(element).perform();
    }
}

// Usage
ActionsHelper actionsHelper = new ActionsHelper(driver);

actionsHelper.hoverElement(menuElement);
actionsHelper.doubleClick(buttonElement);
actionsHelper.dragAndDrop(sourceElement, targetElement);
actionsHelper.pressKeyCombo(Keys.CONTROL, "a");
```
**Follow-up**: What's difference between click() and WebElement.click()? When to use Actions class? How to perform keyboard shortcuts? What is build() vs perform()?

---

## JavaScript Executor (5 Questions)

### Q62: What is JavaScript Executor? When and why to use it?
**Difficulty**: Medium | **Experience**: 3-5, 6-8, 9-12
**Companies**: Amazon, Google, Microsoft, Flipkart
**Answer**: JavascriptExecutor is interface to execute JavaScript code in Selenium. Used when standard WebDriver methods don't work. Use cases: 1) Click hidden/overlapped elements, 2) Scroll to element, 3) Get/set element attributes, 4) Handle dynamic content, 5) Change element properties, 6) Execute complex operations. Methods: executeScript() (synchronous), executeAsyncScript() (asynchronous). Returns Object that needs type casting.
**Code**:
```java
// Cast WebDriver to JavascriptExecutor
JavascriptExecutor js = (JavascriptExecutor) driver;

// 1. Click element (when regular click doesn't work)
WebElement element = driver.findElement(By.id("button"));
js.executeScript("arguments[0].click();", element);

// 2. Scroll to element
WebElement element = driver.findElement(By.id("footer"));
js.executeScript("arguments[0].scrollIntoView(true);", element);

// Scroll to element (centered)
js.executeScript("arguments[0].scrollIntoView({block: 'center'});", element);

// 3. Scroll to top of page
js.executeScript("window.scrollTo(0, 0);");

// Scroll to bottom of page
js.executeScript("window.scrollTo(0, document.body.scrollHeight);");

// Scroll by specific pixels
js.executeScript("window.scrollBy(0, 500);");  // Scroll down 500px

// 4. Enter text in input field (bypasses validation)
WebElement input = driver.findElement(By.id("username"));
js.executeScript("arguments[0].value='admin';", input);

// 5. Get element text (including hidden text)
WebElement element = driver.findElement(By.id("hidden"));
String text = (String) js.executeScript("return arguments[0].textContent;", element);

// 6. Get element attribute
String value = (String) js.executeScript("return arguments[0].getAttribute('value');", element);

// 7. Set element attribute
js.executeScript("arguments[0].setAttribute('value', 'new value');", element);

// 8. Remove attribute
js.executeScript("arguments[0].removeAttribute('disabled');", element);

// 9. Highlight element (for debugging)
js.executeScript("arguments[0].style.border='3px solid red'", element);

// Remove highlight
js.executeScript("arguments[0].style.border=''", element);

// 10. Check if element is visible
boolean isVisible = (boolean) js.executeScript(
    "return arguments[0].offsetWidth > 0 && arguments[0].offsetHeight > 0;",
    element
);

// 11. Get page title
String title = (String) js.executeScript("return document.title;");

// 12. Get current URL
String url = (String) js.executeScript("return window.location.href;");

// 13. Refresh page
js.executeScript("location.reload();");

// 14. Navigate to URL
js.executeScript("window.location = 'https://example.com';");

// 15. Open new tab
js.executeScript("window.open('https://example.com', '_blank');");

// 16. Alert operations
js.executeScript("alert('Hello from JavaScript');");

// 17. Get inner HTML
String innerHTML = (String) js.executeScript("return arguments[0].innerHTML;", element);

// 18. Change inner HTML
js.executeScript("arguments[0].innerHTML = '<b>New Content</b>';", element);

// 19. Get all links on page
List<WebElement> links = (List<WebElement>) js.executeScript(
    "return document.getElementsByTagName('a');"
);

// 20. Execute multiple JavaScript commands
String script = "arguments[0].style.backgroundColor = 'yellow';" +
                "arguments[0].style.border = '2px solid red';" +
                "return arguments[0].textContent;";
String text = (String) js.executeScript(script, element);

// 21. Wait for page load complete
js.executeScript("return document.readyState").equals("complete");

// 22. Handle date picker
WebElement datePicker = driver.findElement(By.id("date"));
js.executeScript("arguments[0].value='2024-12-25';", datePicker);

// 23. Disable element
js.executeScript("arguments[0].disabled = true;", element);

// 24. Focus on element
js.executeScript("arguments[0].focus();", element);

// 25. Click using coordinates
js.executeScript("document.elementFromPoint(100, 200).click();");

// 26. JavascriptExecutor utility class
public class JavaScriptHelper {
    private WebDriver driver;
    private JavascriptExecutor js;

    public JavaScriptHelper(WebDriver driver) {
        this.driver = driver;
        this.js = (JavascriptExecutor) driver;
    }

    public void clickElement(WebElement element) {
        js.executeScript("arguments[0].click();", element);
    }

    public void scrollToElement(WebElement element) {
        js.executeScript("arguments[0].scrollIntoView(true);", element);
    }

    public void scrollToTop() {
        js.executeScript("window.scrollTo(0, 0);");
    }

    public void scrollToBottom() {
        js.executeScript("window.scrollTo(0, document.body.scrollHeight);");
    }

    public void enterText(WebElement element, String text) {
        js.executeScript("arguments[0].value='" + text + "';", element);
    }

    public void highlightElement(WebElement element) {
        js.executeScript("arguments[0].style.border='3px solid red'", element);
    }

    public String getElementText(WebElement element) {
        return (String) js.executeScript("return arguments[0].textContent;", element);
    }

    public void refreshPage() {
        js.executeScript("location.reload();");
    }

    public void openNewTab(String url) {
        js.executeScript("window.open('" + url + "', '_blank');");
    }

    public boolean isPageLoaded() {
        return js.executeScript("return document.readyState").equals("complete");
    }

    public void waitForPageLoad() {
        new WebDriverWait(driver, Duration.ofSeconds(30)).until(
            driver -> js.executeScript("return document.readyState").equals("complete")
        );
    }

    public void flashElement(WebElement element, int times) {
        String originalStyle = element.getAttribute("style");
        for (int i = 0; i < times; i++) {
            js.executeScript("arguments[0].style.border='3px solid red'", element);
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {}
            js.executeScript("arguments[0].style.border=''", element);
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {}
        }
        js.executeScript("arguments[0].setAttribute('style', '" + originalStyle + "');", element);
    }
}

// Usage
JavaScriptHelper jsHelper = new JavaScriptHelper(driver);

jsHelper.scrollToElement(element);
jsHelper.clickElement(element);
jsHelper.highlightElement(element);
jsHelper.waitForPageLoad();

// Real-world scenario: Clicking hidden element
public class ProductPage {
    private WebDriver driver;
    private JavaScriptHelper jsHelper;

    private By addToCartButton = By.id("addCart");

    public ProductPage(WebDriver driver) {
        this.driver = driver;
        this.jsHelper = new JavaScriptHelper(driver);
    }

    public void addToCart() {
        WebElement button = driver.findElement(addToCartButton);

        // Try regular click first
        try {
            button.click();
        } catch (ElementClickInterceptedException e) {
            // If regular click fails, use JavaScript
            jsHelper.clickElement(button);
        }
    }
}
```
**Follow-up**: When should you use JavaScript Executor over regular WebDriver methods? What's difference between executeScript() and executeAsyncScript()? Can you return values from JavaScript? What are limitations?

---

### Q63: How to handle infinite scroll and lazy loading?
**Difficulty**: Medium | **Experience**: 6-8, 9-12
**Companies**: Amazon, Google, Facebook, LinkedIn
**Answer**: Infinite scroll loads content dynamically as user scrolls. Strategies: 1) **Scroll to bottom repeatedly** until no new content, 2) **Track element count** before/after scroll, 3) **Wait for loading indicator** to disappear, 4) **JavaScript to detect scroll end**, 5) Use JavascriptExecutor for scrolling. Common in social media feeds, search results, product listings.
**Code**:
```java
// 1. Basic infinite scroll - Scroll to bottom
JavascriptExecutor js = (JavascriptExecutor) driver;
long lastHeight = (long) js.executeScript("return document.body.scrollHeight");

while (true) {
    // Scroll to bottom
    js.executeScript("window.scrollTo(0, document.body.scrollHeight);");

    // Wait for new content to load
    Thread.sleep(2000);

    // Calculate new scroll height
    long newHeight = (long) js.executeScript("return document.body.scrollHeight");

    // Break if no new content
    if (newHeight == lastHeight) {
        break;
    }
    lastHeight = newHeight;
}

// 2. Track element count approach
public void scrollUntilAllLoaded(By elementLocator) {
    JavascriptExecutor js = (JavascriptExecutor) driver;
    int previousCount = 0;
    int currentCount = 0;
    int attempts = 0;
    int maxAttempts = 10;

    while (attempts < maxAttempts) {
        currentCount = driver.findElements(elementLocator).size();

        // If count hasn't changed, we've loaded everything
        if (currentCount == previousCount) {
            attempts++;
        } else {
            attempts = 0;  // Reset if new items loaded
        }

        previousCount = currentCount;

        // Scroll to bottom
        js.executeScript("window.scrollTo(0, document.body.scrollHeight);");

        // Wait for content to load
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {}
    }

    System.out.println("Total items loaded: " + currentCount);
}

// Usage
scrollUntilAllLoaded(By.cssSelector(".product-item"));

// 3. Wait for loading indicator
public void scrollWithLoadingIndicator(By loadingIndicator) {
    JavascriptExecutor js = (JavascriptExecutor) driver;
    WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));

    int scrollCount = 0;
    int maxScrolls = 50;

    while (scrollCount < maxScrolls) {
        // Scroll to bottom
        js.executeScript("window.scrollTo(0, document.body.scrollHeight);");

        try {
            // Wait for loading indicator to appear
            wait.until(ExpectedConditions.visibilityOfElementLocated(loadingIndicator));

            // Wait for loading indicator to disappear
            wait.until(ExpectedConditions.invisibilityOfElementLocated(loadingIndicator));
        } catch (TimeoutException e) {
            // No more content to load
            break;
        }

        scrollCount++;
    }
}

// Usage
scrollWithLoadingIndicator(By.cssSelector(".loading-spinner"));

// 4. Scroll specific number of times
public void scrollNTimes(int times, int pauseMillis) {
    JavascriptExecutor js = (JavascriptExecutor) driver;

    for (int i = 0; i < times; i++) {
        js.executeScript("window.scrollBy(0, 1000);");  // Scroll 1000px each time

        try {
            Thread.sleep(pauseMillis);
        } catch (InterruptedException e) {}
    }
}

// Usage
scrollNTimes(10, 1000);  // Scroll 10 times with 1 second pause

// 5. Scroll to last visible element
public void scrollToLastElement(By elementLocator) {
    JavascriptExecutor js = (JavascriptExecutor) driver;

    List<WebElement> elements = driver.findElements(elementLocator);
    if (!elements.isEmpty()) {
        WebElement lastElement = elements.get(elements.size() - 1);
        js.executeScript("arguments[0].scrollIntoView();", lastElement);
    }
}

// 6. Infinite scroll utility class
public class InfiniteScrollHelper {
    private WebDriver driver;
    private JavascriptExecutor js;
    private WebDriverWait wait;

    public InfiniteScrollHelper(WebDriver driver) {
        this.driver = driver;
        this.js = (JavascriptExecutor) driver;
        this.wait = new WebDriverWait(driver, Duration.ofSeconds(10));
    }

    public void scrollToBottom() {
        js.executeScript("window.scrollTo(0, document.body.scrollHeight);");
    }

    public void scrollByPixels(int pixels) {
        js.executeScript("window.scrollBy(0, " + pixels + ");");
    }

    public long getScrollHeight() {
        return (long) js.executeScript("return document.body.scrollHeight");
    }

    public void scrollUntilElementCount(By locator, int targetCount) {
        int currentCount = 0;
        int attempts = 0;

        while (currentCount < targetCount && attempts < 100) {
            scrollToBottom();

            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {}

            currentCount = driver.findElements(locator).size();
            attempts++;
        }
    }

    public List<WebElement> loadAllElements(By locator, int maxScrolls) {
        int previousCount = 0;
        int stableCount = 0;

        for (int i = 0; i < maxScrolls; i++) {
            int currentCount = driver.findElements(locator).size();

            if (currentCount == previousCount) {
                stableCount++;
                if (stableCount >= 3) {  // Stable for 3 iterations
                    break;
                }
            } else {
                stableCount = 0;
            }

            previousCount = currentCount;
            scrollToBottom();

            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {}
        }

        return driver.findElements(locator);
    }

    public void scrollWithLoadingCheck(By loadingIndicator, int maxWaitSeconds) {
        int scrolls = 0;

        while (scrolls < 50) {
            scrollToBottom();

            try {
                // Wait for loading indicator
                wait.until(ExpectedConditions.visibilityOfElementLocated(loadingIndicator));
                wait.until(ExpectedConditions.invisibilityOfElementLocated(loadingIndicator));
            } catch (TimeoutException e) {
                break;  // No more loading
            }

            scrolls++;
        }
    }
}

// Usage
InfiniteScrollHelper scrollHelper = new InfiniteScrollHelper(driver);

// Load all products
List<WebElement> products = scrollHelper.loadAllElements(
    By.cssSelector(".product-card"),
    50  // Max 50 scrolls
);

System.out.println("Loaded " + products.size() + " products");

// 7. Real-world example: Social media feed
public class FeedPage {
    private WebDriver driver;
    private InfiniteScrollHelper scrollHelper;

    private By postLocator = By.cssSelector(".feed-post");
    private By loadingSpinner = By.cssSelector(".loading");

    public FeedPage(WebDriver driver) {
        this.driver = driver;
        this.scrollHelper = new InfiniteScrollHelper(driver);
    }

    public List<String> getAllPostTexts() {
        // Load all posts
        List<WebElement> posts = scrollHelper.loadAllElements(postLocator, 30);

        // Extract text from all posts
        return posts.stream()
            .map(WebElement::getText)
            .collect(Collectors.toList());
    }

    public void scrollToPost(int index) {
        scrollHelper.scrollUntilElementCount(postLocator, index + 1);
        List<WebElement> posts = driver.findElements(postLocator);
        if (posts.size() > index) {
            posts.get(index).click();
        }
    }
}

// 8. Lazy loading images
public void waitForAllImagesToLoad() {
    JavascriptExecutor js = (JavascriptExecutor) driver;

    // Scroll to trigger lazy loading
    long lastHeight = (long) js.executeScript("return document.body.scrollHeight");

    while (true) {
        js.executeScript("window.scrollTo(0, document.body.scrollHeight);");

        // Wait for images to load
        new WebDriverWait(driver, Duration.ofSeconds(5)).until(driver -> {
            return (boolean) js.executeScript(
                "return Array.from(document.images).every(img => img.complete);"
            );
        });

        long newHeight = (long) js.executeScript("return document.body.scrollHeight");

        if (newHeight == lastHeight) {
            break;
        }
        lastHeight = newHeight;
    }
}

// 9. Detect end of scroll (JavaScript approach)
public boolean isScrollAtBottom() {
    JavascriptExecutor js = (JavascriptExecutor) driver;

    return (boolean) js.executeScript(
        "return (window.innerHeight + window.scrollY) >= document.body.scrollHeight;"
    );
}

// 10. Smooth scroll animation
public void smoothScrollToBottom() {
    JavascriptExecutor js = (JavascriptExecutor) driver;

    js.executeScript(
        "window.scrollTo({" +
        "  top: document.body.scrollHeight," +
        "  behavior: 'smooth'" +
        "});"
    );
}
```
**Follow-up**: How to determine when infinite scroll has ended? How to handle slow network during lazy loading? How to test performance with lazy loading? What if scroll height doesn't change?

---

### Q64: How to take screenshots in Selenium?
**Difficulty**: Basic | **Experience**: 0-2, 3-5, 6-8
**Companies**: All companies
**Answer**: Use TakesScreenshot interface. Three types: 1) **Full page screenshot**, 2) **Element screenshot**, 3) **Failed test screenshot**. Methods: getScreenshotAs(OutputType.FILE), getScreenshotAs(OutputType.BYTES), getScreenshotAs(OutputType.BASE64). Store in file using FileUtils.copyFile(). Best practice: Take screenshot on test failure for debugging. Selenium 4 supports element screenshots directly.
**Code**:
```java
// 1. Full page screenshot
TakesScreenshot ts = (TakesScreenshot) driver;
File source = ts.getScreenshotAs(OutputType.FILE);
File destination = new File("screenshot.png");
FileUtils.copyFile(source, destination);

// With timestamp
String timestamp = new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss").format(new Date());
File destination = new File("screenshot_" + timestamp + ".png");
FileUtils.copyFile(source, destination);

// 2. Element screenshot (Selenium 4+)
WebElement element = driver.findElement(By.id("logo"));
File source = element.getScreenshotAs(OutputType.FILE);
FileUtils.copyFile(source, new File("element_screenshot.png"));

// 3. Screenshot as Base64 (for embedding in reports)
String base64Screenshot = ts.getScreenshotAs(OutputType.BASE64);

// 4. Screenshot as bytes
byte[] screenshot = ts.getScreenshotAs(OutputType.BYTES);

// 5. Screenshot utility class
public class ScreenshotHelper {
    private WebDriver driver;
    private String screenshotDir;

    public ScreenshotHelper(WebDriver driver) {
        this.driver = driver;
        this.screenshotDir = System.getProperty("user.dir") + "/screenshots";
        createScreenshotDirectory();
    }

    private void createScreenshotDirectory() {
        File dir = new File(screenshotDir);
        if (!dir.exists()) {
            dir.mkdirs();
        }
    }

    public String takeScreenshot(String testName) {
        try {
            TakesScreenshot ts = (TakesScreenshot) driver;
            File source = ts.getScreenshotAs(OutputType.FILE);

            String timestamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
            String fileName = testName + "_" + timestamp + ".png";
            String filePath = screenshotDir + "/" + fileName;

            File destination = new File(filePath);
            FileUtils.copyFile(source, destination);

            return filePath;
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }

    public String takeElementScreenshot(WebElement element, String elementName) {
        try {
            File source = element.getScreenshotAs(OutputType.FILE);

            String timestamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
            String fileName = elementName + "_" + timestamp + ".png";
            String filePath = screenshotDir + "/" + fileName;

            File destination = new File(filePath);
            FileUtils.copyFile(source, destination);

            return filePath;
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }

    public String getBase64Screenshot() {
        TakesScreenshot ts = (TakesScreenshot) driver;
        return ts.getScreenshotAs(OutputType.BASE64);
    }

    public void clearOldScreenshots(int daysOld) {
        File folder = new File(screenshotDir);
        File[] files = folder.listFiles();

        if (files != null) {
            long cutoffTime = System.currentTimeMillis() - (daysOld * 24 * 60 * 60 * 1000L);

            for (File file : files) {
                if (file.lastModified() < cutoffTime) {
                    file.delete();
                }
            }
        }
    }
}

// Usage
ScreenshotHelper screenshotHelper = new ScreenshotHelper(driver);

// Take full page screenshot
String path = screenshotHelper.takeScreenshot("loginTest");

// Take element screenshot
WebElement logo = driver.findElement(By.id("logo"));
screenshotHelper.takeElementScreenshot(logo, "logo");

// 6. Take screenshot on test failure (TestNG)
public class BaseTest {
    protected WebDriver driver;
    protected ScreenshotHelper screenshotHelper;

    @BeforeMethod
    public void setup() {
        driver = new ChromeDriver();
        screenshotHelper = new ScreenshotHelper(driver);
    }

    @AfterMethod
    public void teardown(ITestResult result) {
        if (result.getStatus() == ITestResult.FAILURE) {
            String testName = result.getName();
            screenshotHelper.takeScreenshot(testName);
        }
        driver.quit();
    }
}

// 7. TestNG listener for screenshots
public class ScreenshotListener implements ITestListener {

    @Override
    public void onTestFailure(ITestResult result) {
        Object testClass = result.getInstance();
        WebDriver driver = ((BaseTest) testClass).driver;

        TakesScreenshot ts = (TakesScreenshot) driver;
        File source = ts.getScreenshotAs(OutputType.FILE);

        String testName = result.getName();
        String filePath = "screenshots/" + testName + ".png";

        try {
            FileUtils.copyFile(source, new File(filePath));
            System.out.println("Screenshot saved: " + filePath);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

// Add in testng.xml
/*
<listeners>
    <listener class-name="com.yourpackage.ScreenshotListener"/>
</listeners>
*/

// 8. Extent Reports with screenshot
@Test
public void loginTest() {
    ExtentTest test = extent.createTest("Login Test");

    try {
        // Test steps
        driver.get("https://example.com/login");
        driver.findElement(By.id("username")).sendKeys("user");
        driver.findElement(By.id("password")).sendKeys("pass");
        driver.findElement(By.id("submit")).click();

        test.pass("Login successful");
    } catch (Exception e) {
        // Take screenshot on failure
        String screenshotPath = screenshotHelper.takeScreenshot("loginTest");
        test.fail("Login failed")
            .addScreenCaptureFromPath(screenshotPath);
    }
}

// 9. Allure Reports with screenshot
@Attachment(value = "Screenshot", type = "image/png")
public byte[] takeScreenshot() {
    return ((TakesScreenshot) driver).getScreenshotAs(OutputType.BYTES);
}

@Test
public void test() {
    try {
        // Test steps
    } catch (Exception e) {
        takeScreenshot();  // Attaches to Allure report
        throw e;
    }
}

// 10. Full page screenshot (including below fold)
public void takeFullPageScreenshot(String filePath) throws IOException {
    // Get dimensions
    JavascriptExecutor js = (JavascriptExecutor) driver;
    int width = ((Long) js.executeScript("return document.body.scrollWidth")).intValue();
    int height = ((Long) js.executeScript("return document.body.scrollHeight")).intValue();

    // Set window size to full page
    driver.manage().window().setSize(new Dimension(width, height));

    // Take screenshot
    File screenshot = ((TakesScreenshot) driver).getScreenshotAs(OutputType.FILE);
    FileUtils.copyFile(screenshot, new File(filePath));
}

// 11. Screenshot comparison (for visual testing)
public boolean compareScreenshots(String expectedPath, String actualPath) throws IOException {
    BufferedImage expected = ImageIO.read(new File(expectedPath));
    BufferedImage actual = ImageIO.read(new File(actualPath));

    if (expected.getWidth() != actual.getWidth() ||
        expected.getHeight() != actual.getHeight()) {
        return false;
    }

    for (int y = 0; y < expected.getHeight(); y++) {
        for (int x = 0; x < expected.getWidth(); x++) {
            if (expected.getRGB(x, y) != actual.getRGB(x, y)) {
                return false;
            }
        }
    }

    return true;
}

// 12. Real-world Page Object with screenshot
public class LoginPage {
    private WebDriver driver;
    private ScreenshotHelper screenshotHelper;

    private By usernameField = By.id("username");
    private By passwordField = By.id("password");
    private By submitButton = By.id("submit");

    public LoginPage(WebDriver driver) {
        this.driver = driver;
        this.screenshotHelper = new ScreenshotHelper(driver);
    }

    public HomePage login(String username, String password) {
        try {
            driver.findElement(usernameField).sendKeys(username);
            driver.findElement(passwordField).sendKeys(password);

            // Screenshot before clicking submit
            screenshotHelper.takeScreenshot("beforeLogin");

            driver.findElement(submitButton).click();

            // Screenshot after login
            screenshotHelper.takeScreenshot("afterLogin");

            return new HomePage(driver);
        } catch (Exception e) {
            screenshotHelper.takeScreenshot("loginError");
            throw e;
        }
    }
}
```
**Follow-up**: How to take full page screenshot? How to integrate screenshots with test reports? How to compare screenshots? Can you take screenshot of specific element only?

---

### Q65: How to handle cookies in Selenium?
**Difficulty**: Basic | **Experience**: 0-2, 3-5, 6-8
**Companies**: All companies
**Answer**: Use driver.manage().getCookies(), addCookie(), deleteCookie(), deleteAllCookies(). Cookie class represents cookie with name, value, domain, path, expiry. Use cases: 1) Save login session, 2) Bypass login, 3) Test cookie functionality, 4) Clear cache between tests. Cookies persist until browser closes or deleted explicitly.
**Code**:
```java
// 1. Get all cookies
Set<Cookie> cookies = driver.manage().getCookies();
System.out.println("Total cookies: " + cookies.size());

for (Cookie cookie : cookies) {
    System.out.println("Name: " + cookie.getName());
    System.out.println("Value: " + cookie.getValue());
    System.out.println("Domain: " + cookie.getDomain());
    System.out.println("Path: " + cookie.getPath());
    System.out.println("Expiry: " + cookie.getExpiry());
    System.out.println("IsSecure: " + cookie.isSecure());
    System.out.println("IsHttpOnly: " + cookie.isHttpOnly());
    System.out.println("---");
}

// 2. Get specific cookie
Cookie sessionCookie = driver.manage().getCookieNamed("sessionId");
if (sessionCookie != null) {
    System.out.println("Session ID: " + sessionCookie.getValue());
}

// 3. Add cookie
Cookie cookie = new Cookie("username", "testuser");
driver.manage().addCookie(cookie);

// Add cookie with all parameters
Cookie detailedCookie = new Cookie.Builder("auth_token", "abc123")
    .domain("example.com")
    .path("/")
    .expiresOn(new Date(System.currentTimeMillis() + 86400000))  // 1 day
    .isSecure(true)
    .isHttpOnly(true)
    .build();
driver.manage().addCookie(detailedCookie);

// 4. Delete specific cookie
driver.manage().deleteCookieNamed("sessionId");

// Delete cookie object
Cookie cookieToDelete = driver.manage().getCookieNamed("username");
driver.manage().deleteCookie(cookieToDelete);

// 5. Delete all cookies
driver.manage().deleteAllCookies();

// 6. Save cookies to file
public void saveCookiesToFile(String filePath) throws IOException {
    Set<Cookie> cookies = driver.manage().getCookies();

    FileWriter fileWriter = new FileWriter(filePath);
    BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);

    for (Cookie cookie : cookies) {
        bufferedWriter.write(cookie.getName() + ";" +
                           cookie.getValue() + ";" +
                           cookie.getDomain() + ";" +
                           cookie.getPath() + ";" +
                           cookie.getExpiry() + ";" +
                           cookie.isSecure());
        bufferedWriter.newLine();
    }

    bufferedWriter.close();
    fileWriter.close();
}

// 7. Load cookies from file
public void loadCookiesFromFile(String filePath) throws IOException {
    File file = new File(filePath);
    FileReader fileReader = new FileReader(file);
    BufferedReader bufferedReader = new BufferedReader(fileReader);

    String line;
    while ((line = bufferedReader.readLine()) != null) {
        String[] cookieData = line.split(";");

        Cookie.Builder cookieBuilder = new Cookie.Builder(cookieData[0], cookieData[1])
            .domain(cookieData[2])
            .path(cookieData[3])
            .isSecure(Boolean.parseBoolean(cookieData[5]));

        if (!cookieData[4].equals("null")) {
            cookieBuilder.expiresOn(new Date(Long.parseLong(cookieData[4])));
        }

        driver.manage().addCookie(cookieBuilder.build());
    }

    bufferedReader.close();
    fileReader.close();
}

// 8. Cookie utility class
public class CookieHelper {
    private WebDriver driver;

    public CookieHelper(WebDriver driver) {
        this.driver = driver;
    }

    public void addCookie(String name, String value) {
        Cookie cookie = new Cookie(name, value);
        driver.manage().addCookie(cookie);
    }

    public String getCookieValue(String cookieName) {
        Cookie cookie = driver.manage().getCookieNamed(cookieName);
        return cookie != null ? cookie.getValue() : null;
    }

    public void deleteCookie(String cookieName) {
        driver.manage().deleteCookieNamed(cookieName);
    }

    public void deleteAllCookies() {
        driver.manage().deleteAllCookies();
    }

    public boolean isCookiePresent(String cookieName) {
        return driver.manage().getCookieNamed(cookieName) != null;
    }

    public void printAllCookies() {
        Set<Cookie> cookies = driver.manage().getCookies();
        System.out.println("Total cookies: " + cookies.size());

        for (Cookie cookie : cookies) {
            System.out.println(cookie.getName() + " = " + cookie.getValue());
        }
    }

    public void saveCookies(String filePath) {
        try {
            Set<Cookie> cookies = driver.manage().getCookies();
            ObjectOutputStream oos = new ObjectOutputStream(
                new FileOutputStream(filePath)
            );
            oos.writeObject(cookies);
            oos.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @SuppressWarnings("unchecked")
    public void loadCookies(String filePath) {
        try {
            ObjectInputStream ois = new ObjectInputStream(
                new FileInputStream(filePath)
            );
            Set<Cookie> cookies = (Set<Cookie>) ois.readObject();
            ois.close();

            for (Cookie cookie : cookies) {
                driver.manage().addCookie(cookie);
            }
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}

// Usage
CookieHelper cookieHelper = new CookieHelper(driver);

// Add cookie
cookieHelper.addCookie("user_pref", "dark_mode");

// Get cookie
String sessionId = cookieHelper.getCookieValue("JSESSIONID");

// Check if cookie exists
boolean hasAuth = cookieHelper.isCookiePresent("auth_token");

// Save cookies
cookieHelper.saveCookies("cookies.dat");

// 9. Real-world scenario: Bypass login using cookies
public class LoginBypassTest {
    private WebDriver driver;
    private CookieHelper cookieHelper;

    @Test
    public void saveLoginSession() {
        driver.get("https://example.com/login");

        // Perform login
        driver.findElement(By.id("username")).sendKeys("user");
        driver.findElement(By.id("password")).sendKeys("pass");
        driver.findElement(By.id("submit")).click();

        // Wait for login success
        new WebDriverWait(driver, Duration.ofSeconds(10))
            .until(ExpectedConditions.urlContains("dashboard"));

        // Save cookies
        cookieHelper.saveCookies("login_cookies.dat");
    }

    @Test(dependsOnMethods = "saveLoginSession")
    public void reuseLoginSession() {
        // Navigate to site first
        driver.get("https://example.com");

        // Load saved cookies
        cookieHelper.loadCookies("login_cookies.dat");

        // Refresh to apply cookies
        driver.navigate().refresh();

        // Now logged in without entering credentials
        // Verify logged in state
        Assert.assertTrue(driver.getCurrentUrl().contains("dashboard"));
    }
}

// 10. Test cookie acceptance banner
public void acceptCookies() {
    try {
        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(5));
        WebElement acceptButton = wait.until(
            ExpectedConditions.elementToBeClickable(By.id("accept-cookies"))
        );
        acceptButton.click();
    } catch (TimeoutException e) {
        // No cookie banner present
    }
}

// 11. Clear cache and cookies before test
@BeforeMethod
public void clearCacheAndCookies() {
    driver.manage().deleteAllCookies();

    // Clear local storage (JavaScript)
    JavascriptExecutor js = (JavascriptExecutor) driver;
    js.executeScript("localStorage.clear();");
    js.executeScript("sessionStorage.clear();");
}

// 12. Cookie-based feature flags
public boolean isFeatureEnabled(String featureName) {
    String featureFlags = cookieHelper.getCookieValue("feature_flags");
    return featureFlags != null && featureFlags.contains(featureName);
}
```
**Follow-up**: How to persist cookies across test runs? How to handle secure cookies? What's difference between cookie and local storage? How to test cookie consent banners?

---

### Q66: Explain ChromeOptions and FirefoxOptions
**Difficulty**: Medium | **Experience**: 3-5, 6-8, 9-12
**Companies**: Amazon, Google, Microsoft
**Answer**: ChromeOptions and FirefoxOptions configure browser-specific settings. Use cases: 1) **Headless mode**, 2) **Disable notifications**, 3) **Set download directory**, 4) **Add extensions**, 5) **Set user agent**, 6) **Disable images**, 7) **Incognito mode**, 8) **Accept insecure certificates**. Pass options to driver constructor: new ChromeDriver(options).
**Code**:
```java
// 1. ChromeOptions - Basic setup
ChromeOptions options = new ChromeOptions();
WebDriver driver = new ChromeDriver(options);

// 2. Headless mode (no browser UI)
options.addArguments("--headless=new");  // Selenium 4 syntax
options.addArguments("--disable-gpu");   // Windows
options.addArguments("--window-size=1920,1080");

// 3. Start maximized
options.addArguments("--start-maximized");

// 4. Disable notifications
options.addArguments("--disable-notifications");

// 5. Incognito/Private mode
options.addArguments("--incognito");

// 6. Disable extensions
options.addArguments("--disable-extensions");

// 7. Disable infobars
options.setExperimentalOption("excludeSwitches", Arrays.asList("enable-automation"));
options.setExperimentalOption("useAutomationExtension", false);

// 8. Set download directory
Map<String, Object> prefs = new HashMap<>();
prefs.put("download.default_directory", "/path/to/downloads");
prefs.put("download.prompt_for_download", false);
prefs.put("plugins.always_open_pdf_externally", true);
options.setExperimentalOption("prefs", prefs);

// 9. Accept insecure certificates
options.setAcceptInsecureCerts(true);

// 10. Add browser extension
options.addExtensions(new File("path/to/extension.crx"));

// 11. Set user agent
options.addArguments("user-agent=Mozilla/5.0 Custom Agent");

// 12. Disable images (faster loading)
Map<String, Object> prefs = new HashMap<>();
prefs.put("profile.managed_default_content_settings.images", 2);
options.setExperimentalOption("prefs", prefs);

// 13. Set page load strategy
options.setPageLoadStrategy(PageLoadStrategy.EAGER);  // Don't wait for images, stylesheets

// 14. Set proxy
Proxy proxy = new Proxy();
proxy.setHttpProxy("proxyserver:port");
proxy.setSslProxy("proxyserver:port");
options.setProxy(proxy);

// 15. Disable automation flags (avoid detection)
options.addArguments("--disable-blink-features=AutomationControlled");
options.setExperimentalOption("excludeSwitches", Arrays.asList("enable-automation"));

// 16. Set binary location (custom Chrome)
options.setBinary("/path/to/chrome/binary");

// 17. Comprehensive ChromeOptions example
ChromeOptions options = new ChromeOptions();
options.addArguments("--start-maximized");
options.addArguments("--disable-notifications");
options.addArguments("--disable-popup-blocking");
options.addArguments("--disable-infobars");
options.addArguments("--disable-extensions");

Map<String, Object> prefs = new HashMap<>();
prefs.put("credentials_enable_service", false);
prefs.put("profile.password_manager_enabled", false);
options.setExperimentalOption("prefs", prefs);

options.setExperimentalOption("excludeSwitches",
    Arrays.asList("enable-automation", "disable-popup-blocking"));

WebDriver driver = new ChromeDriver(options);

// 18. FirefoxOptions - Basic setup
FirefoxOptions firefoxOptions = new FirefoxOptions();
WebDriver driver = new FirefoxDriver(firefoxOptions);

// 19. Firefox headless
firefoxOptions.addArguments("--headless");
firefoxOptions.addArguments("--width=1920");
firefoxOptions.addArguments("--height=1080");

// 20. Firefox private browsing
firefoxOptions.addArguments("-private");

// 21. Firefox profile
FirefoxProfile profile = new FirefoxProfile();

// Disable notifications
profile.setPreference("dom.webnotifications.enabled", false);
profile.setPreference("dom.push.enabled", false);

// Set download directory
profile.setPreference("browser.download.folderList", 2);
profile.setPreference("browser.download.dir", "/path/to/downloads");
profile.setPreference("browser.helperApps.neverAsk.saveToDisk",
    "application/pdf,application/zip");

// Disable PDF viewer
profile.setPreference("pdfjs.disabled", true);

firefoxOptions.setProfile(profile);

// 22. Firefox accept insecure certs
firefoxOptions.setAcceptInsecureCerts(true);

// 23. Firefox set binary
firefoxOptions.setBinary("/path/to/firefox/binary");

// 24. Firefox logging
System.setProperty(FirefoxDriver.SystemProperty.BROWSER_LOGFILE, "/dev/null");

// 25. Options utility class
public class BrowserOptionsManager {

    public static ChromeOptions getChromeOptions(boolean headless) {
        ChromeOptions options = new ChromeOptions();

        if (headless) {
            options.addArguments("--headless=new");
            options.addArguments("--window-size=1920,1080");
        } else {
            options.addArguments("--start-maximized");
        }

        options.addArguments("--disable-notifications");
        options.addArguments("--disable-popup-blocking");
        options.addArguments("--disable-infobars");

        options.setExperimentalOption("excludeSwitches",
            Arrays.asList("enable-automation"));

        return options;
    }

    public static ChromeOptions getChromeOptionsWithDownload(String downloadPath) {
        ChromeOptions options = getChromeOptions(false);

        Map<String, Object> prefs = new HashMap<>();
        prefs.put("download.default_directory", downloadPath);
        prefs.put("download.prompt_for_download", false);
        prefs.put("plugins.always_open_pdf_externally", true);
        options.setExperimentalOption("prefs", prefs);

        return options;
    }

    public static FirefoxOptions getFirefoxOptions(boolean headless) {
        FirefoxOptions options = new FirefoxOptions();

        if (headless) {
            options.addArguments("--headless");
            options.addArguments("--width=1920");
            options.addArguments("--height=1080");
        }

        FirefoxProfile profile = new FirefoxProfile();
        profile.setPreference("dom.webnotifications.enabled", false);
        options.setProfile(profile);

        return options;
    }
}

// Usage
ChromeOptions options = BrowserOptionsManager.getChromeOptions(true);  // Headless
WebDriver driver = new ChromeDriver(options);

// 26. Real-world framework example
public class DriverFactory {

    public static WebDriver createDriver(String browser, boolean headless) {
        WebDriver driver;

        switch (browser.toLowerCase()) {
            case "chrome":
                ChromeOptions chromeOptions = new ChromeOptions();
                if (headless) {
                    chromeOptions.addArguments("--headless=new");
                    chromeOptions.addArguments("--window-size=1920,1080");
                }
                chromeOptions.addArguments("--disable-notifications");
                chromeOptions.addArguments("--start-maximized");
                driver = new ChromeDriver(chromeOptions);
                break;

            case "firefox":
                FirefoxOptions firefoxOptions = new FirefoxOptions();
                if (headless) {
                    firefoxOptions.addArguments("--headless");
                }
                driver = new FirefoxDriver(firefoxOptions);
                break;

            case "edge":
                EdgeOptions edgeOptions = new EdgeOptions();
                if (headless) {
                    edgeOptions.addArguments("--headless");
                }
                driver = new EdgeDriver(edgeOptions);
                break;

            default:
                throw new IllegalArgumentException("Browser not supported: " + browser);
        }

        driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));
        return driver;
    }
}

// Usage
WebDriver driver = DriverFactory.createDriver("chrome", true);

// 27. Mobile emulation (Chrome)
Map<String, String> mobileEmulation = new HashMap<>();
mobileEmulation.put("deviceName", "iPhone 12 Pro");
// OR custom dimensions
Map<String, Object> deviceMetrics = new HashMap<>();
deviceMetrics.put("width", 375);
deviceMetrics.put("height", 812);
deviceMetrics.put("pixelRatio", 3.0);
mobileEmulation.put("deviceMetrics", deviceMetrics);
mobileEmulation.put("userAgent", "Mozilla/5.0 iPhone...");

options.setExperimentalOption("mobileEmulation", mobileEmulation);
```
**Follow-up**: How to run tests in headless mode? How to set custom download location? How to disable images for faster execution? How to handle browser-specific options in framework?

---

### Q67. How do you create custom ExpectedConditions in Selenium? When would you need them?

**Difficulty**: Medium | **Experience**: 3-5, 6-8 years
**Companies**: Google, Amazon, Microsoft, Adobe, Flipkart, Paytm

**Answer**:
Custom ExpectedConditions are needed when standard conditions don't cover specific waiting scenarios in your application. They implement the `ExpectedCondition<T>` interface and provide a custom `apply()` method that returns the expected result when the condition is met, or null/false otherwise.

You create custom conditions when you need to wait for:
- Complex element states (e.g., element has specific attribute value)
- Multiple elements to reach certain conditions
- AJAX/API responses to complete
- Custom page readiness checks
- Dynamic content to be fully loaded
- Specific text patterns to appear
- Element count to reach a threshold

Custom conditions improve test reliability by eliminating hard-coded waits and providing meaningful wait logic. They make tests more maintainable and reusable across the framework.

**Code Examples**:

```java
// Custom ExpectedConditions Utility Class
package utils;

import org.openqa.selenium.*;
import org.openqa.selenium.support.ui.ExpectedCondition;
import java.util.List;

public class CustomExpectedConditions {

    /**
     * Wait for element to have specific attribute value
     */
    public static ExpectedCondition<Boolean> attributeContains(
            final WebElement element,
            final String attribute,
            final String value) {

        return new ExpectedCondition<Boolean>() {
            private String currentValue = null;

            @Override
            public Boolean apply(WebDriver driver) {
                try {
                    currentValue = element.getAttribute(attribute);
                    if (currentValue != null && currentValue.contains(value)) {
                        return true;
                    }
                    return false;
                } catch (StaleElementReferenceException e) {
                    return false;
                }
            }

            @Override
            public String toString() {
                return String.format(
                    "attribute '%s' to contain '%s'. Current value: '%s'",
                    attribute, value, currentValue
                );
            }
        };
    }

    /**
     * Wait for element count to be a specific number
     */
    public static ExpectedCondition<Boolean> numberOfElementsToBe(
            final By locator,
            final int expectedCount) {

        return new ExpectedCondition<Boolean>() {
            private int currentCount = 0;

            @Override
            public Boolean apply(WebDriver driver) {
                try {
                    List<WebElement> elements = driver.findElements(locator);
                    currentCount = elements.size();
                    return currentCount == expectedCount;
                } catch (Exception e) {
                    return false;
                }
            }

            @Override
            public String toString() {
                return String.format(
                    "number of elements located by %s to be %d. Current count: %d",
                    locator, expectedCount, currentCount
                );
            }
        };
    }

    /**
     * Wait for element count to be greater than
     */
    public static ExpectedCondition<Boolean> numberOfElementsToBeGreaterThan(
            final By locator,
            final int count) {

        return new ExpectedCondition<Boolean>() {
            private int currentCount = 0;

            @Override
            public Boolean apply(WebDriver driver) {
                try {
                    currentCount = driver.findElements(locator).size();
                    return currentCount > count;
                } catch (Exception e) {
                    return false;
                }
            }

            @Override
            public String toString() {
                return String.format(
                    "number of elements to be greater than %d. Current: %d",
                    count, currentCount
                );
            }
        };
    }

    /**
     * Wait for element to be visible and enabled
     */
    public static ExpectedCondition<WebElement> elementToBeVisibleAndEnabled(
            final By locator) {

        return new ExpectedCondition<WebElement>() {
            @Override
            public WebElement apply(WebDriver driver) {
                try {
                    WebElement element = driver.findElement(locator);
                    if (element.isDisplayed() && element.isEnabled()) {
                        return element;
                    }
                    return null;
                } catch (Exception e) {
                    return null;
                }
            }

            @Override
            public String toString() {
                return "element to be visible and enabled: " + locator;
            }
        };
    }

    /**
     * Wait for text to match regex pattern
     */
    public static ExpectedCondition<Boolean> textToMatchPattern(
            final WebElement element,
            final String pattern) {

        return new ExpectedCondition<Boolean>() {
            private String currentText = "";

            @Override
            public Boolean apply(WebDriver driver) {
                try {
                    currentText = element.getText();
                    return currentText.matches(pattern);
                } catch (StaleElementReferenceException e) {
                    return false;
                }
            }

            @Override
            public String toString() {
                return String.format(
                    "text to match pattern '%s'. Current text: '%s'",
                    pattern, currentText
                );
            }
        };
    }

    /**
     * Wait for any element from list to be clickable
     */
    public static ExpectedCondition<WebElement> anyElementToBeClickable(
            final List<By> locators) {

        return new ExpectedCondition<WebElement>() {
            @Override
            public WebElement apply(WebDriver driver) {
                for (By locator : locators) {
                    try {
                        List<WebElement> elements = driver.findElements(locator);
                        for (WebElement element : elements) {
                            if (element.isDisplayed() && element.isEnabled()) {
                                return element;
                            }
                        }
                    } catch (Exception e) {
                        continue;
                    }
                }
                return null;
            }

            @Override
            public String toString() {
                return "any element from list to be clickable";
            }
        };
    }

    /**
     * Wait for page to be fully loaded (document.readyState = complete)
     */
    public static ExpectedCondition<Boolean> pageLoadComplete() {
        return new ExpectedCondition<Boolean>() {
            @Override
            public Boolean apply(WebDriver driver) {
                try {
                    JavascriptExecutor js = (JavascriptExecutor) driver;
                    String readyState = js.executeScript(
                        "return document.readyState"
                    ).toString();
                    return readyState.equals("complete");
                } catch (Exception e) {
                    return false;
                }
            }

            @Override
            public String toString() {
                return "page load to be complete (document.readyState)";
            }
        };
    }

    /**
     * Wait for jQuery to be loaded and inactive
     */
    public static ExpectedCondition<Boolean> jQueryToBeInactive() {
        return new ExpectedCondition<Boolean>() {
            @Override
            public Boolean apply(WebDriver driver) {
                try {
                    JavascriptExecutor js = (JavascriptExecutor) driver;

                    // Check if jQuery is defined
                    Boolean jQueryDefined = (Boolean) js.executeScript(
                        "return typeof jQuery != 'undefined'"
                    );

                    if (!jQueryDefined) {
                        return true; // jQuery not used, consider complete
                    }

                    // Check if jQuery.active is 0 (no active requests)
                    Long active = (Long) js.executeScript(
                        "return jQuery.active"
                    );

                    return active == 0;
                } catch (Exception e) {
                    return false;
                }
            }

            @Override
            public String toString() {
                return "jQuery to be inactive (jQuery.active == 0)";
            }
        };
    }

    /**
     * Wait for Angular to finish loading
     */
    public static ExpectedCondition<Boolean> angularToBeReady() {
        return new ExpectedCondition<Boolean>() {
            @Override
            public Boolean apply(WebDriver driver) {
                try {
                    JavascriptExecutor js = (JavascriptExecutor) driver;

                    // Check if Angular is defined
                    Boolean angularDefined = (Boolean) js.executeScript(
                        "return typeof angular != 'undefined'"
                    );

                    if (!angularDefined) {
                        return true;
                    }

                    // Check if no pending HTTP requests
                    Boolean ready = (Boolean) js.executeScript(
                        "return angular.element(document).injector()" +
                        ".get('$http').pendingRequests.length === 0"
                    );

                    return ready;
                } catch (Exception e) {
                    return false;
                }
            }

            @Override
            public String toString() {
                return "Angular to be ready (no pending HTTP requests)";
            }
        };
    }

    /**
     * Wait for element to stop moving (for animations)
     */
    public static ExpectedCondition<Boolean> elementToStopMoving(
            final WebElement element) {

        return new ExpectedCondition<Boolean>() {
            private Point previousLocation = null;

            @Override
            public Boolean apply(WebDriver driver) {
                try {
                    Point currentLocation = element.getLocation();

                    if (previousLocation == null) {
                        previousLocation = currentLocation;
                        return false;
                    }

                    if (previousLocation.equals(currentLocation)) {
                        return true;
                    }

                    previousLocation = currentLocation;
                    return false;

                } catch (StaleElementReferenceException e) {
                    return false;
                }
            }

            @Override
            public String toString() {
                return "element to stop moving (position stable)";
            }
        };
    }
}
```

**Usage in Page Object**:

```java
package pages;

import org.openqa.selenium.*;
import org.openqa.selenium.support.ui.WebDriverWait;
import utils.CustomExpectedConditions;
import java.time.Duration;

public class DynamicContentPage {
    private WebDriver driver;
    private WebDriverWait wait;

    // Locators
    private By loadingSpinner = By.cssSelector(".spinner");
    private By contentItems = By.cssSelector(".content-item");
    private By statusBadge = By.id("status-badge");
    private By submitButton = By.id("submit-btn");

    public DynamicContentPage(WebDriver driver) {
        this.driver = driver;
        this.wait = new WebDriverWait(driver, Duration.ofSeconds(30));
    }

    /**
     * Wait for content items to reach expected count
     */
    public void waitForContentItemsCount(int expectedCount) {
        wait.until(
            CustomExpectedConditions.numberOfElementsToBe(
                contentItems,
                expectedCount
            )
        );
    }

    /**
     * Wait for status badge to show specific status
     */
    public void waitForStatusBadge(String expectedStatus) {
        WebElement badge = driver.findElement(statusBadge);
        wait.until(
            CustomExpectedConditions.attributeContains(
                badge,
                "data-status",
                expectedStatus
            )
        );
    }

    /**
     * Wait for page to be fully ready (all conditions)
     */
    public void waitForPageReady() {
        // Wait for page load
        wait.until(CustomExpectedConditions.pageLoadComplete());

        // Wait for jQuery to be inactive
        wait.until(CustomExpectedConditions.jQueryToBeInactive());

        // Wait for loading spinner to disappear
        wait.until(ExpectedConditions.invisibilityOfElementLocated(loadingSpinner));
    }

    /**
     * Wait for submit button to be clickable (visible + enabled)
     */
    public void waitForSubmitButtonReady() {
        wait.until(
            CustomExpectedConditions.elementToBeVisibleAndEnabled(submitButton)
        );
    }

    /**
     * Wait for success message with specific pattern
     */
    public void waitForSuccessMessagePattern() {
        WebElement message = driver.findElement(By.id("message"));

        // Wait for message to match pattern: "Success: ID-12345"
        wait.until(
            CustomExpectedConditions.textToMatchPattern(
                message,
                "Success: ID-\\d+"
            )
        );
    }

    /**
     * Wait for at least N items to load
     */
    public void waitForMinimumItems(int minCount) {
        wait.until(
            CustomExpectedConditions.numberOfElementsToBeGreaterThan(
                contentItems,
                minCount
            )
        );
    }
}
```

**Test Class with Custom Conditions**:

```java
package tests;

import org.testng.annotations.*;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import pages.DynamicContentPage;

public class CustomConditionsTest {
    private WebDriver driver;
    private DynamicContentPage contentPage;

    @BeforeMethod
    public void setup() {
        driver = new ChromeDriver();
        driver.get("https://example.com/dynamic-content");
        contentPage = new DynamicContentPage(driver);
    }

    @Test
    public void testDynamicContentLoading() {
        // Wait for page to be completely ready
        contentPage.waitForPageReady();

        // Trigger dynamic content load
        driver.findElement(By.id("load-more")).click();

        // Wait for exactly 10 items to load
        contentPage.waitForContentItemsCount(10);

        // Verify content loaded
        Assert.assertEquals(
            driver.findElements(By.cssSelector(".content-item")).size(),
            10
        );
    }

    @Test
    public void testStatusUpdate() {
        // Submit form
        driver.findElement(By.id("submit-btn")).click();

        // Wait for status to change to "processing"
        contentPage.waitForStatusBadge("processing");

        // Wait for status to change to "complete"
        contentPage.waitForStatusBadge("complete");

        // Verify success message pattern
        contentPage.waitForSuccessMessagePattern();
    }

    @AfterMethod
    public void teardown() {
        if (driver != null) {
            driver.quit();
        }
    }
}
```

**Advanced: Fluent Custom Condition**:

```java
public class FluentCustomCondition {

    /**
     * Builder pattern for complex custom conditions
     */
    public static class ElementStateBuilder {
        private WebElement element;
        private boolean checkVisible = false;
        private boolean checkEnabled = false;
        private boolean checkSelected = false;
        private String attributeName = null;
        private String attributeValue = null;

        public ElementStateBuilder(WebElement element) {
            this.element = element;
        }

        public ElementStateBuilder isVisible() {
            this.checkVisible = true;
            return this;
        }

        public ElementStateBuilder isEnabled() {
            this.checkEnabled = true;
            return this;
        }

        public ElementStateBuilder isSelected() {
            this.checkSelected = true;
            return this;
        }

        public ElementStateBuilder hasAttribute(String name, String value) {
            this.attributeName = name;
            this.attributeValue = value;
            return this;
        }

        public ExpectedCondition<Boolean> build() {
            return new ExpectedCondition<Boolean>() {
                @Override
                public Boolean apply(WebDriver driver) {
                    try {
                        if (checkVisible && !element.isDisplayed()) {
                            return false;
                        }

                        if (checkEnabled && !element.isEnabled()) {
                            return false;
                        }

                        if (checkSelected && !element.isSelected()) {
                            return false;
                        }

                        if (attributeName != null) {
                            String actual = element.getAttribute(attributeName);
                            if (!attributeValue.equals(actual)) {
                                return false;
                            }
                        }

                        return true;

                    } catch (StaleElementReferenceException e) {
                        return false;
                    }
                }

                @Override
                public String toString() {
                    return "element to meet all specified conditions";
                }
            };
        }
    }

    // Usage:
    // wait.until(
    //     new FluentCustomCondition.ElementStateBuilder(element)
    //         .isVisible()
    //         .isEnabled()
    //         .hasAttribute("data-status", "ready")
    //         .build()
    // );
}
```

**Follow-up**: How do you handle timeouts with custom conditions? How to debug failing custom conditions? How to make custom conditions reusable across framework? What's the performance impact of complex custom conditions?

---

### Q68. What strategies do you use to handle flaky tests in Selenium? Explain retry mechanisms.

**Difficulty**: Hard | **Experience**: 6-8, 9-12 years
**Companies**: Google, Amazon, Microsoft, Netflix, Uber, Adobe

**Answer**:
Flaky tests are tests that intermittently fail without code changes. Handling them requires multiple strategies:

1. **Root Cause Analysis**: Identify why tests are flaky (timing issues, environment, test data, element states)
2. **Proper Waits**: Replace Thread.sleep() with explicit/custom waits
3. **Element State Verification**: Check visibility, clickability, staleness
4. **Retry Mechanisms**: Implement retry logic at different levels
5. **Test Isolation**: Ensure tests don't depend on each other
6. **Stable Test Data**: Use unique test data for each run
7. **Synchronization**: Wait for page/AJAX/animations to complete
8. **Error Handling**: Graceful handling of exceptions
9. **Logging**: Detailed logs to identify failure patterns

Retry mechanisms should be used as a last resort after fixing root causes. They can be implemented at element, method, test, or suite level using TestNG RetryAnalyzer, custom annotations, or framework-level handlers.

**Code Examples**:

```java
// 1. TestNG Retry Analyzer
package listeners;

import org.testng.IRetryAnalyzer;
import org.testng.ITestResult;

public class RetryAnalyzer implements IRetryAnalyzer {
    private int retryCount = 0;
    private static final int MAX_RETRY_COUNT = 3;

    @Override
    public boolean retry(ITestResult result) {
        if (retryCount < MAX_RETRY_COUNT) {
            System.out.println(
                "Retrying test: " + result.getName() +
                " | Attempt: " + (retryCount + 1)
            );
            retryCount++;
            return true;
        }
        return false;
    }
}
```

```java
// 2. Enhanced Retry Analyzer with Specific Exceptions
package listeners;

import org.testng.IRetryAnalyzer;
import org.testng.ITestResult;
import org.openqa.selenium.*;
import java.util.Arrays;
import java.util.List;

public class SmartRetryAnalyzer implements IRetryAnalyzer {
    private int retryCount = 0;
    private static final int MAX_RETRY_COUNT = 3;

    // Only retry for specific exceptions
    private static final List<Class<? extends Throwable>> RETRYABLE_EXCEPTIONS =
        Arrays.asList(
            StaleElementReferenceException.class,
            NoSuchElementException.class,
            TimeoutException.class,
            ElementClickInterceptedException.class,
            WebDriverException.class
        );

    @Override
    public boolean retry(ITestResult result) {
        if (retryCount < MAX_RETRY_COUNT) {
            Throwable throwable = result.getThrowable();

            if (throwable != null && isRetryable(throwable)) {
                System.out.println(
                    "Retrying test: " + result.getName() +
                    " | Exception: " + throwable.getClass().getSimpleName() +
                    " | Attempt: " + (retryCount + 1)
                );
                retryCount++;

                // Reset test status
                result.setStatus(ITestResult.FAILURE);

                return true;
            }
        }
        return false;
    }

    private boolean isRetryable(Throwable throwable) {
        for (Class<? extends Throwable> retryableException : RETRYABLE_EXCEPTIONS) {
            if (retryableException.isInstance(throwable)) {
                return true;
            }
        }
        return false;
    }
}
```

```java
// 3. Retry Listener to Apply Retry Analyzer to All Tests
package listeners;

import org.testng.IAnnotationTransformer;
import org.testng.annotations.ITestAnnotation;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;

public class RetryListener implements IAnnotationTransformer {

    @Override
    public void transform(
            ITestAnnotation annotation,
            Class testClass,
            Constructor testConstructor,
            Method testMethod) {

        // Apply retry analyzer to all tests
        annotation.setRetryAnalyzer(SmartRetryAnalyzer.class);
    }
}
```

```java
// 4. Element-Level Retry Utility
package utils;

import org.openqa.selenium.*;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.WebDriverWait;
import java.time.Duration;
import java.util.function.Function;

public class RetryHelper {
    private WebDriver driver;
    private int maxRetries;
    private Duration retryInterval;

    public RetryHelper(WebDriver driver, int maxRetries, Duration retryInterval) {
        this.driver = driver;
        this.maxRetries = maxRetries;
        this.retryInterval = retryInterval;
    }

    /**
     * Retry clicking an element
     */
    public void retryClick(By locator) {
        int attempts = 0;
        while (attempts < maxRetries) {
            try {
                WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
                WebElement element = wait.until(
                    ExpectedConditions.elementToBeClickable(locator)
                );
                element.click();
                return; // Success

            } catch (StaleElementReferenceException |
                     ElementClickInterceptedException e) {
                attempts++;
                System.out.println(
                    "Click failed, attempt " + attempts + "/" + maxRetries +
                    " | Exception: " + e.getClass().getSimpleName()
                );

                if (attempts >= maxRetries) {
                    throw new RuntimeException(
                        "Failed to click element after " + maxRetries + " attempts",
                        e
                    );
                }

                sleep(retryInterval.toMillis());
            }
        }
    }

    /**
     * Retry sending keys
     */
    public void retrySendKeys(By locator, String text) {
        int attempts = 0;
        while (attempts < maxRetries) {
            try {
                WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
                WebElement element = wait.until(
                    ExpectedConditions.visibilityOfElementLocated(locator)
                );
                element.clear();
                element.sendKeys(text);
                return;

            } catch (StaleElementReferenceException e) {
                attempts++;
                if (attempts >= maxRetries) {
                    throw new RuntimeException(
                        "Failed to send keys after " + maxRetries + " attempts",
                        e
                    );
                }
                sleep(retryInterval.toMillis());
            }
        }
    }

    /**
     * Generic retry mechanism for any action
     */
    public <T> T retryAction(Function<WebDriver, T> action, String actionName) {
        int attempts = 0;
        Exception lastException = null;

        while (attempts < maxRetries) {
            try {
                return action.apply(driver);

            } catch (StaleElementReferenceException |
                     NoSuchElementException |
                     TimeoutException e) {
                lastException = e;
                attempts++;

                System.out.println(
                    actionName + " failed, attempt " + attempts + "/" + maxRetries +
                    " | Exception: " + e.getClass().getSimpleName()
                );

                if (attempts < maxRetries) {
                    sleep(retryInterval.toMillis());
                }
            }
        }

        throw new RuntimeException(
            actionName + " failed after " + maxRetries + " attempts",
            lastException
        );
    }

    /**
     * Retry finding element
     */
    public WebElement retryFindElement(By locator) {
        return retryAction(
            driver -> {
                WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
                return wait.until(ExpectedConditions.presenceOfElementLocated(locator));
            },
            "Find element: " + locator
        );
    }

    private void sleep(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

```java
// 5. Page Object with Retry Mechanism
package pages;

import org.openqa.selenium.*;
import org.openqa.selenium.support.ui.WebDriverWait;
import utils.RetryHelper;
import java.time.Duration;

public class LoginPage {
    private WebDriver driver;
    private RetryHelper retryHelper;

    // Locators
    private By usernameField = By.id("username");
    private By passwordField = By.id("password");
    private By loginButton = By.id("login-btn");
    private By errorMessage = By.cssSelector(".error-message");

    public LoginPage(WebDriver driver) {
        this.driver = driver;
        this.retryHelper = new RetryHelper(driver, 3, Duration.ofSeconds(1));
    }

    public void enterUsername(String username) {
        retryHelper.retrySendKeys(usernameField, username);
    }

    public void enterPassword(String password) {
        retryHelper.retrySendKeys(passwordField, password);
    }

    public void clickLogin() {
        retryHelper.retryClick(loginButton);
    }

    public String getErrorMessage() {
        return retryHelper.retryAction(
            driver -> driver.findElement(errorMessage).getText(),
            "Get error message"
        );
    }

    public void login(String username, String password) {
        enterUsername(username);
        enterPassword(password);
        clickLogin();
    }
}
```

```java
// 6. Flaky Test Prevention Strategies
package utils;

import org.openqa.selenium.*;
import org.openqa.selenium.support.ui.*;
import java.time.Duration;

public class StabilityHelper {
    private WebDriver driver;
    private WebDriverWait wait;

    public StabilityHelper(WebDriver driver) {
        this.driver = driver;
        this.wait = new WebDriverWait(driver, Duration.ofSeconds(30));
    }

    /**
     * Wait for element to be stable (not moving)
     */
    public void waitForElementStability(WebElement element) {
        Point previousLocation = null;
        Dimension previousSize = null;
        int stableChecks = 0;
        int requiredStableChecks = 3;

        while (stableChecks < requiredStableChecks) {
            try {
                Point currentLocation = element.getLocation();
                Dimension currentSize = element.getSize();

                if (previousLocation != null && previousSize != null) {
                    if (currentLocation.equals(previousLocation) &&
                        currentSize.equals(previousSize)) {
                        stableChecks++;
                    } else {
                        stableChecks = 0; // Reset if changed
                    }
                }

                previousLocation = currentLocation;
                previousSize = currentSize;

                Thread.sleep(100); // Small delay between checks

            } catch (InterruptedException | StaleElementReferenceException e) {
                stableChecks = 0; // Reset on exception
            }
        }
    }

    /**
     * Safe click with multiple fallback strategies
     */
    public void safeClick(By locator) {
        try {
            // Strategy 1: Regular click
            WebElement element = wait.until(
                ExpectedConditions.elementToBeClickable(locator)
            );
            element.click();

        } catch (ElementClickInterceptedException e) {
            try {
                // Strategy 2: JavaScript click
                WebElement element = driver.findElement(locator);
                ((JavascriptExecutor) driver).executeScript(
                    "arguments[0].click();", element
                );

            } catch (Exception ex) {
                // Strategy 3: Actions class click
                WebElement element = driver.findElement(locator);
                new Actions(driver)
                    .moveToElement(element)
                    .click()
                    .perform();
            }
        }
    }

    /**
     * Wait for all AJAX calls to complete
     */
    public void waitForAjaxComplete() {
        wait.until((ExpectedCondition<Boolean>) driver -> {
            JavascriptExecutor js = (JavascriptExecutor) driver;

            // Check jQuery active requests
            Boolean jQueryReady = (Boolean) js.executeScript(
                "return typeof jQuery == 'undefined' || jQuery.active == 0"
            );

            // Check document ready state
            Boolean docReady = js.executeScript(
                "return document.readyState"
            ).equals("complete");

            return jQueryReady && docReady;
        });
    }

    /**
     * Wait for page to be completely loaded
     */
    public void waitForPageLoad() {
        wait.until((ExpectedCondition<Boolean>) driver -> {
            JavascriptExecutor js = (JavascriptExecutor) driver;
            return js.executeScript("return document.readyState").equals("complete");
        });
    }
}
```

```java
// 7. testng.xml Configuration
/*
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE suite SYSTEM "http://testng.org/testng-1.0.dtd">
<suite name="Test Suite with Retry">
    <listeners>
        <listener class-name="listeners.RetryListener"/>
    </listeners>

    <test name="Login Tests">
        <classes>
            <class name="tests.LoginTest"/>
        </classes>
    </test>
</suite>
*/
```

```java
// 8. Test with Retry Annotation (Alternative Approach)
package tests;

import org.testng.annotations.*;
import listeners.SmartRetryAnalyzer;

public class FlakySafeTest {

    @Test(retryAnalyzer = SmartRetryAnalyzer.class)
    public void testLogin() {
        // Test code here
        // Will automatically retry up to 3 times on failure
    }

    @Test // Will also retry because of RetryListener
    public void testCheckout() {
        // Test code here
    }
}
```

**Follow-up**: When should you use retries vs fixing the root cause? How to identify flaky test patterns? How to report retry metrics? What's the impact of retries on CI/CD pipeline time?

---

### Q69. Explain WebDriver Event Listeners. How do you implement custom event handling?

**Difficulty**: Medium | **Experience**: 4-7, 6-8 years
**Companies**: Amazon, Microsoft, Adobe, Salesforce, Flipkart

**Answer**:
WebDriver Event Listeners allow you to intercept and handle WebDriver events (clicks, navigation, element finding, exceptions, etc.) before and after they occur. They implement the `WebDriverListener` interface (Selenium 4) or `WebDriverEventListener` (Selenium 3).

Use cases for event listeners:
- Logging all WebDriver actions for debugging
- Taking screenshots on failures
- Highlighting elements before interaction
- Custom error handling and recovery
- Performance monitoring (action duration)
- Test execution tracking
- Automatic retry on specific exceptions
- Video recording triggers

Event listeners make your framework more maintainable and provide better observability without modifying test code.

**Code Examples**:

```java
// 1. Custom Event Listener (Selenium 4)
package listeners;

import org.openqa.selenium.*;
import org.openqa.selenium.support.events.WebDriverListener;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class CustomWebDriverListener implements WebDriverListener {
    private static final Logger logger = LogManager.getLogger(CustomWebDriverListener.class);

    // Before navigation
    @Override
    public void beforeGet(WebDriver driver, String url) {
        logger.info("Navigating to URL: " + url);
    }

    // After navigation
    @Override
    public void afterGet(WebDriver driver, String url) {
        logger.info("Successfully navigated to: " + url);
    }

    // Before finding element
    @Override
    public void beforeFindElement(WebDriver driver, By locator) {
        logger.info("Attempting to find element: " + locator);
    }

    // After finding element
    @Override
    public void afterFindElement(WebDriver driver, By locator, WebElement result) {
        logger.info("Successfully found element: " + locator);
        highlightElement(driver, result);
    }

    // Before click
    @Override
    public void beforeClick(WebElement element) {
        logger.info("Clicking on element: " + getElementDescription(element));
    }

    // After click
    @Override
    public void afterClick(WebElement element) {
        logger.info("Successfully clicked element");
    }

    // Before sending keys
    @Override
    public void beforeSendKeys(WebElement element, CharSequence... keysToSend) {
        logger.info("Sending keys to element: " + getElementDescription(element) +
                   " | Keys: " + maskSensitiveData(keysToSend));
    }

    // After sending keys
    @Override
    public void afterSendKeys(WebElement element, CharSequence... keysToSend) {
        logger.info("Successfully sent keys to element");
    }

    // On exception
    @Override
    public void onError(Object target, Method method, Object[] args, InvocationTargetException e) {
        logger.error("Exception occurred: " + e.getTargetException().getMessage());

        if (target instanceof WebDriver) {
            takeScreenshot((WebDriver) target);
        }
    }

    // Before quit
    @Override
    public void beforeQuit(WebDriver driver) {
        logger.info("Closing browser session");
    }

    // Helper method to highlight element
    private void highlightElement(WebDriver driver, WebElement element) {
        try {
            JavascriptExecutor js = (JavascriptExecutor) driver;
            String originalStyle = element.getAttribute("style");

            // Highlight with border
            js.executeScript(
                "arguments[0].setAttribute('style', arguments[1]);",
                element,
                "border: 3px solid red; background: yellow;"
            );

            Thread.sleep(200); // Brief highlight

            // Restore original style
            js.executeScript(
                "arguments[0].setAttribute('style', arguments[1]);",
                element,
                originalStyle == null ? "" : originalStyle
            );

        } catch (Exception e) {
            logger.warn("Could not highlight element: " + e.getMessage());
        }
    }

    // Helper method to get element description
    private String getElementDescription(WebElement element) {
        try {
            String tag = element.getTagName();
            String id = element.getAttribute("id");
            String name = element.getAttribute("name");
            String className = element.getAttribute("class");

            StringBuilder desc = new StringBuilder("<" + tag);
            if (id != null && !id.isEmpty()) desc.append(" id='" + id + "'");
            if (name != null && !name.isEmpty()) desc.append(" name='" + name + "'");
            if (className != null && !className.isEmpty())
                desc.append(" class='" + className + "'");
            desc.append(">");

            return desc.toString();

        } catch (Exception e) {
            return "unknown element";
        }
    }

    // Helper method to mask sensitive data
    private String maskSensitiveData(CharSequence... keysToSend) {
        String keys = String.join("", keysToSend);

        // Mask if looks like password (heuristic)
        if (keys.length() > 6 && !keys.contains("@")) {
            return "****" + keys.substring(keys.length() - 2);
        }

        return keys;
    }

    // Helper method to take screenshot
    private void takeScreenshot(WebDriver driver) {
        try {
            TakesScreenshot ts = (TakesScreenshot) driver;
            byte[] screenshot = ts.getScreenshotAs(OutputType.BYTES);
            // Save screenshot logic here
            logger.info("Screenshot captured on error");
        } catch (Exception e) {
            logger.warn("Could not capture screenshot: " + e.getMessage());
        }
    }
}
```

```java
// 2. Advanced Event Listener with Performance Tracking
package listeners;

import org.openqa.selenium.*;
import org.openqa.selenium.support.events.WebDriverListener;
import java.lang.reflect.Method;
import java.time.Duration;
import java.time.Instant;
import java.util.concurrent.ConcurrentHashMap;

public class PerformanceTrackingListener implements WebDriverListener {

    private ThreadLocal<Instant> startTime = new ThreadLocal<>();
    private ConcurrentHashMap<String, Long> performanceMetrics = new ConcurrentHashMap<>();

    @Override
    public void beforeGet(WebDriver driver, String url) {
        startTime.set(Instant.now());
    }

    @Override
    public void afterGet(WebDriver driver, String url) {
        long duration = Duration.between(startTime.get(), Instant.now()).toMillis();
        performanceMetrics.put("Navigation_" + url, duration);
        System.out.println("Page load time for " + url + ": " + duration + "ms");
    }

    @Override
    public void beforeClick(WebElement element) {
        startTime.set(Instant.now());
    }

    @Override
    public void afterClick(WebElement element) {
        long duration = Duration.between(startTime.get(), Instant.now()).toMillis();
        performanceMetrics.put("Click_" + getElementId(element), duration);

        if (duration > 1000) {
            System.out.println("âš ï¸ Slow click detected: " + duration + "ms");
        }
    }

    @Override
    public void beforeFindElement(WebDriver driver, By locator) {
        startTime.set(Instant.now());
    }

    @Override
    public void afterFindElement(WebDriver driver, By locator, WebElement result) {
        long duration = Duration.between(startTime.get(), Instant.now()).toMillis();
        performanceMetrics.put("FindElement_" + locator, duration);

        if (duration > 2000) {
            System.out.println("âš ï¸ Slow element lookup: " + locator + " (" + duration + "ms)");
        }
    }

    public void printPerformanceReport() {
        System.out.println("\n=== Performance Report ===");
        performanceMetrics.forEach((action, duration) -> {
            System.out.println(action + ": " + duration + "ms");
        });

        long avgDuration = (long) performanceMetrics.values().stream()
            .mapToLong(Long::longValue)
            .average()
            .orElse(0.0);
        System.out.println("Average action time: " + avgDuration + "ms");
    }

    private String getElementId(WebElement element) {
        try {
            String id = element.getAttribute("id");
            return id != null && !id.isEmpty() ? id : "unknown";
        } catch (Exception e) {
            return "unknown";
        }
    }
}
```

```java
// 3. Event Listener with Screenshot on Failure
package listeners;

import org.openqa.selenium.*;
import org.openqa.selenium.support.events.WebDriverListener;
import org.apache.commons.io.FileUtils;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.text.SimpleDateFormat;
import java.util.Date;

public class ScreenshotOnFailureListener implements WebDriverListener {

    private String screenshotDir = "target/screenshots";

    public ScreenshotOnFailureListener() {
        new File(screenshotDir).mkdirs();
    }

    @Override
    public void onError(Object target, Method method, Object[] args,
                       InvocationTargetException e) {

        System.err.println("Error occurred: " + e.getTargetException().getMessage());

        // Take screenshot if target is WebDriver
        if (target instanceof WebDriver) {
            WebDriver driver = (WebDriver) target;
            takeScreenshot(driver, method.getName());
        }

        // Take screenshot if target is WebElement (get driver from element)
        if (target instanceof WebElement) {
            WebElement element = (WebElement) target;
            WebDriver driver = ((WrapsDriver) element).getWrappedDriver();
            takeScreenshot(driver, method.getName());
        }
    }

    private void takeScreenshot(WebDriver driver, String methodName) {
        try {
            TakesScreenshot ts = (TakesScreenshot) driver;
            File source = ts.getScreenshotAs(OutputType.FILE);

            String timestamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
            String fileName = "Error_" + methodName + "_" + timestamp + ".png";
            File destination = new File(screenshotDir + "/" + fileName);

            FileUtils.copyFile(source, destination);

            System.out.println("Screenshot saved: " + destination.getAbsolutePath());

        } catch (IOException ex) {
            System.err.println("Failed to capture screenshot: " + ex.getMessage());
        }
    }
}
```

```java
// 4. Driver Factory with Event Listener Registration
package factory;

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.support.events.EventFiringDecorator;
import listeners.*;

public class DriverFactory {

    private static ThreadLocal<WebDriver> driver = new ThreadLocal<>();

    public static WebDriver getDriver() {
        if (driver.get() == null) {
            WebDriver originalDriver = new ChromeDriver();

            // Create event firing driver with multiple listeners
            WebDriver decoratedDriver = new EventFiringDecorator(
                new CustomWebDriverListener(),
                new PerformanceTrackingListener(),
                new ScreenshotOnFailureListener()
            ).decorate(originalDriver);

            driver.set(decoratedDriver);
        }
        return driver.get();
    }

    public static void quitDriver() {
        if (driver.get() != null) {
            driver.get().quit();
            driver.remove();
        }
    }
}
```

```java
// 5. Combined Multi-Purpose Listener
package listeners;

import org.openqa.selenium.*;
import org.openqa.selenium.support.events.WebDriverListener;
import io.qameta.allure.Allure;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import java.io.ByteArrayInputStream;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class AllureEventListener implements WebDriverListener {

    private static final Logger logger = LogManager.getLogger(AllureEventListener.class);

    @Override
    public void beforeGet(WebDriver driver, String url) {
        Allure.step("Navigate to: " + url);
        logger.info("Navigating to: " + url);
    }

    @Override
    public void beforeClick(WebElement element) {
        String elementDesc = getElementDescription(element);
        Allure.step("Click on: " + elementDesc);
        logger.info("Clicking: " + elementDesc);

        // Attach screenshot before click
        attachScreenshot(((WrapsDriver) element).getWrappedDriver(), "Before Click");
    }

    @Override
    public void beforeSendKeys(WebElement element, CharSequence... keysToSend) {
        String elementDesc = getElementDescription(element);
        Allure.step("Enter text in: " + elementDesc);
        logger.info("Sending keys to: " + elementDesc);
    }

    @Override
    public void onError(Object target, Method method, Object[] args,
                       InvocationTargetException e) {

        String errorMsg = e.getTargetException().getMessage();
        Allure.step("âŒ Error: " + errorMsg);
        logger.error("Error occurred: " + errorMsg);

        // Attach screenshot on error
        if (target instanceof WebDriver) {
            attachScreenshot((WebDriver) target, "Error Screenshot");
        }
    }

    private void attachScreenshot(WebDriver driver, String name) {
        try {
            byte[] screenshot = ((TakesScreenshot) driver).getScreenshotAs(OutputType.BYTES);
            Allure.addAttachment(
                name,
                "image/png",
                new ByteArrayInputStream(screenshot),
                "png"
            );
        } catch (Exception e) {
            logger.warn("Could not attach screenshot: " + e.getMessage());
        }
    }

    private String getElementDescription(WebElement element) {
        try {
            return String.format(
                "<%s id='%s' name='%s'>",
                element.getTagName(),
                element.getAttribute("id"),
                element.getAttribute("name")
            );
        } catch (Exception e) {
            return "unknown element";
        }
    }
}
```

```java
// 6. Usage in Test Class
package tests;

import org.testng.annotations.*;
import org.openqa.selenium.WebDriver;
import factory.DriverFactory;
import pages.LoginPage;

public class EventListenerTest {
    private WebDriver driver;
    private LoginPage loginPage;

    @BeforeMethod
    public void setup() {
        // Driver with event listeners already registered
        driver = DriverFactory.getDriver();
        driver.get("https://example.com/login");
        loginPage = new LoginPage(driver);
    }

    @Test
    public void testLogin() {
        // All actions will be logged and tracked by listeners
        loginPage.enterUsername("testuser");
        loginPage.enterPassword("password123");
        loginPage.clickLogin();

        // Listeners will:
        // - Log all actions
        // - Highlight elements
        // - Track performance
        // - Take screenshots on errors
    }

    @AfterMethod
    public void teardown() {
        DriverFactory.quitDriver();
    }
}
```

**Follow-up**: How do event listeners impact test performance? How to register multiple listeners? How to conditionally enable/disable listeners? How to use listeners with Selenium Grid?

---

### Q70. How do you implement parallel execution in Selenium? Explain ThreadLocal for WebDriver.

**Difficulty**: Hard | **Experience**: 6-8, 9-12 years
**Companies**: Google, Amazon, Microsoft, Netflix, Uber, Flipkart

**Answer**:
Parallel execution runs multiple tests simultaneously to reduce overall execution time. In Selenium, this requires:

1. **Thread-Safe WebDriver Management**: Each thread must have its own WebDriver instance using ThreadLocal
2. **TestNG Parallel Configuration**: Configure parallel execution at suite, test, class, or method level
3. **Selenium Grid**: Distribute tests across multiple machines/browsers
4. **Synchronization**: Handle shared resources (test data, reports) safely
5. **Independent Tests**: Tests must not depend on each other

**ThreadLocal** creates thread-confined variables - each thread accessing the variable gets its own independent copy. This prevents WebDriver instances from being shared across threads, which would cause conflicts.

Without ThreadLocal, all threads would share one WebDriver instance, leading to unpredictable behavior (clicking wrong elements, navigation issues, etc.).

**Code Examples**:

```java
// 1. Thread-Safe WebDriver Manager using ThreadLocal
package factory;

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.firefox.FirefoxDriver;
import org.openqa.selenium.edge.EdgeDriver;
import org.openqa.selenium.chrome.ChromeOptions;

public class DriverManager {

    // ThreadLocal to maintain separate WebDriver instance per thread
    private static ThreadLocal<WebDriver> driver = new ThreadLocal<>();

    /**
     * Get WebDriver instance for current thread
     */
    public static WebDriver getDriver() {
        return driver.get();
    }

    /**
     * Create and set WebDriver instance for current thread
     */
    public static void setDriver(String browserName) {
        WebDriver webDriver = null;

        switch (browserName.toLowerCase()) {
            case "chrome":
                ChromeOptions chromeOptions = new ChromeOptions();
                chromeOptions.addArguments("--start-maximized");
                chromeOptions.addArguments("--disable-notifications");
                webDriver = new ChromeDriver(chromeOptions);
                break;

            case "firefox":
                webDriver = new FirefoxDriver();
                break;

            case "edge":
                webDriver = new EdgeDriver();
                break;

            default:
                throw new IllegalArgumentException("Browser not supported: " + browserName);
        }

        driver.set(webDriver);

        System.out.println(
            "WebDriver initialized for thread: " + Thread.currentThread().getId() +
            " | Browser: " + browserName
        );
    }

    /**
     * Quit WebDriver and remove from ThreadLocal
     */
    public static void quitDriver() {
        if (driver.get() != null) {
            System.out.println(
                "Quitting WebDriver for thread: " + Thread.currentThread().getId()
            );

            driver.get().quit();
            driver.remove(); // Important: Remove to prevent memory leaks
        }
    }
}
```

```java
// 2. Base Test Class with Thread-Safe Setup
package tests;

import org.testng.annotations.*;
import org.openqa.selenium.WebDriver;
import factory.DriverManager;

public class BaseTest {

    protected WebDriver driver;

    @BeforeMethod
    @Parameters("browser")
    public void setup(@Optional("chrome") String browser) {
        // Each thread gets its own WebDriver instance
        DriverManager.setDriver(browser);
        driver = DriverManager.getDriver();

        System.out.println(
            "Test started on thread: " + Thread.currentThread().getId() +
            " | Test: " + this.getClass().getSimpleName()
        );
    }

    @AfterMethod
    public void teardown() {
        System.out.println(
            "Test completed on thread: " + Thread.currentThread().getId()
        );

        DriverManager.quitDriver();
    }
}
```

```java
// 3. Test Classes
package tests;

import org.testng.annotations.Test;
import pages.LoginPage;

public class LoginTest extends BaseTest {

    @Test(priority = 1)
    public void testValidLogin() {
        driver.get("https://example.com/login");
        LoginPage loginPage = new LoginPage(driver);

        loginPage.login("validuser", "password");

        // Assertions
        System.out.println("Login test executed on thread: " +
                         Thread.currentThread().getId());
    }

    @Test(priority = 2)
    public void testInvalidLogin() {
        driver.get("https://example.com/login");
        LoginPage loginPage = new LoginPage(driver);

        loginPage.login("invaliduser", "wrong");

        // Assertions
        System.out.println("Invalid login test executed on thread: " +
                         Thread.currentThread().getId());
    }
}
```

```java
package tests;

import org.testng.annotations.Test;
import pages.CheckoutPage;

public class CheckoutTest extends BaseTest {

    @Test
    public void testCheckoutProcess() {
        driver.get("https://example.com/checkout");
        CheckoutPage checkoutPage = new CheckoutPage(driver);

        checkoutPage.completeCheckout();

        System.out.println("Checkout test executed on thread: " +
                         Thread.currentThread().getId());
    }
}
```

```java
// 4. testng.xml - Parallel Configuration
/*
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE suite SYSTEM "http://testng.org/testng-1.0.dtd">

<!-- Parallel Execution at METHOD Level -->
<suite name="Parallel Test Suite" parallel="methods" thread-count="3">

    <parameter name="browser" value="chrome"/>

    <test name="Regression Tests">
        <classes>
            <class name="tests.LoginTest"/>
            <class name="tests.CheckoutTest"/>
        </classes>
    </test>
</suite>

<!--
Parallel Options:
- parallel="methods" : Each @Test method runs in separate thread
- parallel="classes" : Each test class runs in separate thread
- parallel="tests"   : Each <test> tag runs in separate thread
- parallel="instances" : Each instance of test class runs in separate thread

thread-count: Number of threads to use (adjust based on resources)
-->
*/
```

```java
// 5. Cross-Browser Parallel Execution
/*
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE suite SYSTEM "http://testng.org/testng-1.0.dtd">

<suite name="Cross-Browser Suite" parallel="tests" thread-count="3">

    <test name="Chrome Tests">
        <parameter name="browser" value="chrome"/>
        <classes>
            <class name="tests.LoginTest"/>
        </classes>
    </test>

    <test name="Firefox Tests">
        <parameter name="browser" value="firefox"/>
        <classes>
            <class name="tests.LoginTest"/>
        </classes>
    </test>

    <test name="Edge Tests">
        <parameter name="browser" value="edge"/>
        <classes>
            <class name="tests.LoginTest"/>
        </classes>
    </test>
</suite>
*/
```

```java
// 6. Enhanced DriverManager with Selenium Grid Support
package factory;

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.remote.RemoteWebDriver;
import org.openqa.selenium.remote.DesiredCapabilities;
import org.openqa.selenium.chrome.ChromeOptions;
import org.openqa.selenium.firefox.FirefoxOptions;
import java.net.URL;
import java.net.MalformedURLException;

public class GridDriverManager {

    private static ThreadLocal<WebDriver> driver = new ThreadLocal<>();
    private static final String GRID_URL = "http://localhost:4444/wd/hub";

    public static WebDriver getDriver() {
        return driver.get();
    }

    /**
     * Create WebDriver for Selenium Grid
     */
    public static void setGridDriver(String browserName) throws MalformedURLException {
        WebDriver webDriver = null;

        DesiredCapabilities capabilities = new DesiredCapabilities();

        switch (browserName.toLowerCase()) {
            case "chrome":
                ChromeOptions chromeOptions = new ChromeOptions();
                chromeOptions.addArguments("--start-maximized");
                capabilities.merge(chromeOptions);
                break;

            case "firefox":
                FirefoxOptions firefoxOptions = new FirefoxOptions();
                capabilities.merge(firefoxOptions);
                break;
        }

        webDriver = new RemoteWebDriver(new URL(GRID_URL), capabilities);
        driver.set(webDriver);

        System.out.println(
            "Grid WebDriver initialized | Thread: " + Thread.currentThread().getId() +
            " | Browser: " + browserName +
            " | Session: " + ((RemoteWebDriver) webDriver).getSessionId()
        );
    }

    public static void quitDriver() {
        if (driver.get() != null) {
            System.out.println(
                "Quitting Grid WebDriver | Thread: " + Thread.currentThread().getId()
            );
            driver.get().quit();
            driver.remove();
        }
    }
}
```

```java
// 7. Thread-Safe Extent Report Manager
package reports;

import com.aventstack.extentreports.ExtentReports;
import com.aventstack.extentreports.ExtentTest;
import com.aventstack.extentreports.reporter.ExtentSparkReporter;

public class ExtentManager {

    private static ExtentReports extent;
    private static ThreadLocal<ExtentTest> test = new ThreadLocal<>();

    /**
     * Initialize Extent Reports (synchronized for thread safety)
     */
    public synchronized static ExtentReports getInstance() {
        if (extent == null) {
            ExtentSparkReporter htmlReporter = new ExtentSparkReporter(
                "target/extent-reports/report.html"
            );
            extent = new ExtentReports();
            extent.attachReporter(htmlReporter);
        }
        return extent;
    }

    /**
     * Create test for current thread
     */
    public static void startTest(String testName) {
        ExtentTest extentTest = getInstance().createTest(testName);
        test.set(extentTest);

        System.out.println(
            "Started test: " + testName +
            " | Thread: " + Thread.currentThread().getId()
        );
    }

    /**
     * Get test for current thread
     */
    public static ExtentTest getTest() {
        return test.get();
    }

    /**
     * End test for current thread
     */
    public static void endTest() {
        test.remove();
    }

    /**
     * Flush reports (call at suite end)
     */
    public synchronized static void flush() {
        if (extent != null) {
            extent.flush();
        }
    }
}
```

```java
// 8. Test with Thread-Safe Reporting
package tests;

import org.testng.annotations.*;
import com.aventstack.extentreports.ExtentTest;
import reports.ExtentManager;

public class ReportingTest extends BaseTest {

    @BeforeMethod
    public void setupReport() {
        ExtentManager.startTest(
            this.getClass().getSimpleName() + " - " +
            Thread.currentThread().getId()
        );
    }

    @Test
    public void testWithReporting() {
        ExtentTest test = ExtentManager.getTest();

        test.info("Step 1: Navigate to application");
        driver.get("https://example.com");

        test.info("Step 2: Perform login");
        // Test steps...

        test.pass("Test completed successfully");

        System.out.println("Test thread: " + Thread.currentThread().getId());
    }

    @AfterMethod
    public void endReport() {
        ExtentManager.endTest();
    }

    @AfterSuite
    public void flushReports() {
        ExtentManager.flush();
    }
}
```

```java
// 9. Docker Compose for Selenium Grid (docker-compose.yml)
/*
version: '3'
services:
  selenium-hub:
    image: selenium/hub:latest
    container_name: selenium-hub
    ports:
      - "4444:4444"
      - "4442:4442"
      - "4443:4443"

  chrome:
    image: selenium/node-chrome:latest
    depends_on:
      - selenium-hub
    environment:
      - SE_EVENT_BUS_HOST=selenium-hub
      - SE_EVENT_BUS_PUBLISH_PORT=4442
      - SE_EVENT_BUS_SUBSCRIBE_PORT=4443
      - SE_NODE_MAX_SESSIONS=3
    volumes:
      - /dev/shm:/dev/shm
    deploy:
      replicas: 2

  firefox:
    image: selenium/node-firefox:latest
    depends_on:
      - selenium-hub
    environment:
      - SE_EVENT_BUS_HOST=selenium-hub
      - SE_EVENT_BUS_PUBLISH_PORT=4442
      - SE_EVENT_BUS_SUBSCRIBE_PORT=4443
      - SE_NODE_MAX_SESSIONS=3
    volumes:
      - /dev/shm:/dev/shm
    deploy:
      replicas: 2

# Start: docker-compose up -d
# Stop: docker-compose down
# Access Grid UI: http://localhost:4444
*/
```

**Follow-up**: What are challenges with parallel execution? How to handle shared test data? How to optimize thread count? How to debug parallel test failures?

---

### Q71. Explain Selenium Grid architecture. How do you set up and configure a Grid?

**Difficulty**: Hard | **Experience**: 6-8, 9-12 years
**Companies**: Google, Amazon, Microsoft, Netflix, Uber, Adobe

**Answer**:
Selenium Grid is a smart proxy server that allows running tests on different machines against different browsers in parallel. It consists of a Hub and multiple Nodes in a hub-node architecture.

**Components**:
1. **Hub**: Central point that receives test requests and routes them to appropriate nodes
2. **Nodes**: Individual machines/containers that execute tests on specific browsers
3. **Sessions**: Test execution instances managed by the hub

**Use Cases**:
- Run tests in parallel across multiple browsers/OS
- Reduce execution time by distributing tests
- Execute tests on remote machines
- Test on browsers/OS not available locally
- Scale test execution horizontally

Selenium Grid 4 introduced several improvements: standalone mode, fully distributed mode, toml configuration, observability features, and native Docker support.

**Code Examples**:

```java
// 1. Starting Selenium Grid 4 - Different Modes

// Mode 1: Standalone (Single node with all browsers)
/*
java -jar selenium-server-4.x.x.jar standalone
Access: http://localhost:4444
*/

// Mode 2: Hub-Node (Classic Grid)
/*
# Start Hub
java -jar selenium-server-4.x.x.jar hub

# Start Chrome Node
java -jar selenium-server-4.x.x.jar node --detect-drivers true

# Start Firefox Node with specific config
java -jar selenium-server-4.x.x.jar node \
  --detect-drivers true \
  --max-sessions 5 \
  --hub http://localhost:4444
*/

// Mode 3: Fully Distributed (Separate components)
/*
# Router
java -jar selenium-server-4.x.x.jar router --port 4444

# Distributor
java -jar selenium-server-4.x.x.jar distributor \
  --port 5553 \
  --bind-host false

# Session Map
java -jar selenium-server-4.x.x.jar sessions \
  --port 5556

# Session Queue
java -jar selenium-server-4.x.x.jar sessionqueue \
  --port 5559

# Node
java -jar selenium-server-4.x.x.jar node \
  --port 5555
*/
```

```java
// 2. Grid Configuration File (config.toml)
/*
[network]
relax-checks = true

[node]
detect-drivers = false
max-sessions = 5

[[node.driver-configuration]]
name = "chrome"
max-sessions = 3
stereotype = '''
{
  "browserName": "chrome",
  "browserVersion": "120",
  "platformName": "Linux",
  "goog:chromeOptions": {
    "args": ["--no-sandbox", "--disable-dev-shm-usage"]
  }
}
'''

[[node.driver-configuration]]
name = "firefox"
max-sessions = 2
stereotype = '''
{
  "browserName": "firefox",
  "browserVersion": "120",
  "platformName": "Linux",
  "moz:firefoxOptions": {
    "args": ["-headless"]
  }
}
'''

# Start with config:
# java -jar selenium-server-4.x.x.jar node --config config.toml
*/
```

```java
// 3. Docker-based Selenium Grid (docker-compose.yml)
/*
version: '3.8'
services:
  selenium-hub:
    image: selenium/hub:4.15.0
    container_name: selenium-hub
    ports:
      - "4444:4444"
      - "4442:4442"  # Event bus publish port
      - "4443:4443"  # Event bus subscribe port
    environment:
      - GRID_MAX_SESSION=10
      - GRID_TIMEOUT=300
      - GRID_BROWSER_TIMEOUT=300
    healthcheck:
      test: ["CMD", "/opt/bin/check-grid.sh", "--host", "0.0.0.0", "--port", "4444"]
      interval: 15s
      timeout: 30s
      retries: 5

  chrome-node:
    image: selenium/node-chrome:4.15.0
    depends_on:
      - selenium-hub
    environment:
      - SE_EVENT_BUS_HOST=selenium-hub
      - SE_EVENT_BUS_PUBLISH_PORT=4442
      - SE_EVENT_BUS_SUBSCRIBE_PORT=4443
      - SE_NODE_MAX_SESSIONS=5
      - SE_NODE_SESSION_TIMEOUT=300
    volumes:
      - /dev/shm:/dev/shm  # Shared memory for Chrome
    deploy:
      replicas: 2  # 2 Chrome nodes
    shm_size: '2gb'

  firefox-node:
    image: selenium/node-firefox:4.15.0
    depends_on:
      - selenium-hub
    environment:
      - SE_EVENT_BUS_HOST=selenium-hub
      - SE_EVENT_BUS_PUBLISH_PORT=4442
      - SE_EVENT_BUS_SUBSCRIBE_PORT=4443
      - SE_NODE_MAX_SESSIONS=5
      - SE_NODE_SESSION_TIMEOUT=300
    volumes:
      - /dev/shm:/dev/shm
    deploy:
      replicas: 2  # 2 Firefox nodes
    shm_size: '2gb'

  edge-node:
    image: selenium/node-edge:4.15.0
    depends_on:
      - selenium-hub
    environment:
      - SE_EVENT_BUS_HOST=selenium-hub
      - SE_EVENT_BUS_PUBLISH_PORT=4442
      - SE_EVENT_BUS_SUBSCRIBE_PORT=4443
      - SE_NODE_MAX_SESSIONS=3
    volumes:
      - /dev/shm:/dev/shm
    shm_size: '2gb'

# Commands:
# Start: docker-compose up -d
# Scale: docker-compose up -d --scale chrome-node=5
# Stop: docker-compose down
# View Grid: http://localhost:4444
*/
```

```java
// 4. RemoteWebDriver Configuration
package factory;

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.remote.RemoteWebDriver;
import org.openqa.selenium.remote.DesiredCapabilities;
import org.openqa.selenium.chrome.ChromeOptions;
import org.openqa.selenium.firefox.FirefoxOptions;
import org.openqa.selenium.edge.EdgeOptions;
import java.net.URL;
import java.net.MalformedURLException;

public class GridDriverFactory {

    private static final String GRID_HUB_URL = "http://localhost:4444";
    private static ThreadLocal<WebDriver> driver = new ThreadLocal<>();

    public static WebDriver createDriver(String browserName) throws MalformedURLException {
        WebDriver remoteDriver = null;

        switch (browserName.toLowerCase()) {
            case "chrome":
                ChromeOptions chromeOptions = new ChromeOptions();
                chromeOptions.addArguments("--start-maximized");
                chromeOptions.addArguments("--disable-notifications");
                chromeOptions.addArguments("--disable-popup-blocking");
                chromeOptions.setCapability("browserVersion", "120");
                chromeOptions.setCapability("platformName", "Linux");

                remoteDriver = new RemoteWebDriver(
                    new URL(GRID_HUB_URL),
                    chromeOptions
                );
                break;

            case "firefox":
                FirefoxOptions firefoxOptions = new FirefoxOptions();
                firefoxOptions.addArguments("--width=1920");
                firefoxOptions.addArguments("--height=1080");
                firefoxOptions.setCapability("browserVersion", "120");
                firefoxOptions.setCapability("platformName", "Linux");

                remoteDriver = new RemoteWebDriver(
                    new URL(GRID_HUB_URL),
                    firefoxOptions
                );
                break;

            case "edge":
                EdgeOptions edgeOptions = new EdgeOptions();
                edgeOptions.addArguments("--start-maximized");
                edgeOptions.setCapability("browserVersion", "120");
                edgeOptions.setCapability("platformName", "Windows 10");

                remoteDriver = new RemoteWebDriver(
                    new URL(GRID_HUB_URL),
                    edgeOptions
                );
                break;

            default:
                throw new IllegalArgumentException("Browser not supported: " + browserName);
        }

        driver.set(remoteDriver);

        System.out.println(
            "Grid Session Created: " +
            " Browser: " + browserName +
            " | Session ID: " + ((RemoteWebDriver) remoteDriver).getSessionId() +
            " | Thread: " + Thread.currentThread().getId()
        );

        return remoteDriver;
    }

    public static WebDriver getDriver() {
        return driver.get();
    }

    public static void quitDriver() {
        if (driver.get() != null) {
            RemoteWebDriver remoteDriver = (RemoteWebDriver) driver.get();
            System.out.println(
                "Closing Grid Session: " + remoteDriver.getSessionId()
            );
            remoteDriver.quit();
            driver.remove();
        }
    }
}
```

```java
// 5. Grid Health Check and Session Management
package utils;

import org.openqa.selenium.remote.RemoteWebDriver;
import io.restassured.RestAssured;
import io.restassured.response.Response;
import org.json.JSONObject;
import org.json.JSONArray;

public class GridHealthChecker {

    private String gridUrl;

    public GridHealthChecker(String gridUrl) {
        this.gridUrl = gridUrl;
    }

    /**
     * Check if Grid Hub is ready
     */
    public boolean isGridReady() {
        try {
            Response response = RestAssured
                .given()
                .get(gridUrl + "/status");

            return response.getStatusCode() == 200 &&
                   response.jsonPath().getBoolean("value.ready");
        } catch (Exception e) {
            return false;
        }
    }

    /**
     * Get Grid node details
     */
    public void printGridStatus() {
        try {
            Response response = RestAssured
                .given()
                .get(gridUrl + "/status");

            JSONObject status = new JSONObject(response.asString());
            JSONObject value = status.getJSONObject("value");

            System.out.println("=== Grid Status ===");
            System.out.println("Ready: " + value.getBoolean("ready"));
            System.out.println("Message: " + value.getString("message"));

            JSONArray nodes = value.getJSONArray("nodes");
            System.out.println("Total Nodes: " + nodes.length());

            for (int i = 0; i < nodes.length(); i++) {
                JSONObject node = nodes.getJSONObject(i);
                System.out.println("\nNode " + (i + 1) + ":");
                System.out.println("  ID: " + node.getString("id"));
                System.out.println("  URI: " + node.getString("uri"));
                System.out.println("  Max Sessions: " + node.getInt("maxSessions"));
                System.out.println("  Available: " + node.getJSONObject("availability"));
            }

        } catch (Exception e) {
            System.err.println("Failed to get grid status: " + e.getMessage());
        }
    }

    /**
     * Get active sessions count
     */
    public int getActiveSessionsCount() {
        try {
            Response response = RestAssured
                .given()
                .get(gridUrl + "/status");

            JSONObject status = new JSONObject(response.asString());
            JSONArray nodes = status.getJSONObject("value").getJSONArray("nodes");

            int totalActive = 0;
            for (int i = 0; i < nodes.length(); i++) {
                totalActive += nodes.getJSONObject(i)
                                   .getJSONArray("slots")
                                   .length();
            }

            return totalActive;

        } catch (Exception e) {
            return -1;
        }
    }

    /**
     * Kill a specific session
     */
    public void killSession(String sessionId) {
        try {
            RestAssured
                .given()
                .delete(gridUrl + "/session/" + sessionId);

            System.out.println("Session killed: " + sessionId);

        } catch (Exception e) {
            System.err.println("Failed to kill session: " + e.getMessage());
        }
    }
}
```

```java
// 6. BaseTest with Grid Integration
package tests;

import org.testng.annotations.*;
import org.openqa.selenium.WebDriver;
import factory.GridDriverFactory;
import utils.GridHealthChecker;

public class GridBaseTest {

    protected WebDriver driver;
    private GridHealthChecker gridChecker;

    @BeforeSuite
    public void checkGridHealth() {
        gridChecker = new GridHealthChecker("http://localhost:4444");

        if (!gridChecker.isGridReady()) {
            throw new RuntimeException("Selenium Grid is not ready!");
        }

        System.out.println("âœ… Grid is ready for testing");
        gridChecker.printGridStatus();
    }

    @BeforeMethod
    @Parameters({"browser"})
    public void setup(@Optional("chrome") String browser) throws Exception {
        driver = GridDriverFactory.createDriver(browser);
    }

    @AfterMethod
    public void teardown() {
        GridDriverFactory.quitDriver();
    }

    @AfterSuite
    public void printFinalStats() {
        int activeSessions = gridChecker.getActiveSessionsCount();
        System.out.println("Active sessions at end: " + activeSessions);
    }
}
```

```java
// 7. Cross-Browser TestNG Suite (testng-grid.xml)
/*
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE suite SYSTEM "http://testng.org/testng-1.0.dtd">
<suite name="Cross-Browser Grid Suite" parallel="tests" thread-count="3">

    <test name="Chrome Tests">
        <parameter name="browser" value="chrome"/>
        <classes>
            <class name="tests.LoginTest"/>
            <class name="tests.CheckoutTest"/>
        </classes>
    </test>

    <test name="Firefox Tests">
        <parameter name="browser" value="firefox"/>
        <classes>
            <class name="tests.LoginTest"/>
            <class name="tests.CheckoutTest"/>
        </classes>
    </test>

    <test name="Edge Tests">
        <parameter name="browser" value="edge"/>
        <classes>
            <class name="tests.LoginTest"/>
        </classes>
    </test>
</suite>
*/
```

```java
// 8. Dynamic Grid Scaling Script (Kubernetes)
/*
apiVersion: apps/v1
kind: Deployment
metadata:
  name: selenium-hub
spec:
  replicas: 1
  selector:
    matchLabels:
      app: selenium-hub
  template:
    metadata:
      labels:
        app: selenium-hub
    spec:
      containers:
      - name: selenium-hub
        image: selenium/hub:4.15.0
        ports:
        - containerPort: 4444
        env:
        - name: GRID_MAX_SESSION
          value: "100"
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: selenium-node-chrome
spec:
  replicas: 3  # Scale as needed
  selector:
    matchLabels:
      app: selenium-node-chrome
  template:
    metadata:
      labels:
        app: selenium-node-chrome
    spec:
      containers:
      - name: selenium-node-chrome
        image: selenium/node-chrome:4.15.0
        env:
        - name: SE_EVENT_BUS_HOST
          value: "selenium-hub"
        - name: SE_EVENT_BUS_PUBLISH_PORT
          value: "4442"
        - name: SE_EVENT_BUS_SUBSCRIBE_PORT
          value: "4443"
        resources:
          limits:
            memory: "2Gi"
            cpu: "1000m"
          requests:
            memory: "1Gi"
            cpu: "500m"
*/
```

**Follow-up**: How does Grid 4 differ from Grid 3? How to handle node failures? How to monitor Grid health in CI/CD? What are Grid performance tuning best practices?

---

### Q72. How do you run Selenium tests in Docker containers? Explain the approach.

**Difficulty**: Hard | **Experience**: 6-8, 9-12 years
**Companies**: Google, Amazon, Microsoft, Netflix, Uber, Flipkart

**Answer**:
Running Selenium tests in Docker containers provides isolation, consistency, scalability, and easy CI/CD integration. Docker containers package the test environment including browser drivers, dependencies, and test code, ensuring tests run identically across different environments.

**Benefits**:
1. **Environment Consistency**: Same environment everywhere (dev, CI, prod)
2. **Isolation**: Tests don't interfere with host system
3. **Scalability**: Easy to scale with container orchestration
4. **Version Control**: Pin specific browser versions
5. **Parallel Execution**: Run multiple containers simultaneously
6. **CI/CD Integration**: Seamless integration with pipelines
7. **Resource Efficiency**: Better resource utilization

**Approaches**:
- Use official Selenium Docker images
- Create custom Dockerfiles for test execution
- Use Docker Compose for Grid setup
- Integrate with Kubernetes for large-scale execution

**Code Examples**:

```dockerfile
# 1. Dockerfile for Maven-based Selenium Tests
FROM maven:3.8-openjdk-11

# Set working directory
WORKDIR /app

# Copy pom.xml and download dependencies (layer caching)
COPY pom.xml .
RUN mvn dependency:go-offline -B

# Copy source code
COPY src ./src

# Copy test resources
COPY testng.xml .

# Set environment variables
ENV GRID_URL=http://selenium-hub:4444
ENV BROWSER=chrome

# Run tests
CMD ["mvn", "clean", "test", "-DsuiteXmlFile=testng.xml"]

# Usage:
# Build: docker build -t selenium-tests .
# Run: docker run --network=selenium-grid selenium-tests
```

```dockerfile
# 2. Multi-stage Dockerfile (Optimized)
# Stage 1: Build
FROM maven:3.8-openjdk-11 AS build
WORKDIR /app
COPY pom.xml .
RUN mvn dependency:go-offline -B
COPY src ./src
RUN mvn clean package -DskipTests

# Stage 2: Runtime
FROM adoptopenjdk:11-jre-hotspot
WORKDIR /app

# Copy only compiled artifacts
COPY --from=build /app/target/test-classes ./test-classes
COPY --from=build /app/target/classes ./classes
COPY --from=build /app/target/dependency ./dependency

# Copy test resources
COPY testng.xml .
COPY src/test/resources ./resources

# Environment variables
ENV GRID_URL=http://selenium-hub:4444
ENV BROWSER=chrome
ENV ENVIRONMENT=qa

# Run tests with Java
CMD ["java", "-cp", "classes:test-classes:dependency/*", \
     "org.testng.TestNG", "testng.xml"]
```

```yaml
# 3. Complete Docker Compose Setup
version: '3.8'

services:
  # Selenium Grid Hub
  selenium-hub:
    image: selenium/hub:4.15.0
    container_name: selenium-hub
    ports:
      - "4444:4444"
      - "4442:4442"
      - "4443:4443"
    networks:
      - selenium-grid
    healthcheck:
      test: ["CMD", "/opt/bin/check-grid.sh", "--host", "0.0.0.0", "--port", "4444"]
      interval: 15s
      timeout: 30s
      retries: 5

  # Chrome Nodes
  chrome:
    image: selenium/node-chrome:4.15.0
    depends_on:
      selenium-hub:
        condition: service_healthy
    environment:
      - SE_EVENT_BUS_HOST=selenium-hub
      - SE_EVENT_BUS_PUBLISH_PORT=4442
      - SE_EVENT_BUS_SUBSCRIBE_PORT=4443
      - SE_NODE_MAX_SESSIONS=3
      - SE_VNC_NO_PASSWORD=1
    volumes:
      - /dev/shm:/dev/shm
    networks:
      - selenium-grid
    shm_size: '2gb'
    deploy:
      replicas: 2

  # Firefox Nodes
  firefox:
    image: selenium/node-firefox:4.15.0
    depends_on:
      selenium-hub:
        condition: service_healthy
    environment:
      - SE_EVENT_BUS_HOST=selenium-hub
      - SE_EVENT_BUS_PUBLISH_PORT=4442
      - SE_EVENT_BUS_SUBSCRIBE_PORT=4443
      - SE_NODE_MAX_SESSIONS=3
    volumes:
      - /dev/shm:/dev/shm
    networks:
      - selenium-grid
    shm_size: '2gb'

  # Test Execution Container
  test-runner:
    build:
      context: .
      dockerfile: Dockerfile
    depends_on:
      selenium-hub:
        condition: service_healthy
    environment:
      - GRID_URL=http://selenium-hub:4444
      - BROWSER=chrome
      - PARALLEL_THREADS=3
    volumes:
      - ./test-reports:/app/target/reports  # Mount reports directory
      - ./screenshots:/app/target/screenshots
      - ./logs:/app/logs
    networks:
      - selenium-grid
    command: mvn clean test -Dsurefire.suiteXmlFiles=testng.xml

networks:
  selenium-grid:
    driver: bridge

# Commands:
# Start all: docker-compose up
# Start Grid only: docker-compose up -d selenium-hub chrome firefox
# Run tests: docker-compose run test-runner
# View logs: docker-compose logs -f test-runner
# Scale: docker-compose up -d --scale chrome=5
# Stop all: docker-compose down
```

```java
// 4. Config Helper for Docker Environment
package config;

public class DockerConfig {

    public static String getGridUrl() {
        // In Docker, use service name; locally, use localhost
        String gridUrl = System.getenv("GRID_URL");

        if (gridUrl == null || gridUrl.isEmpty()) {
            // Local execution
            return "http://localhost:4444";
        }

        // Docker execution
        return gridUrl;
    }

    public static String getBrowser() {
        String browser = System.getenv("BROWSER");
        return browser != null ? browser : "chrome";
    }

    public static int getParallelThreads() {
        String threads = System.getenv("PARALLEL_THREADS");
        return threads != null ? Integer.parseInt(threads) : 1;
    }

    public static boolean isDockerEnvironment() {
        return System.getenv("GRID_URL") != null;
    }

    public static void printEnvironmentInfo() {
        System.out.println("=== Test Environment ===");
        System.out.println("Docker Mode: " + isDockerEnvironment());
        System.out.println("Grid URL: " + getGridUrl());
        System.out.println("Browser: " + getBrowser());
        System.out.println("Parallel Threads: " + getParallelThreads());
        System.out.println("========================");
    }
}
```

```java
// 5. Enhanced Driver Factory for Docker
package factory;

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.remote.RemoteWebDriver;
import org.openqa.selenium.chrome.ChromeOptions;
import org.openqa.selenium.firefox.FirefoxOptions;
import config.DockerConfig;
import java.net.URL;

public class DockerDriverFactory {

    private static ThreadLocal<WebDriver> driver = new ThreadLocal<>();

    public static WebDriver createDriver() {
        try {
            String browser = DockerConfig.getBrowser();
            String gridUrl = DockerConfig.getGridUrl();

            WebDriver remoteDriver;

            if ("chrome".equalsIgnoreCase(browser)) {
                ChromeOptions options = new ChromeOptions();

                if (DockerConfig.isDockerEnvironment()) {
                    // Docker-specific options
                    options.addArguments("--no-sandbox");
                    options.addArguments("--disable-dev-shm-usage");
                    options.addArguments("--disable-gpu");
                } else {
                    options.addArguments("--start-maximized");
                }

                options.addArguments("--disable-notifications");
                options.addArguments("--disable-popup-blocking");

                remoteDriver = new RemoteWebDriver(
                    new URL(gridUrl),
                    options
                );

            } else if ("firefox".equalsIgnoreCase(browser)) {
                FirefoxOptions options = new FirefoxOptions();

                if (DockerConfig.isDockerEnvironment()) {
                    // Docker-specific options
                    options.addPreference("browser.privatebrowsing.autostart", true);
                }

                remoteDriver = new RemoteWebDriver(
                    new URL(gridUrl),
                    options
                );

            } else {
                throw new IllegalArgumentException("Unsupported browser: " + browser);
            }

            driver.set(remoteDriver);

            System.out.println(
                "Driver created | Browser: " + browser +
                " | Grid: " + gridUrl +
                " | Session: " + ((RemoteWebDriver) remoteDriver).getSessionId()
            );

            return remoteDriver;

        } catch (Exception e) {
            throw new RuntimeException("Failed to create driver: " + e.getMessage(), e);
        }
    }

    public static WebDriver getDriver() {
        return driver.get();
    }

    public static void quitDriver() {
        if (driver.get() != null) {
            driver.get().quit();
            driver.remove();
        }
    }
}
```

```yaml
# 6. Jenkinsfile for Docker-based Test Execution
/*
pipeline {
    agent any

    environment {
        DOCKER_COMPOSE_FILE = 'docker-compose.yml'
        TEST_REPORTS_DIR = 'test-reports'
    }

    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }

        stage('Start Selenium Grid') {
            steps {
                script {
                    sh """
                        docker-compose -f ${DOCKER_COMPOSE_FILE} up -d selenium-hub chrome firefox
                        echo "Waiting for Grid to be ready..."
                        sleep 15
                    """
                }
            }
        }

        stage('Run Tests') {
            parallel {
                stage('Chrome Tests') {
                    steps {
                        script {
                            sh """
                                docker-compose -f ${DOCKER_COMPOSE_FILE} run \
                                    -e BROWSER=chrome \
                                    -e PARALLEL_THREADS=3 \
                                    test-runner
                            """
                        }
                    }
                }

                stage('Firefox Tests') {
                    steps {
                        script {
                            sh """
                                docker-compose -f ${DOCKER_COMPOSE_FILE} run \
                                    -e BROWSER=firefox \
                                    -e PARALLEL_THREADS=2 \
                                    test-runner
                            """
                        }
                    }
                }
            }
        }

        stage('Generate Reports') {
            steps {
                script {
                    sh """
                        # Copy reports from container
                        docker cp test-runner:/app/target/reports ./test-reports
                        docker cp test-runner:/app/target/screenshots ./screenshots
                    """
                }
            }
        }
    }

    post {
        always {
            script {
                // Stop and remove containers
                sh "docker-compose -f ${DOCKER_COMPOSE_FILE} down"

                // Publish reports
                publishHTML([
                    allowMissing: false,
                    alwaysLinkToLastBuild: true,
                    keepAll: true,
                    reportDir: 'test-reports',
                    reportFiles: 'index.html',
                    reportName: 'Test Report'
                ])

                // Archive artifacts
                archiveArtifacts artifacts: 'test-reports/**, screenshots/**',
                                allowEmptyArchive: true
            }
        }

        success {
            echo 'Tests passed successfully!'
        }

        failure {
            echo 'Tests failed. Check reports for details.'
        }
    }
}
*/
```

```bash
# 7. Shell Scripts for Docker Management

# start-grid.sh
#!/bin/bash
echo "Starting Selenium Grid..."
docker-compose up -d selenium-hub chrome firefox

echo "Waiting for Grid to be ready..."
until $(curl --output /dev/null --silent --head --fail http://localhost:4444/status); do
    printf '.'
    sleep 2
done

echo "\nGrid is ready!"
echo "Grid UI: http://localhost:4444"

# run-tests.sh
#!/bin/bash
BROWSER=${1:-chrome}
THREADS=${2:-3}

echo "Running tests with Browser: $BROWSER, Threads: $THREADS"

docker-compose run \
    -e BROWSER=$BROWSER \
    -e PARALLEL_THREADS=$THREADS \
    test-runner \
    mvn clean test

echo "Tests completed. Check ./test-reports for results."

# stop-grid.sh
#!/bin/bash
echo "Stopping Selenium Grid and cleaning up..."
docker-compose down -v
docker system prune -f

echo "Cleanup complete!"

# Usage:
# chmod +x *.sh
# ./start-grid.sh
# ./run-tests.sh chrome 5
# ./stop-grid.sh
```

```yaml
# 8. GitHub Actions Workflow
/*
name: Selenium Docker Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 2 * * *'  # Daily at 2 AM

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2

    - name: Start Selenium Grid
      run: |
        docker-compose up -d selenium-hub chrome firefox
        echo "Waiting for Grid..."
        sleep 20

    - name: Build Test Image
      run: docker-compose build test-runner

    - name: Run Chrome Tests
      run: |
        docker-compose run \
          -e BROWSER=chrome \
          -e PARALLEL_THREADS=3 \
          test-runner

    - name: Run Firefox Tests
      run: |
        docker-compose run \
          -e BROWSER=firefox \
          -e PARALLEL_THREADS=2 \
          test-runner

    - name: Upload Test Reports
      if: always()
      uses: actions/upload-artifact@v3
      with:
        name: test-reports
        path: test-reports/

    - name: Upload Screenshots
      if: failure()
      uses: actions/upload-artifact@v3
      with:
        name: screenshots
        path: screenshots/

    - name: Cleanup
      if: always()
      run: docker-compose down -v
*/
```

**Follow-up**: How to debug tests running in Docker? How to handle volume mounts for reports? How to optimize Docker image size? What are best practices for Docker-based test execution in CI/CD?

---

### Q73. How do you run Selenium tests in headless mode? When would you use it?

**Difficulty**: Medium | **Experience**: 4-7, 6-8 years
**Companies**: Amazon, Microsoft, Netflix, Uber, Adobe, Flipkart

**Answer**:
Headless browser execution runs browsers without a graphical user interface (GUI), making tests faster and more efficient for CI/CD environments. The browser processes run in memory without rendering pixels to screen.

**Use Cases**:
- CI/CD pipelines (Jenkins, GitHub Actions)
- Docker containers without display
- Faster test execution (no GUI rendering)
- Parallel execution on limited resources
- Automated scheduled test runs
- Cloud-based test execution
- Regression testing on servers

**Benefits**:
- 30-50% faster execution
- Lower resource consumption (CPU, Memory)
- Runs in environments without display
- Better for containerized execution

**Limitations**:
- Can't visually debug tests
- Some JavaScript rendering differences
- Screenshot quality may vary
- Animation/visual effects behave differently

**Code Examples**:

```java
// 1. Chrome Headless Configuration
package config;

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.chrome.ChromeOptions;

public class ChromeHeadlessConfig {

    public static WebDriver createHeadlessChrome() {
        ChromeOptions options = new ChromeOptions();

        // Enable headless mode
        options.addArguments("--headless=new");  // New headless mode (Chrome 109+)

        // OR for older versions
        // options.addArguments("--headless");

        // Essential headless arguments
        options.addArguments("--no-sandbox");
        options.addArguments("--disable-dev-shm-usage");
        options.addArguments("--disable-gpu");

        // Set window size (important for responsive testing)
        options.addArguments("--window-size=1920,1080");

        // Additional performance options
        options.addArguments("--disable-extensions");
        options.addArguments("--disable-software-rasterizer");
        options.addArguments("--disable-notifications");
        options.addArguments("--disable-popup-blocking");

        // User agent (to avoid headless detection)
        options.addArguments(
            "--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) " +
            "AppleWebKit/537.36 (KHTML, like Gecko) " +
            "Chrome/120.0.0.0 Safari/537.36"
        );

        // Performance preferences
        options.setExperimentalOption("excludeSwitches",
            new String[]{"enable-automation"});
        options.setExperimentalOption("useAutomationExtension", false);

        WebDriver driver = new ChromeDriver(options);

        System.out.println("Chrome started in headless mode");
        return driver;
    }
}
```

```java
// 2. Firefox Headless Configuration
package config;

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.firefox.FirefoxDriver;
import org.openqa.selenium.firefox.FirefoxOptions;
import org.openqa.selenium.firefox.FirefoxProfile;

public class FirefoxHeadlessConfig {

    public static WebDriver createHeadlessFirefox() {
        FirefoxOptions options = new FirefoxOptions();

        // Enable headless mode
        options.addArguments("--headless");

        // Set window size
        options.addArguments("--width=1920");
        options.addArguments("--height=1080");

        // Firefox profile configurations
        FirefoxProfile profile = new FirefoxProfile();

        // Disable images for faster loading (optional)
        profile.setPreference("permissions.default.image", 2);

        // Disable CSS (optional for even faster execution)
        // profile.setPreference("permissions.default.stylesheet", 2);

        // Disable Flash
        profile.setPreference("dom.ipc.plugins.enabled.libflashplayer.so", false);

        // Set download directory
        profile.setPreference("browser.download.folderList", 2);
        profile.setPreference("browser.download.dir", "/tmp/downloads");
        profile.setPreference("browser.helperApps.neverAsk.saveToDisk",
            "application/pdf,text/csv,application/zip");

        options.setProfile(profile);

        WebDriver driver = new FirefoxDriver(options);

        System.out.println("Firefox started in headless mode");
        return driver;
    }
}
```

```java
// 3. Edge Headless Configuration
package config;

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.edge.EdgeDriver;
import org.openqa.selenium.edge.EdgeOptions;

public class EdgeHeadlessConfig {

    public static WebDriver createHeadlessEdge() {
        EdgeOptions options = new EdgeOptions();

        // Enable headless mode
        options.addArguments("--headless");
        options.addArguments("--disable-gpu");
        options.addArguments("--window-size=1920,1080");
        options.addArguments("--no-sandbox");
        options.addArguments("--disable-dev-shm-usage");

        WebDriver driver = new EdgeDriver(options);

        System.out.println("Edge started in headless mode");
        return driver;
    }
}
```

```java
// 4. Dynamic Headless Configuration based on Environment
package factory;

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.chrome.ChromeOptions;

public class AdaptiveDriverFactory {

    private static ThreadLocal<WebDriver> driver = new ThreadLocal<>();

    public static WebDriver createDriver() {
        boolean isHeadless = shouldRunHeadless();

        ChromeOptions options = new ChromeOptions();

        if (isHeadless) {
            System.out.println("Running in HEADLESS mode");
            options.addArguments("--headless=new");
            options.addArguments("--no-sandbox");
            options.addArguments("--disable-dev-shm-usage");
            options.addArguments("--disable-gpu");
            options.addArguments("--window-size=1920,1080");
        } else {
            System.out.println("Running in HEADED mode");
            options.addArguments("--start-maximized");
        }

        // Common options for both modes
        options.addArguments("--disable-notifications");
        options.addArguments("--disable-popup-blocking");
        options.addArguments("--disable-extensions");

        WebDriver webDriver = new ChromeDriver(options);
        driver.set(webDriver);

        return webDriver;
    }

    /**
     * Determine if headless mode should be used
     */
    private static boolean shouldRunHeadless() {
        // Check environment variable
        String headlessEnv = System.getenv("HEADLESS");
        if (headlessEnv != null) {
            return Boolean.parseBoolean(headlessEnv);
        }

        // Check system property
        String headlessProp = System.getProperty("headless");
        if (headlessProp != null) {
            return Boolean.parseBoolean(headlessProp);
        }

        // Check if running in CI environment
        return isCIEnvironment();
    }

    /**
     * Detect CI environment
     */
    private static boolean isCIEnvironment() {
        return System.getenv("CI") != null ||
               System.getenv("JENKINS_HOME") != null ||
               System.getenv("GITHUB_ACTIONS") != null ||
               System.getenv("GITLAB_CI") != null ||
               System.getenv("CIRCLECI") != null;
    }

    public static WebDriver getDriver() {
        return driver.get();
    }

    public static void quitDriver() {
        if (driver.get() != null) {
            driver.get().quit();
            driver.remove();
        }
    }
}
```

```java
// 5. Headless with Screenshot Capability
package utils;

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.OutputType;
import org.openqa.selenium.TakesScreenshot;
import org.apache.commons.io.FileUtils;
import java.io.File;
import java.io.IOException;

public class HeadlessScreenshotHelper {

    private WebDriver driver;

    public HeadlessScreenshotHelper(WebDriver driver) {
        this.driver = driver;
    }

    /**
     * Take full page screenshot in headless mode
     */
    public String takeFullPageScreenshot(String fileName) {
        try {
            // Even in headless mode, screenshots work perfectly
            TakesScreenshot ts = (TakesScreenshot) driver;
            File source = ts.getScreenshotAs(OutputType.FILE);

            String filePath = "screenshots/" + fileName + ".png";
            File destination = new File(filePath);
            destination.getParentFile().mkdirs();

            FileUtils.copyFile(source, destination);

            System.out.println("Screenshot captured in headless mode: " + filePath);
            return filePath;

        } catch (IOException e) {
            System.err.println("Failed to capture screenshot: " + e.getMessage());
            return null;
        }
    }

    /**
     * Capture screenshot as Base64 (useful for reports)
     */
    public String takeScreenshotAsBase64() {
        TakesScreenshot ts = (TakesScreenshot) driver;
        return ts.getScreenshotAs(OutputType.BASE64);
    }
}
```

```java
// 6. Performance Comparison Test
package tests;

import org.testng.annotations.Test;
import org.openqa.selenium.WebDriver;
import factory.AdaptiveDriverFactory;

public class HeadlessPerformanceTest {

    @Test
    public void measureHeadlessPerformance() {
        long startTime = System.currentTimeMillis();

        WebDriver driver = AdaptiveDriverFactory.createDriver();

        try {
            driver.get("https://example.com");

            // Perform test operations
            driver.findElement(By.id("search")).sendKeys("test");
            driver.findElement(By.id("submit")).click();

            // Wait for results
            new WebDriverWait(driver, Duration.ofSeconds(10))
                .until(ExpectedConditions.presenceOfElementLocated(
                    By.cssSelector(".results")
                ));

            long endTime = System.currentTimeMillis();
            long duration = endTime - startTime;

            System.out.println("Test execution time: " + duration + "ms");

            // Headless is typically 30-50% faster
            // Headed: ~5000ms
            // Headless: ~3000ms

        } finally {
            AdaptiveDriverFactory.quitDriver();
        }
    }
}
```

```xml
<!-- 7. Maven Command Line Options -->
<!--
Run with headless mode:
mvn clean test -Dheadless=true

Run with headed mode:
mvn clean test -Dheadless=false

Run with specific browser in headless:
mvn clean test -Dbrowser=chrome -Dheadless=true
-->
```

```yaml
# 8. Jenkins Pipeline with Headless Configuration
/*
pipeline {
    agent any

    environment {
        HEADLESS = 'true'
        BROWSER = 'chrome'
    }

    stages {
        stage('Run Headless Tests') {
            steps {
                sh """
                    mvn clean test \
                        -Dheadless=${HEADLESS} \
                        -Dbrowser=${BROWSER} \
                        -DsuiteXmlFile=testng.xml
                """
            }
        }

        stage('Archive Screenshots') {
            steps {
                archiveArtifacts artifacts: 'screenshots/**',
                                allowEmptyArchive: true
            }
        }
    }
}
*/
```

```yaml
# 9. GitHub Actions with Headless Mode
/*
name: Headless Browser Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Set up JDK 11
      uses: actions/setup-java@v3
      with:
        java-version: '11'
        distribution: 'temurin'

    - name: Run Tests in Headless Mode
      run: |
        mvn clean test \
          -Dheadless=true \
          -Dbrowser=chrome
      env:
        HEADLESS: true
        CI: true

    - name: Upload Screenshots
      if: failure()
      uses: actions/upload-artifact@v3
      with:
        name: screenshots
        path: screenshots/
*/
```

```java
// 10. TestNG Configuration for Headless/Headed
package tests;

import org.testng.annotations.*;
import org.openqa.selenium.WebDriver;
import factory.AdaptiveDriverFactory;

public class BaseTest {

    protected WebDriver driver;

    @BeforeMethod
    public void setup() {
        // Automatically detects environment and runs headless in CI
        driver = AdaptiveDriverFactory.createDriver();

        printExecutionMode();
    }

    @AfterMethod
    public void teardown() {
        AdaptiveDriverFactory.quitDriver();
    }

    private void printExecutionMode() {
        String mode = AdaptiveDriverFactory.shouldRunHeadless() ?
                     "HEADLESS" : "HEADED";
        System.out.println("Execution Mode: " + mode);
    }
}
```

**Follow-up**: How does headless mode affect test reliability? How to debug headless test failures? What are the performance differences? How to handle visual testing in headless mode?

---

### Q74. What are Selenium 4 new features? How do they differ from Selenium 3?

**Difficulty**: Medium | **Experience**: 5-8, 6-8 years
**Companies**: Google, Amazon, Microsoft, Adobe, Netflix

**Answer**:
Selenium 4 introduced major improvements focusing on W3C WebDriver protocol compliance, better APIs, improved documentation, and enhanced Grid architecture.

**Key New Features**:
1. **W3C WebDriver Standard**: Full compliance (no more JSON Wire Protocol)
2. **Relative Locators**: Find elements relative to other elements
3. **New Window/Tab Management**: Better window handling
4. **Network Interception**: Capture network traffic
5. **Chrome DevTools Protocol (CDP)**: Direct access to Chrome DevTools
6. **Improved Selenium Grid**: Standalone, distributed modes, better UI
7. **Enhanced Actions API**: Better mouse/keyboard actions
8. **Updated Documentation**: Better JavaDocs and guides
9. **Better Browser Options**: Simplified configuration
10. **Element Screenshot**: Capture specific element screenshots

**Code Examples**:

```java
// 1. Relative Locators (Selenium 4 Feature)
package features;

import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.support.locators.RelativeLocator;
import static org.openqa.selenium.support.locators.RelativeLocator.with;

public class RelativeLocatorsDemo {

    private WebDriver driver;

    public RelativeLocatorsDemo(WebDriver driver) {
        this.driver = driver;
    }

    /**
     * Find element above another element
     */
    public WebElement findElementAbove() {
        WebElement passwordField = driver.findElement(By.id("password"));

        // Find label above password field
        WebElement label = driver.findElement(
            with(By.tagName("label")).above(passwordField)
        );

        return label;
    }

    /**
     * Find element below another element
     */
    public WebElement findElementBelow() {
        WebElement usernameField = driver.findElement(By.id("username"));

        // Find password field below username
        WebElement passwordField = driver.findElement(
            with(By.tagName("input")).below(usernameField)
        );

        return passwordField;
    }

    /**
     * Find element to the left of another element
     */
    public WebElement findElementToLeft() {
        WebElement submitButton = driver.findElement(By.id("submit"));

        // Find cancel button to the left
        WebElement cancelButton = driver.findElement(
            with(By.tagName("button")).toLeftOf(submitButton)
        );

        return cancelButton;
    }

    /**
     * Find element to the right of another element
     */
    public WebElement findElementToRight() {
        WebElement cancelButton = driver.findElement(By.id("cancel"));

        // Find submit button to the right
        WebElement submitButton = driver.findElement(
            with(By.tagName("button")).toRightOf(cancelButton)
        );

        return submitButton;
    }

    /**
     * Find element near another element (within 50px)
     */
    public WebElement findElementNear() {
        WebElement loginButton = driver.findElement(By.id("login"));

        // Find "Forgot Password?" link near login button
        WebElement forgotPasswordLink = driver.findElement(
            with(By.tagName("a")).near(loginButton)
        );

        return forgotPasswordLink;
    }

    /**
     * Complex relative locator combination
     */
    public WebElement findWithMultipleConditions() {
        WebElement emailLabel = driver.findElement(By.id("email-label"));
        WebElement submitButton = driver.findElement(By.id("submit"));

        // Find element below email label and above submit button
        WebElement element = driver.findElement(
            with(By.tagName("input"))
                .below(emailLabel)
                .above(submitButton)
        );

        return element;
    }
}
```

```java
// 2. New Window/Tab Management (Selenium 4)
package features;

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WindowType;
import java.util.Set;

public class WindowTabManagement {

    private WebDriver driver;

    public WindowTabManagement(WebDriver driver) {
        this.driver = driver;
    }

    /**
     * Open new tab and switch to it
     */
    public void openNewTab() {
        String originalWindow = driver.getWindowHandle();

        // Selenium 4: Easy way to open new tab
        driver.switchTo().newWindow(WindowType.TAB);

        System.out.println("New tab opened");
        driver.get("https://example.com");

        // Switch back to original tab
        driver.switchTo().window(originalWindow);
    }

    /**
     * Open new window and switch to it
     */
    public void openNewWindow() {
        String originalWindow = driver.getWindowHandle();

        // Selenium 4: Easy way to open new window
        driver.switchTo().newWindow(WindowType.WINDOW);

        System.out.println("New window opened");
        driver.get("https://example.com");

        // Switch back to original window
        driver.switchTo().window(originalWindow);
    }

    /**
     * Work with multiple tabs
     */
    public void multiTabWorkflow() {
        // Original tab
        driver.get("https://example.com");
        String tab1 = driver.getWindowHandle();

        // Open second tab
        driver.switchTo().newWindow(WindowType.TAB);
        String tab2 = driver.getWindowHandle();
        driver.get("https://google.com");

        // Open third tab
        driver.switchTo().newWindow(WindowType.TAB);
        String tab3 = driver.getWindowHandle();
        driver.get("https://github.com");

        // Switch between tabs
        driver.switchTo().window(tab1);
        System.out.println("On tab 1: " + driver.getTitle());

        driver.switchTo().window(tab2);
        System.out.println("On tab 2: " + driver.getTitle());

        driver.switchTo().window(tab3);
        System.out.println("On tab 3: " + driver.getTitle());
    }
}
```

```java
// 3. Chrome DevTools Protocol (CDP) Integration
package features;

import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.devtools.DevTools;
import org.openqa.selenium.devtools.v120.network.Network;
import org.openqa.selenium.devtools.v120.network.model.RequestId;
import org.openqa.selenium.devtools.v120.performance.Performance;
import org.openqa.selenium.devtools.v120.performance.model.Metric;
import java.util.List;
import java.util.Optional;

public class ChromeDevToolsDemo {

    private ChromeDriver driver;
    private DevTools devTools;

    public ChromeDevToolsDemo(ChromeDriver driver) {
        this.driver = driver;
        this.devTools = driver.getDevTools();
        devTools.createSession();
    }

    /**
     * Monitor network traffic
     */
    public void monitorNetworkTraffic() {
        // Enable network tracking
        devTools.send(Network.enable(
            Optional.empty(),
            Optional.empty(),
            Optional.empty()
        ));

        // Listen to network requests
        devTools.addListener(Network.requestWillBeSent(), request -> {
            System.out.println("Request URL: " + request.getRequest().getUrl());
            System.out.println("Request Method: " + request.getRequest().getMethod());
        });

        // Listen to network responses
        devTools.addListener(Network.responseReceived(), response -> {
            System.out.println("Response URL: " + response.getResponse().getUrl());
            System.out.println("Status Code: " + response.getResponse().getStatus());
        });

        driver.get("https://example.com");
    }

    /**
     * Block specific URLs
     */
    public void blockUrls() {
        devTools.send(Network.enable(
            Optional.empty(),
            Optional.empty(),
            Optional.empty()
        ));

        // Block URLs matching pattern
        devTools.send(Network.setBlockedURLs(
            List.of("*.css", "*.png", "*.jpg", "*analytics*", "*ads*")
        ));

        System.out.println("Blocked: Images, CSS, Analytics, Ads");

        driver.get("https://example.com");
    }

    /**
     * Simulate network conditions
     */
    public void simulateNetworkConditions() {
        devTools.send(Network.enable(
            Optional.empty(),
            Optional.empty(),
            Optional.empty()
        ));

        // Simulate slow 3G network
        devTools.send(Network.emulateNetworkConditions(
            false,                    // offline
            100,                      // latency (ms)
            750 * 1024 / 8,          // download throughput (bytes/sec)
            250 * 1024 / 8,          // upload throughput (bytes/sec)
            Optional.empty()          // connection type
        ));

        System.out.println("Simulating slow 3G network");

        driver.get("https://example.com");
    }

    /**
     * Capture performance metrics
     */
    public void capturePerformanceMetrics() {
        devTools.send(Performance.enable(Optional.empty()));

        driver.get("https://example.com");

        // Get performance metrics
        List<Metric> metrics = devTools.send(Performance.getMetrics());

        System.out.println("\n=== Performance Metrics ===");
        for (Metric metric : metrics) {
            System.out.println(metric.getName() + ": " + metric.getValue());
        }
    }

    /**
     * Set geolocation
     */
    public void setGeolocation() {
        // Set geolocation to New York
        driver.executeCdpCommand("Emulation.setGeolocationOverride",
            Map.of(
                "latitude", 40.7128,
                "longitude", -74.0060,
                "accuracy", 1
            )
        );

        System.out.println("Geolocation set to New York");

        driver.get("https://maps.google.com");
    }

    /**
     * Capture console logs
     */
    public void captureConsoleLogs() {
        devTools.send(org.openqa.selenium.devtools.v120.log.Log.enable());

        devTools.addListener(
            org.openqa.selenium.devtools.v120.log.Log.entryAdded(),
            logEntry -> {
                System.out.println("Console " + logEntry.getLevel() + ": " +
                                 logEntry.getText());
            }
        );

        driver.get("https://example.com");
    }
}
```

```java
// 4. Element Screenshot (Selenium 4)
package features;

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.By;
import org.openqa.selenium.OutputType;
import org.apache.commons.io.FileUtils;
import java.io.File;
import java.io.IOException;

public class ElementScreenshotDemo {

    private WebDriver driver;

    public ElementScreenshotDemo(WebDriver driver) {
        this.driver = driver;
    }

    /**
     * Capture screenshot of specific element (Selenium 4 feature)
     */
    public void captureElementScreenshot() {
        driver.get("https://example.com");

        // Find element
        WebElement logo = driver.findElement(By.className("logo"));

        // Selenium 4: Capture element screenshot directly
        try {
            File screenshot = logo.getScreenshotAs(OutputType.FILE);
            File destination = new File("screenshots/logo.png");
            destination.getParentFile().mkdirs();
            FileUtils.copyFile(screenshot, destination);

            System.out.println("Element screenshot saved: " +
                             destination.getAbsolutePath());

        } catch (IOException e) {
            System.err.println("Failed to save screenshot: " + e.getMessage());
        }
    }

    /**
     * Capture multiple element screenshots
     */
    public void captureMultipleElementScreenshots() {
        driver.get("https://example.com");

        // Capture header
        WebElement header = driver.findElement(By.tagName("header"));
        saveElementScreenshot(header, "header.png");

        // Capture main content
        WebElement main = driver.findElement(By.tagName("main"));
        saveElementScreenshot(main, "main-content.png");

        // Capture footer
        WebElement footer = driver.findElement(By.tagName("footer"));
        saveElementScreenshot(footer, "footer.png");
    }

    private void saveElementScreenshot(WebElement element, String fileName) {
        try {
            File screenshot = element.getScreenshotAs(OutputType.FILE);
            File destination = new File("screenshots/elements/" + fileName);
            destination.getParentFile().mkdirs();
            FileUtils.copyFile(screenshot, destination);
            System.out.println("Saved: " + fileName);
        } catch (IOException e) {
            System.err.println("Failed to save " + fileName);
        }
    }
}
```

```java
// 5. Enhanced Actions API (Selenium 4)
package features;

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.By;
import org.openqa.selenium.interactions.Actions;
import org.openqa.selenium.interactions.WheelInput;
import java.time.Duration;

public class EnhancedActionsDemo {

    private WebDriver driver;
    private Actions actions;

    public EnhancedActionsDemo(WebDriver driver) {
        this.driver = driver;
        this.actions = new Actions(driver);
    }

    /**
     * Scroll to element with offset (Selenium 4)
     */
    public void scrollToElementWithOffset() {
        WebElement element = driver.findElement(By.id("target"));

        // Selenium 4: Scroll with offset
        actions.scrollToElement(element)
               .perform();

        System.out.println("Scrolled to element");
    }

    /**
     * Scroll by amount (Selenium 4)
     */
    public void scrollByAmount() {
        // Scroll down by 500 pixels
        actions.scrollByAmount(0, 500)
               .perform();

        System.out.println("Scrolled down 500px");
    }

    /**
     * Wheel input for precise scrolling (Selenium 4)
     */
    public void preciseWheelScroll() {
        WebElement element = driver.findElement(By.id("scrollable"));

        WheelInput.ScrollOrigin scrollOrigin =
            WheelInput.ScrollOrigin.fromElement(element);

        // Precise scroll with delta
        actions.scrollFromOrigin(scrollOrigin, 0, 200)
               .perform();

        System.out.println("Precise scroll performed");
    }

    /**
     * Right-click with context menu
     */
    public void enhancedContextClick() {
        WebElement element = driver.findElement(By.id("file"));

        // Right-click and select from context menu
        actions.contextClick(element)
               .pause(Duration.ofMillis(500))
               .sendKeys(Keys.ARROW_DOWN)
               .sendKeys(Keys.ARROW_DOWN)
               .sendKeys(Keys.ENTER)
               .perform();

        System.out.println("Context menu action performed");
    }
}
```

```java
// 6. Comparison: Selenium 3 vs Selenium 4
package comparison;

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.By;
import org.openqa.selenium.WebElement;

public class Selenium3vs4Comparison {

    /**
     * SELENIUM 3: Opening new tab (complicated)
     */
    public void openNewTabSelenium3(WebDriver driver) {
        JavascriptExecutor js = (JavascriptExecutor) driver;
        js.executeScript("window.open()");

        Set<String> windows = driver.getWindowHandles();
        for (String window : windows) {
            driver.switchTo().window(window);
        }
    }

    /**
     * SELENIUM 4: Opening new tab (simple)
     */
    public void openNewTabSelenium4(WebDriver driver) {
        driver.switchTo().newWindow(WindowType.TAB);
    }

    /**
     * SELENIUM 3: Finding element above another (workaround)
     */
    public WebElement findAboveSelenium3(WebDriver driver, WebElement reference) {
        JavascriptExecutor js = (JavascriptExecutor) driver;
        int y = reference.getLocation().getY();

        // Complex JavaScript to find element above
        return (WebElement) js.executeScript(
            "return document.elementFromPoint(arguments[0], arguments[1] - 50);",
            reference.getLocation().getX(),
            y
        );
    }

    /**
     * SELENIUM 4: Finding element above another (simple)
     */
    public WebElement findAboveSelenium4(WebDriver driver, WebElement reference) {
        return driver.findElement(
            RelativeLocator.with(By.tagName("div")).above(reference)
        );
    }

    /**
     * SELENIUM 3: Element screenshot (workaround)
     */
    public void elementScreenshotSelenium3(WebDriver driver, WebElement element) {
        // Take full page screenshot
        File screenshot = ((TakesScreenshot) driver).getScreenshotAs(OutputType.FILE);

        // Crop to element size using BufferedImage
        // ... complex cropping logic ...
    }

    /**
     * SELENIUM 4: Element screenshot (built-in)
     */
    public void elementScreenshotSelenium4(WebElement element) {
        File screenshot = element.getScreenshotAs(OutputType.FILE);
        // Ready to use!
    }
}
```

**Follow-up**: What is W3C WebDriver protocol? How to migrate from Selenium 3 to 4? What are breaking changes? Which Selenium 4 features would you use most in your framework?

---

### Q75. How do you optimize Selenium test execution performance? What strategies do you use?

**Difficulty**: Hard | **Experience**: 6-8, 9-12 years
**Companies**: Google, Amazon, Microsoft, Netflix, Uber, Adobe

**Answer**:
Performance optimization in Selenium testing involves reducing execution time while maintaining test reliability and coverage. Multiple strategies at different levels can significantly improve performance.

**Optimization Strategies**:
1. **Parallel Execution**: Run tests concurrently
2. **Headless Browsers**: 30-50% faster execution
3. **Reduce Waits**: Use explicit waits efficiently
4. **Disable Unnecessary Features**: Images, CSS, JavaScript (when possible)
5. **Page Load Strategy**: Use eager or none strategies
6. **Connection Pooling**: Reuse browser sessions
7. **Selective Test Execution**: Tags, groups, smoke vs regression
8. **Grid & Cloud**: Distribute across machines
9. **Smart Test Selection**: Run only affected tests
10. **Framework Optimization**: Efficient locators, caching

**Code Examples**:

```java
// 1. Page Load Strategy Optimization
package optimization;

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.chrome.ChromeOptions;
import org.openqa.selenium.PageLoadStrategy;

public class PageLoadStrategyOptimizer {

    /**
     * Normal strategy: Waits for full page load (default)
     * - Slowest but most reliable
     */
    public static WebDriver createDriverNormalLoad() {
        ChromeOptions options = new ChromeOptions();
        options.setPageLoadStrategy(PageLoadStrategy.NORMAL);

        return new ChromeDriver(options);
    }

    /**
     * Eager strategy: Waits for DOMContentLoaded event
     * - Faster, doesn't wait for images/stylesheets
     * - Best for most test scenarios
     */
    public static WebDriver createDriverEagerLoad() {
        ChromeOptions options = new ChromeOptions();
        options.setPageLoadStrategy(PageLoadStrategy.EAGER);

        System.out.println("Using EAGER page load strategy");
        return new ChromeDriver(options);
    }

    /**
     * None strategy: Doesn't wait for page load
     * - Fastest but requires manual synchronization
     * - Use with caution
     */
    public static WebDriver createDriverNoneLoad() {
        ChromeOptions options = new ChromeOptions();
        options.setPageLoadStrategy(PageLoadStrategy.NONE);

        System.out.println("Using NONE page load strategy - manual sync required");
        return new ChromeDriver(options);
    }
}
```

```java
// 2. Disable Images, CSS, JavaScript for Faster Loading
package optimization;

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.chrome.ChromeOptions;
import java.util.HashMap;
import java.util.Map;

public class ContentBlockingOptimizer {

    /**
     * Disable images for faster page load
     */
    public static WebDriver createDriverWithoutImages() {
        ChromeOptions options = new ChromeOptions();

        Map<String, Object> prefs = new HashMap<>();

        // Disable images
        prefs.put("profile.managed_default_content_settings.images", 2);

        // Disable CSS (optional - use with caution)
        // prefs.put("profile.managed_default_content_settings.stylesheet", 2);

        options.setExperimentalOption("prefs", prefs);

        System.out.println("Images disabled - faster page load");
        return new ChromeDriver(options);
    }

    /**
     * Block specific content types using Chrome DevTools Protocol
     */
    public static WebDriver createDriverWithContentBlocking() {
        ChromeOptions options = new ChromeOptions();

        // Block various resource types
        Map<String, Object> prefs = new HashMap<>();
        prefs.put("profile.managed_default_content_settings.images", 2);
        prefs.put("profile.managed_default_content_settings.plugins", 2);
        prefs.put("profile.managed_default_content_settings.popups", 2);
        prefs.put("profile.managed_default_content_settings.geolocation", 2);
        prefs.put("profile.managed_default_content_settings.notifications", 2);
        prefs.put("profile.managed_default_content_settings.media_stream", 2);

        options.setExperimentalOption("prefs", prefs);

        System.out.println("Multiple content types blocked for performance");
        return new ChromeDriver(options);
    }

    /**
     * Block specific URLs (analytics, ads, tracking)
     */
    public static void blockPerformanceHeavyUrls(ChromeDriver driver) {
        driver.executeCdpCommand("Network.enable", Map.of());

        driver.executeCdpCommand("Network.setBlockedURLs",
            Map.of("urls", List.of(
                "*google-analytics.com*",
                "*doubleclick.net*",
                "*facebook.com/tr*",
                "*analytics*",
                "*ads*",
                "*tracking*",
                "*.gif",
                "*.svg"
            ))
        );

        System.out.println("Analytics, ads, and tracking blocked");
    }
}
```

```java
// 3. Efficient Wait Strategy
package optimization;

import org.openqa.selenium.*;
import org.openqa.selenium.support.ui.WebDriverWait;
import org.openqa.selenium.support.ui.ExpectedConditions;
import java.time.Duration;

public class EfficientWaitStrategy {

    private WebDriver driver;
    private WebDriverWait wait;

    public EfficientWaitStrategy(WebDriver driver) {
        this.driver = driver;
        // Reduce default wait time for faster failures
        this.wait = new WebDriverWait(driver, Duration.ofSeconds(10));
    }

    /**
     * Smart wait - tries quick check first, then waits if needed
     */
    public WebElement smartFindElement(By locator) {
        try {
            // Try immediate find (no wait)
            return driver.findElement(locator);
        } catch (NoSuchElementException e) {
            // If not found, use explicit wait
            return wait.until(ExpectedConditions.presenceOfElementLocated(locator));
        }
    }

    /**
     * Batch element finding - find multiple elements in one go
     */
    public Map<String, WebElement> batchFindElements(Map<String, By> locators) {
        Map<String, WebElement> elements = new HashMap<>();

        // Wait for page to be ready once
        wait.until(driver ->
            ((JavascriptExecutor) driver)
                .executeScript("return document.readyState")
                .equals("complete")
        );

        // Find all elements without individual waits
        for (Map.Entry<String, By> entry : locators.entrySet()) {
            try {
                elements.put(entry.getKey(), driver.findElement(entry.getValue()));
            } catch (NoSuchElementException e) {
                System.err.println("Element not found: " + entry.getKey());
            }
        }

        return elements;
    }

    /**
     * Conditional wait - only wait if element is not already present
     */
    public WebElement conditionalWait(By locator, Duration timeout) {
        List<WebElement> elements = driver.findElements(locator);

        if (!elements.isEmpty() && elements.get(0).isDisplayed()) {
            // Element already present and visible
            return elements.get(0);
        }

        // Element not ready, use wait
        WebDriverWait customWait = new WebDriverWait(driver, timeout);
        return customWait.until(ExpectedConditions.visibilityOfElementLocated(locator));
    }
}
```

```java
// 4. Browser Session Reuse (Connection Pooling)
package optimization;

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import java.util.concurrent.ConcurrentHashMap;

public class BrowserSessionPool {

    private static ConcurrentHashMap<String, WebDriver> sessionPool =
        new ConcurrentHashMap<>();

    private static final int MAX_SESSIONS = 5;
    private static final Duration SESSION_TIMEOUT = Duration.ofMinutes(5);

    /**
     * Get or create browser session
     */
    public static WebDriver getSession(String sessionId) {
        return sessionPool.computeIfAbsent(sessionId, id -> {
            System.out.println("Creating new browser session: " + id);
            return new ChromeDriver();
        });
    }

    /**
     * Reuse existing session instead of creating new one
     */
    public static WebDriver reuseSession(String sessionId) {
        if (sessionPool.containsKey(sessionId)) {
            WebDriver driver = sessionPool.get(sessionId);

            // Clear cookies and navigate to blank page
            driver.manage().deleteAllCookies();
            driver.get("about:blank");

            System.out.println("Reusing existing session: " + sessionId);
            return driver;
        }

        return getSession(sessionId);
    }

    /**
     * Release session back to pool
     */
    public static void releaseSession(String sessionId) {
        // Don't quit driver, keep it in pool for reuse
        System.out.println("Session released to pool: " + sessionId);
    }

    /**
     * Cleanup - quit all sessions
     */
    public static void cleanup() {
        sessionPool.forEach((id, driver) -> {
            System.out.println("Quitting session: " + id);
            driver.quit();
        });
        sessionPool.clear();
    }
}
```

```java
// 5. Smart Locator Caching
package optimization;

import org.openqa.selenium.*;
import java.util.concurrent.ConcurrentHashMap;

public class LocatorCache {

    private WebDriver driver;
    private ConcurrentHashMap<String, WebElement> elementCache;
    private ConcurrentHashMap<String, Long> cacheTimestamps;
    private static final long CACHE_EXPIRY_MS = 5000; // 5 seconds

    public LocatorCache(WebDriver driver) {
        this.driver = driver;
        this.elementCache = new ConcurrentHashMap<>();
        this.cacheTimestamps = new ConcurrentHashMap<>();
    }

    /**
     * Find element with caching
     */
    public WebElement findWithCache(String key, By locator) {
        // Check if cached and not expired
        if (isCacheValid(key)) {
            try {
                WebElement element = elementCache.get(key);

                // Verify element is still valid (not stale)
                element.isDisplayed();

                System.out.println("Cache HIT: " + key);
                return element;

            } catch (StaleElementReferenceException e) {
                // Element is stale, remove from cache
                invalidateCache(key);
            }
        }

        // Cache MISS - find element and cache it
        System.out.println("Cache MISS: " + key);
        WebElement element = driver.findElement(locator);

        elementCache.put(key, element);
        cacheTimestamps.put(key, System.currentTimeMillis());

        return element;
    }

    /**
     * Check if cached element is still valid
     */
    private boolean isCacheValid(String key) {
        if (!elementCache.containsKey(key)) {
            return false;
        }

        long cachedTime = cacheTimestamps.get(key);
        long currentTime = System.currentTimeMillis();

        return (currentTime - cachedTime) < CACHE_EXPIRY_MS;
    }

    /**
     * Invalidate specific cache entry
     */
    public void invalidateCache(String key) {
        elementCache.remove(key);
        cacheTimestamps.remove(key);
    }

    /**
     * Clear all cache
     */
    public void clearCache() {
        elementCache.clear();
        cacheTimestamps.clear();
    }
}
```

```java
// 6. Parallel Execution with Optimal Thread Count
package optimization;

import org.testng.annotations.DataProvider;
import java.util.concurrent.Executors;
import java.util.concurrent.ExecutorService;

public class ParallelExecutionOptimizer {

    /**
     * Calculate optimal thread count based on system resources
     */
    public static int getOptimalThreadCount() {
        int availableCores = Runtime.getRuntime().availableProcessors();

        // Formula: cores * 2 for I/O bound tasks (Selenium tests)
        int optimalThreads = availableCores * 2;

        // Cap at reasonable maximum
        int maxThreads = 10;

        int threadCount = Math.min(optimalThreads, maxThreads);

        System.out.println("Available cores: " + availableCores);
        System.out.println("Optimal thread count: " + threadCount);

        return threadCount;
    }

    /**
     * Dynamic TestNG parallel configuration
     */
    @DataProvider(parallel = true)
    public Object[][] parallelTestData() {
        int threadCount = getOptimalThreadCount();

        // Adjust data provider based on system capability
        Object[][] data = new Object[threadCount][];

        for (int i = 0; i < threadCount; i++) {
            data[i] = new Object[]{"Test Data " + (i + 1)};
        }

        return data;
    }
}
```

```java
// 7. Performance Monitoring and Metrics
package optimization;

import org.openqa.selenium.WebDriver;
import java.util.HashMap;
import java.util.Map;
import java.time.Duration;
import java.time.Instant;

public class PerformanceMonitor {

    private Map<String, Instant> startTimes;
    private Map<String, Long> executionTimes;

    public PerformanceMonitor() {
        this.startTimes = new HashMap<>();
        this.executionTimes = new HashMap<>();
    }

    /**
     * Start timing an operation
     */
    public void startTimer(String operation) {
        startTimes.put(operation, Instant.now());
    }

    /**
     * Stop timing and record duration
     */
    public long stopTimer(String operation) {
        if (!startTimes.containsKey(operation)) {
            return -1;
        }

        Instant start = startTimes.get(operation);
        long duration = Duration.between(start, Instant.now()).toMillis();

        executionTimes.put(operation, duration);
        startTimes.remove(operation);

        return duration;
    }

    /**
     * Get performance report
     */
    public void printPerformanceReport() {
        System.out.println("\n=== Performance Report ===");

        long totalTime = 0;

        for (Map.Entry<String, Long> entry : executionTimes.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue() + "ms");
            totalTime += entry.getValue();
        }

        System.out.println("Total Execution Time: " + totalTime + "ms");

        if (!executionTimes.isEmpty()) {
            long avgTime = totalTime / executionTimes.size();
            System.out.println("Average Operation Time: " + avgTime + "ms");
        }

        // Identify slow operations
        System.out.println("\nâš ï¸ Slow Operations (>2000ms):");
        executionTimes.entrySet().stream()
            .filter(e -> e.getValue() > 2000)
            .forEach(e -> System.out.println("  - " + e.getKey() + ": " +
                                            e.getValue() + "ms"));
    }

    /**
     * Measure test execution time
     */
    public <T> T measureExecution(String operationName,
                                   java.util.function.Supplier<T> operation) {
        startTimer(operationName);
        T result = operation.get();
        long duration = stopTimer(operationName);

        System.out.println(operationName + " completed in " + duration + "ms");

        return result;
    }
}
```

```java
// 8. Selective Test Execution with TestNG Groups
package optimization;

import org.testng.annotations.Test;

public class SelectiveTestExecution {

    /**
     * Smoke tests - run on every commit (fast)
     */
    @Test(groups = {"smoke", "fast"}, priority = 1)
    public void smokeTest1() {
        // Quick critical path test
        System.out.println("Smoke test - 10 seconds");
    }

    /**
     * Regression tests - run nightly (comprehensive)
     */
    @Test(groups = {"regression", "slow"}, priority = 3)
    public void regressionTest1() {
        // Comprehensive test
        System.out.println("Regression test - 2 minutes");
    }

    /**
     * Sanity tests - run after deployment (medium)
     */
    @Test(groups = {"sanity", "medium"}, priority = 2)
    public void sanityTest1() {
        // Basic functionality check
        System.out.println("Sanity test - 30 seconds");
    }

    /*
    TestNG XML for selective execution:

    <!-- Run only smoke tests (fast) -->
    <suite name="Smoke Suite">
        <test name="Smoke Tests">
            <groups>
                <run>
                    <include name="smoke"/>
                </run>
            </groups>
            <packages>
                <package name="tests.*"/>
            </packages>
        </test>
    </suite>

    Maven command:
    mvn test -Dgroups=smoke
    */
}
```

```java
// 9. Optimized Test Base Class
package optimization;

import org.testng.annotations.*;
import org.openqa.selenium.WebDriver;
import factory.OptimizedDriverFactory;

public class OptimizedBaseTest {

    protected WebDriver driver;
    protected PerformanceMonitor perfMonitor;

    @BeforeSuite
    public void suiteSetup() {
        perfMonitor = new PerformanceMonitor();
        System.out.println("Optimal thread count: " +
                          ParallelExecutionOptimizer.getOptimalThreadCount());
    }

    @BeforeMethod
    public void setup() {
        perfMonitor.startTimer("Browser Initialization");

        // Use optimized driver with:
        // - Eager page load strategy
        // - Headless mode
        // - Images disabled
        // - Content blocking
        driver = OptimizedDriverFactory.createOptimizedDriver();

        perfMonitor.stopTimer("Browser Initialization");
    }

    @AfterMethod
    public void teardown() {
        if (driver != null) {
            driver.quit();
        }
    }

    @AfterSuite
    public void suiteTeardown() {
        perfMonitor.printPerformanceReport();
    }
}
```

```java
// 10. Complete Optimized Driver Factory
package factory;

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.chrome.ChromeOptions;
import org.openqa.selenium.PageLoadStrategy;
import java.util.HashMap;
import java.util.Map;

public class OptimizedDriverFactory {

    public static WebDriver createOptimizedDriver() {
        ChromeOptions options = new ChromeOptions();

        // 1. Headless mode for speed
        options.addArguments("--headless=new");
        options.addArguments("--no-sandbox");
        options.addArguments("--disable-dev-shm-usage");

        // 2. Eager page load strategy
        options.setPageLoadStrategy(PageLoadStrategy.EAGER);

        // 3. Disable images
        Map<String, Object> prefs = new HashMap<>();
        prefs.put("profile.managed_default_content_settings.images", 2);
        options.setExperimentalOption("prefs", prefs);

        // 4. Disable unnecessary features
        options.addArguments("--disable-extensions");
        options.addArguments("--disable-gpu");
        options.addArguments("--disable-plugins");
        options.addArguments("--disable-popup-blocking");
        options.addArguments("--disable-notifications");

        // 5. Performance settings
        options.addArguments("--disable-infobars");
        options.addArguments("--disable-logging");
        options.addArguments("--log-level=3");
        options.addArguments("--silent");

        // 6. Window size
        options.addArguments("--window-size=1920,1080");

        WebDriver driver = new ChromeDriver(options);

        // 7. Set timeouts
        driver.manage().timeouts().pageLoadTimeout(Duration.ofSeconds(30));
        driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(0)); // Disable

        System.out.println("âœ… Optimized driver created with all performance settings");

        return driver;
    }
}
```

**Performance Improvement Results**:
- Headless mode: 30-50% faster
- Eager page load: 20-30% faster
- Disabled images: 15-25% faster
- Parallel execution: 3-5x faster (with 5 threads)
- Combined optimizations: 60-80% faster overall

**Follow-up**: How to measure test execution performance? What's the trade-off between speed and reliability? How to identify performance bottlenecks? What metrics do you track?

---

### Q76. How do you debug Selenium test failures? What tools and techniques do you use?

**Difficulty**: Medium | **Experience**: 4-7, 6-8 years
**Companies**: Amazon, Microsoft, Adobe, Salesforce, Flipkart

**Answer**:
Debugging Selenium test failures requires systematic approaches and multiple techniques to identify root causes quickly. Effective debugging combines logging, screenshots, video recording, browser dev tools, and proper error handling.

**Debugging Techniques**:
1. **Screenshots on Failure**: Capture visual evidence
2. **Verbose Logging**: Detailed step-by-step logs
3. **Video Recording**: Record entire test execution
4. **Browser Console Logs**: Capture JavaScript errors
5. **Network Monitoring**: Track API calls and responses
6. **Page Source**: Save HTML for analysis
7. **Step-by-Step Execution**: Breakpoints and pauses
8. **Remote Debugging**: Connect to browser dev tools
9. **Retry with Logging**: Add extra logging on retry
10. **Stack Trace Analysis**: Understanding error origins

**Code Examples**:

```java
// 1. Comprehensive Debug Helper
package debug;

import org.openqa.selenium.*;
import org.apache.commons.io.FileUtils;
import java.io.File;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.logging.Level;
import java.util.logging.Logger;

public class DebugHelper {

    private WebDriver driver;
    private static final Logger logger = Logger.getLogger(DebugHelper.class.getName());
    private String debugDir = "target/debug";

    public DebugHelper(WebDriver driver) {
        this.driver = driver;
        new File(debugDir).mkdirs();
    }

    /**
     * Capture complete debug information on failure
     */
    public void captureDebugInfo(String testName, Throwable exception) {
        String timestamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
        String prefix = testName + "_" + timestamp;

        logger.severe("Test failed: " + testName);
        logger.severe("Exception: " + exception.getMessage());

        // 1. Take screenshot
        takeScreenshot(prefix);

        // 2. Save page source
        savePageSource(prefix);

        // 3. Capture browser logs
        captureBrowserLogs(prefix);

        // 4. Save current URL
        saveCurrentUrl(prefix);

        // 5. Capture console errors
        captureConsoleErrors(prefix);

        // 6. Print stack trace
        exception.printStackTrace();

        logger.info("Debug information saved to: " + debugDir + "/" + prefix);
    }

    /**
     * Take screenshot
     */
    private void takeScreenshot(String prefix) {
        try {
            TakesScreenshot ts = (TakesScreenshot) driver;
            File screenshot = ts.getScreenshotAs(OutputType.FILE);

            String fileName = debugDir + "/" + prefix + "_screenshot.png";
            FileUtils.copyFile(screenshot, new File(fileName));

            logger.info("Screenshot saved: " + fileName);

        } catch (Exception e) {
            logger.warning("Failed to capture screenshot: " + e.getMessage());
        }
    }

    /**
     * Save page source HTML
     */
    private void savePageSource(String prefix) {
        try {
            String pageSource = driver.getPageSource();
            String fileName = debugDir + "/" + prefix + "_source.html";

            FileUtils.writeStringToFile(
                new File(fileName),
                pageSource,
                "UTF-8"
            );

            logger.info("Page source saved: " + fileName);

        } catch (IOException e) {
            logger.warning("Failed to save page source: " + e.getMessage());
        }
    }

    /**
     * Capture browser console logs
     */
    private void captureBrowserLogs(String prefix) {
        try {
            LogEntries logs = driver.manage().logs().get(LogType.BROWSER);
            StringBuilder logContent = new StringBuilder();

            for (LogEntry entry : logs) {
                logContent.append(new Date(entry.getTimestamp()))
                         .append(" ")
                         .append(entry.getLevel())
                         .append(" - ")
                         .append(entry.getMessage())
                         .append("\n");
            }

            String fileName = debugDir + "/" + prefix + "_browser.log";
            FileUtils.writeStringToFile(
                new File(fileName),
                logContent.toString(),
                "UTF-8"
            );

            logger.info("Browser logs saved: " + fileName);

        } catch (Exception e) {
            logger.warning("Failed to capture browser logs: " + e.getMessage());
        }
    }

    /**
     * Save current URL
     */
    private void saveCurrentUrl(String prefix) {
        try {
            String currentUrl = driver.getCurrentUrl();
            String fileName = debugDir + "/" + prefix + "_url.txt";

            FileUtils.writeStringToFile(
                new File(fileName),
                currentUrl,
                "UTF-8"
            );

            logger.info("Current URL saved: " + fileName);

        } catch (IOException e) {
            logger.warning("Failed to save URL: " + e.getMessage());
        }
    }

    /**
     * Capture JavaScript console errors
     */
    private void captureConsoleErrors(String prefix) {
        try {
            JavascriptExecutor js = (JavascriptExecutor) driver;

            // Execute JavaScript to get console errors
            String script = "return window.jsErrors || [];";
            Object errors = js.executeScript(script);

            String fileName = debugDir + "/" + prefix + "_console_errors.txt";
            FileUtils.writeStringToFile(
                new File(fileName),
                errors.toString(),
                "UTF-8"
            );

            logger.info("Console errors saved: " + fileName);

        } catch (Exception e) {
            logger.warning("Failed to capture console errors: " + e.getMessage());
        }
    }

    /**
     * Highlight element before interaction (for debugging)
     */
    public void highlightElement(WebElement element) {
        try {
            JavascriptExecutor js = (JavascriptExecutor) driver;
            String originalStyle = element.getAttribute("style");

            // Highlight with red border
            js.executeScript(
                "arguments[0].setAttribute('style', 'border: 3px solid red; " +
                "background: yellow;');",
                element
            );

            Thread.sleep(500); // Pause to see highlight

            // Restore original style
            js.executeScript(
                "arguments[0].setAttribute('style', '" + originalStyle + "');",
                element
            );

        } catch (Exception e) {
            logger.warning("Failed to highlight element: " + e.getMessage());
        }
    }
}
```

```java
// 2. TestNG Listener for Automatic Debug Capture
package listeners;

import org.testng.*;
import org.openqa.selenium.WebDriver;
import debug.DebugHelper;
import factory.DriverManager;

public class DebugListener implements ITestListener {

    @Override
    public void onTestFailure(ITestResult result) {
        System.out.println("âŒ Test FAILED: " + result.getName());

        // Get WebDriver instance
        WebDriver driver = DriverManager.getDriver();

        if (driver != null) {
            DebugHelper debugHelper = new DebugHelper(driver);

            // Capture all debug information
            debugHelper.captureDebugInfo(
                result.getName(),
                result.getThrowable()
            );
        }
    }

    @Override
    public void onTestSuccess(ITestResult result) {
        System.out.println("âœ… Test PASSED: " + result.getName());
    }

    @Override
    public void onTestSkipped(ITestResult result) {
        System.out.println("â­ï¸ Test SKIPPED: " + result.getName());
    }

    @Override
    public void onTestStart(ITestResult result) {
        System.out.println("â–¶ï¸ Test STARTED: " + result.getName());
    }
}
```

```java
// 3. Video Recording Helper
package debug;

import org.monte.screenrecorder.ScreenRecorder;
import org.monte.media.Format;
import org.monte.media.math.Rational;
import static org.monte.media.FormatKeys.*;
import static org.monte.media.VideoFormatKeys.*;
import java.awt.*;
import java.io.File;

public class VideoRecorder {

    private ScreenRecorder screenRecorder;
    private String videoDir = "target/videos";

    public VideoRecorder() {
        new File(videoDir).mkdirs();
    }

    /**
     * Start video recording
     */
    public void startRecording(String testName) {
        try {
            GraphicsConfiguration gc = GraphicsEnvironment
                .getLocalGraphicsEnvironment()
                .getDefaultScreenDevice()
                .getDefaultConfiguration();

            screenRecorder = new ScreenRecorder(
                gc,
                gc.getBounds(),
                new Format(MediaTypeKey, MediaType.FILE, MimeTypeKey, MIME_AVI),
                new Format(MediaTypeKey, MediaType.VIDEO,
                          EncodingKey, ENCODING_AVI_TECHSMITH_SCREEN_CAPTURE,
                          CompressorNameKey, ENCODING_AVI_TECHSMITH_SCREEN_CAPTURE,
                          DepthKey, 24,
                          FrameRateKey, Rational.valueOf(15),
                          QualityKey, 1.0f,
                          KeyFrameIntervalKey, 15 * 60),
                new Format(MediaTypeKey, MediaType.VIDEO, EncodingKey, "black",
                          FrameRateKey, Rational.valueOf(30)),
                null,
                new File(videoDir)
            );

            screenRecorder.start();
            System.out.println("ðŸŽ¥ Recording started for: " + testName);

        } catch (Exception e) {
            System.err.println("Failed to start recording: " + e.getMessage());
        }
    }

    /**
     * Stop video recording
     */
    public void stopRecording() {
        try {
            if (screenRecorder != null) {
                screenRecorder.stop();
                System.out.println("â¹ï¸ Recording stopped");
            }
        } catch (Exception e) {
            System.err.println("Failed to stop recording: " + e.getMessage());
        }
    }
}
```

```java
// 4. Enhanced Logging with Step-by-Step Details
package debug;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.By;

public class DetailedLogger {

    private static final Logger logger = LogManager.getLogger(DetailedLogger.class);
    private WebDriver driver;

    public DetailedLogger(WebDriver driver) {
        this.driver = driver;
    }

    /**
     * Log with context information
     */
    public void logStep(String step) {
        logger.info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        logger.info("STEP: " + step);
        logger.info("Current URL: " + driver.getCurrentUrl());
        logger.info("Page Title: " + driver.getTitle());
        logger.info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    }

    /**
     * Log element interaction
     */
    public void logElementAction(String action, By locator) {
        logger.info("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
        logger.info("ACTION: " + action);
        logger.info("LOCATOR: " + locator);

        try {
            WebElement element = driver.findElement(locator);
            logger.info("Element Found: YES");
            logger.info("Element Displayed: " + element.isDisplayed());
            logger.info("Element Enabled: " + element.isEnabled());
            logger.info("Element Tag: " + element.getTagName());
            logger.info("Element Text: " + element.getText());
        } catch (Exception e) {
            logger.error("Element Found: NO");
            logger.error("Error: " + e.getMessage());
        }

        logger.info("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    }

    /**
     * Log exception with full context
     */
    public void logException(Exception e) {
        logger.error("â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ");
        logger.error("EXCEPTION OCCURRED");
        logger.error("Type: " + e.getClass().getSimpleName());
        logger.error("Message: " + e.getMessage());
        logger.error("Current URL: " + driver.getCurrentUrl());
        logger.error("Page Title: " + driver.getTitle());
        logger.error("Stack Trace:");

        for (StackTraceElement element : e.getStackTrace()) {
            logger.error("  at " + element.toString());
        }

        logger.error("â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ");
    }
}
```

```java
// 5. Remote Debugging Setup
package debug;

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.chrome.ChromeOptions;

public class RemoteDebuggingSetup {

    /**
     * Enable Chrome remote debugging
     * Access DevTools at: http://localhost:9222
     */
    public static WebDriver createDriverWithRemoteDebugging() {
        ChromeOptions options = new ChromeOptions();

        // Enable remote debugging on port 9222
        options.addArguments("--remote-debugging-port=9222");
        options.addArguments("--remote-debugging-address=0.0.0.0");

        // Keep browser open after test
        options.setExperimentalOption("detach", true);

        WebDriver driver = new ChromeDriver(options);

        System.out.println("Remote debugging enabled on http://localhost:9222");
        System.out.println("Open chrome://inspect in another Chrome window to debug");

        return driver;
    }

    /**
     * Enable verbose Chrome logging
     */
    public static WebDriver createDriverWithVerboseLogging() {
        System.setProperty("webdriver.chrome.verboseLogging", "true");
        System.setProperty("webdriver.chrome.logfile", "target/chromedriver.log");

        ChromeOptions options = new ChromeOptions();
        options.addArguments("--enable-logging");
        options.addArguments("--v=1");

        return new ChromeDriver(options);
    }
}
```

```java
// 6. Interactive Debug Mode
package debug;

import org.openqa.selenium.WebDriver;
import java.util.Scanner;

public class InteractiveDebugger {

    private WebDriver driver;
    private Scanner scanner;

    public InteractiveDebugger(WebDriver driver) {
        this.driver = driver;
        this.scanner = new Scanner(System.in);
    }

    /**
     * Pause execution for manual debugging
     */
    public void pauseForDebug(String message) {
        System.out.println("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        System.out.println("â•‘  DEBUG PAUSE                           â•‘");
        System.out.println("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
        System.out.println("â•‘  " + message);
        System.out.println("â•‘  Current URL: " + driver.getCurrentUrl());
        System.out.println("â•‘  Page Title: " + driver.getTitle());
        System.out.println("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
        System.out.println("â•‘  Press ENTER to continue...            â•‘");
        System.out.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");

        scanner.nextLine();
    }

    /**
     * Add breakpoint with options
     */
    public void breakpoint(String location) {
        System.out.println("\nâ¸ï¸ BREAKPOINT: " + location);
        System.out.println("Options:");
        System.out.println("1. Continue");
        System.out.println("2. Take Screenshot");
        System.out.println("3. Print Page Source");
        System.out.println("4. Print Current URL");
        System.out.println("5. Inspect Element");
        System.out.print("Choice: ");

        int choice = scanner.nextInt();
        scanner.nextLine(); // Consume newline

        switch (choice) {
            case 2:
                new DebugHelper(driver).takeScreenshot("breakpoint_" + location);
                break;
            case 3:
                System.out.println(driver.getPageSource());
                break;
            case 4:
                System.out.println(driver.getCurrentUrl());
                break;
            case 5:
                System.out.print("Enter locator: ");
                String locator = scanner.nextLine();
                // Inspect element logic
                break;
            default:
                System.out.println("Continuing...");
        }
    }
}
```

```java
// 7. Test with Full Debug Support
package tests;

import org.testng.annotations.*;
import org.openqa.selenium.WebDriver;
import debug.*;
import listeners.DebugListener;

@Listeners(DebugListener.class)
public class DebuggableTest {

    private WebDriver driver;
    private DebugHelper debugHelper;
    private DetailedLogger logger;
    private VideoRecorder videoRecorder;

    @BeforeMethod
    public void setup() {
        driver = RemoteDebuggingSetup.createDriverWithRemoteDebugging();
        debugHelper = new DebugHelper(driver);
        logger = new DetailedLogger(driver);
        videoRecorder = new VideoRecorder();

        videoRecorder.startRecording("test");
    }

    @Test
    public void testWithFullDebugging() {
        try {
            logger.logStep("Navigate to application");
            driver.get("https://example.com");

            logger.logElementAction("Click Login", By.id("login"));
            WebElement loginBtn = driver.findElement(By.id("login"));

            // Highlight before clicking (for debugging)
            debugHelper.highlightElement(loginBtn);
            loginBtn.click();

            logger.logStep("Login completed");

        } catch (Exception e) {
            logger.logException(e);
            debugHelper.captureDebugInfo("testWithFullDebugging", e);
            throw e;
        }
    }

    @AfterMethod
    public void teardown() {
        videoRecorder.stopRecording();
        if (driver != null) {
            driver.quit();
        }
    }
}
```

**Follow-up**: How to debug tests running in CI/CD? How to handle intermittent failures? What information is most useful for debugging? How to debug parallel test failures?

---

### Q77: How do you handle SSL certificates and untrusted certificates in Selenium?

**Answer**:
Handling SSL certificates and untrusted certificates is common in test environments where self-signed certificates are used. Selenium provides options to accept insecure certificates, bypass SSL warnings, and handle certificate errors across different browsers. You can configure browser capabilities to ignore certificate errors, handle proxy authentication for SSL, and manage trusted certificate stores. For production-like testing, you should also implement proper SSL validation checks as part of your test suite.

**Experience Level**: 6-8 years, 9-12 years
**Difficulty**: Medium
**Companies**: Amazon, Microsoft, Adobe, Salesforce, Oracle, Banking/Finance companies, Enterprise software companies

**Code Examples**:

```java
// 1. Chrome - Accept Insecure Certificates
public class ChromeSSLHandler {
    public static WebDriver createChromeWithSSL() {
        ChromeOptions options = new ChromeOptions();

        // Accept insecure certificates (Selenium 4+)
        options.setAcceptInsecureCerts(true);

        // Additional SSL-related arguments
        options.addArguments("--ignore-certificate-errors");
        options.addArguments("--ignore-ssl-errors");
        options.addArguments("--allow-insecure-localhost");

        // Disable certificate-related security features
        options.setExperimentalOption("excludeSwitches",
            Collections.singletonList("enable-automation"));

        Map<String, Object> prefs = new HashMap<>();
        prefs.put("safebrowsing.enabled", false);
        options.setExperimentalOption("prefs", prefs);

        return new ChromeDriver(options);
    }

    // Chrome with custom certificate authority
    public static WebDriver createChromeWithCustomCA(String certPath) {
        ChromeOptions options = new ChromeOptions();
        options.setAcceptInsecureCerts(true);

        // Add custom CA certificate
        options.addArguments("--ignore-certificate-errors-spki-list");
        options.addArguments("--user-data-dir=/tmp/chrome-test-profile");

        // Load custom certificate
        File certFile = new File(certPath);
        if (certFile.exists()) {
            options.addArguments("--load-extension=" + certPath);
        }

        return new ChromeDriver(options);
    }
}

// 2. Firefox - Accept Untrusted Certificates
public class FirefoxSSLHandler {
    public static WebDriver createFirefoxWithSSL() {
        FirefoxOptions options = new FirefoxOptions();

        // Accept insecure certificates
        options.setAcceptInsecureCerts(true);

        // Firefox profile preferences
        FirefoxProfile profile = new FirefoxProfile();

        // Accept untrusted certificates
        profile.setAcceptUntrustedCertificates(true);
        profile.setAssumeUntrustedCertificateIssuer(false);

        // Additional SSL preferences
        profile.setPreference("security.tls.version.min", 1);
        profile.setPreference("security.tls.version.max", 3);
        profile.setPreference("security.ssl.enable_ocsp_stapling", false);
        profile.setPreference("security.ssl.enable_false_start", false);

        options.setProfile(profile);

        return new FirefoxDriver(options);
    }

    // Firefox with specific security settings
    public static WebDriver createFirefoxWithSecurityDisabled() {
        FirefoxOptions options = new FirefoxOptions();
        options.setAcceptInsecureCerts(true);

        FirefoxProfile profile = new FirefoxProfile();

        // Disable all security warnings
        profile.setPreference("security.cert_pinning.enforcement_level", 0);
        profile.setPreference("security.fileuri.strict_origin_policy", false);
        profile.setPreference("network.stricttransportsecurity.preloadlist", false);
        profile.setPreference("security.enterprise_roots.enabled", true);

        options.setProfile(profile);

        return new FirefoxDriver(options);
    }
}

// 3. Edge - SSL Certificate Handling
public class EdgeSSLHandler {
    public static WebDriver createEdgeWithSSL() {
        EdgeOptions options = new EdgeOptions();

        // Accept insecure certificates
        options.setAcceptInsecureCerts(true);

        // Edge-specific arguments
        options.addArguments("--ignore-certificate-errors");
        options.addArguments("--ignore-ssl-errors");
        options.addArguments("--allow-insecure-localhost");

        return new EdgeDriver(options);
    }
}

// 4. SSL Handler Utility - Universal Approach
public class SSLCertificateHandler {

    public static WebDriver createDriverWithSSL(String browserName) {
        switch (browserName.toLowerCase()) {
            case "chrome":
                return createChromeWithSSL();
            case "firefox":
                return createFirefoxWithSSL();
            case "edge":
                return createEdgeWithSSL();
            default:
                throw new IllegalArgumentException("Unsupported browser: " + browserName);
        }
    }

    private static WebDriver createChromeWithSSL() {
        ChromeOptions options = new ChromeOptions();
        options.setAcceptInsecureCerts(true);
        options.addArguments("--ignore-certificate-errors");
        return new ChromeDriver(options);
    }

    private static WebDriver createFirefoxWithSSL() {
        FirefoxOptions options = new FirefoxOptions();
        options.setAcceptInsecureCerts(true);
        return new FirefoxDriver(options);
    }

    private static WebDriver createEdgeWithSSL() {
        EdgeOptions options = new EdgeOptions();
        options.setAcceptInsecureCerts(true);
        options.addArguments("--ignore-certificate-errors");
        return new EdgeDriver(options);
    }
}

// 5. SSL Certificate Validation Test
public class SSLValidationTest {
    private WebDriver driver;

    @Test
    public void testSSLCertificateAccepted() {
        // Create driver with SSL handling
        ChromeOptions options = new ChromeOptions();
        options.setAcceptInsecureCerts(true);
        driver = new ChromeDriver(options);

        // Navigate to HTTPS site with self-signed certificate
        driver.get("https://self-signed.badssl.com/");

        // Verify page loaded successfully
        Assert.assertTrue(driver.getTitle().contains("badssl"));

        // Verify no certificate warning displayed
        Assert.assertFalse(driver.getPageSource().contains("Your connection is not private"));
    }

    @Test
    public void testExpiredCertificate() {
        ChromeOptions options = new ChromeOptions();
        options.setAcceptInsecureCerts(true);
        driver = new ChromeDriver(options);

        // Navigate to site with expired certificate
        driver.get("https://expired.badssl.com/");

        // Page should load despite expired certificate
        Assert.assertNotNull(driver.getTitle());
    }

    @Test
    public void testWrongHostCertificate() {
        ChromeOptions options = new ChromeOptions();
        options.setAcceptInsecureCerts(true);
        options.addArguments("--ignore-certificate-errors");
        driver = new ChromeDriver(options);

        // Navigate to site with wrong host certificate
        driver.get("https://wrong.host.badssl.com/");

        // Verify navigation succeeded
        Assert.assertTrue(driver.getCurrentUrl().contains("wrong.host.badssl.com"));
    }

    @AfterMethod
    public void tearDown() {
        if (driver != null) {
            driver.quit();
        }
    }
}

// 6. Framework Integration - SSL Configuration Manager
public class SSLConfigurationManager {
    private static final Logger logger = LogManager.getLogger(SSLConfigurationManager.class);

    public static void configureSSLForEnvironment(String environment, MutableCapabilities options) {
        switch (environment.toLowerCase()) {
            case "dev":
            case "qa":
            case "staging":
                // Accept insecure certificates in non-production
                options.setCapability("acceptInsecureCerts", true);
                logger.info("SSL certificate validation disabled for environment: {}", environment);
                addBrowserSpecificSSLOptions(options);
                break;

            case "prod":
                // Strict SSL validation in production
                options.setCapability("acceptInsecureCerts", false);
                logger.info("SSL certificate validation enabled for production");
                break;

            default:
                logger.warn("Unknown environment: {}, using default SSL settings", environment);
                options.setCapability("acceptInsecureCerts", true);
        }
    }

    private static void addBrowserSpecificSSLOptions(MutableCapabilities options) {
        if (options instanceof ChromeOptions) {
            ChromeOptions chromeOptions = (ChromeOptions) options;
            chromeOptions.addArguments("--ignore-certificate-errors");
            chromeOptions.addArguments("--allow-insecure-localhost");
        } else if (options instanceof FirefoxOptions) {
            FirefoxOptions firefoxOptions = (FirefoxOptions) options;
            FirefoxProfile profile = new FirefoxProfile();
            profile.setAcceptUntrustedCertificates(true);
            firefoxOptions.setProfile(profile);
        }
    }

    public static boolean verifySSLCertificate(String url) {
        try {
            URL siteUrl = new URL(url);
            HttpsURLConnection connection = (HttpsURLConnection) siteUrl.openConnection();
            connection.connect();

            Certificate[] certs = connection.getServerCertificates();

            for (Certificate cert : certs) {
                if (cert instanceof X509Certificate) {
                    X509Certificate x509 = (X509Certificate) cert;

                    // Check if certificate is expired
                    x509.checkValidity();

                    logger.info("Certificate Subject: {}", x509.getSubjectDN());
                    logger.info("Certificate Issuer: {}", x509.getIssuerDN());
                    logger.info("Valid From: {}", x509.getNotBefore());
                    logger.info("Valid Until: {}", x509.getNotAfter());
                }
            }

            connection.disconnect();
            return true;

        } catch (Exception e) {
            logger.error("SSL Certificate validation failed: {}", e.getMessage());
            return false;
        }
    }
}

// 7. Page Object with SSL Handling
public class SecureLoginPage {
    private WebDriver driver;
    private static final String LOGIN_URL = "https://secure-site.example.com/login";

    @FindBy(id = "username")
    private WebElement usernameField;

    @FindBy(id = "password")
    private WebElement passwordField;

    @FindBy(id = "login-button")
    private WebElement loginButton;

    public SecureLoginPage(WebDriver driver) {
        this.driver = driver;
        PageFactory.initElements(driver, this);
    }

    public void navigateToSecureLogin() {
        // Navigate to HTTPS URL
        driver.get(LOGIN_URL);

        // Verify we're on HTTPS
        Assert.assertTrue(driver.getCurrentUrl().startsWith("https://"),
            "Connection is not secure");

        // Wait for page to load
        new WebDriverWait(driver, Duration.ofSeconds(10))
            .until(ExpectedConditions.visibilityOf(usernameField));
    }

    public void login(String username, String password) {
        usernameField.sendKeys(username);
        passwordField.sendKeys(password);
        loginButton.click();
    }

    public boolean isSSLSecure() {
        // Check if connection is secure (browser-specific)
        String url = driver.getCurrentUrl();
        return url.startsWith("https://");
    }
}

// 8. Test with SSL Certificate Verification
@Test
public class SSLSecurityTest {
    private WebDriver driver;
    private SSLConfigurationManager sslConfig;

    @BeforeMethod
    @Parameters({"environment", "browser"})
    public void setUp(String environment, String browser) {
        // Get browser options
        MutableCapabilities options = getBrowserOptions(browser);

        // Configure SSL based on environment
        SSLConfigurationManager.configureSSLForEnvironment(environment, options);

        // Create driver
        driver = createDriver(browser, options);
    }

    @Test
    public void testSecureConnection() {
        // Verify SSL certificate before testing
        String url = "https://example.com";
        boolean certValid = SSLConfigurationManager.verifySSLCertificate(url);

        if (!certValid) {
            logger.warn("SSL certificate validation failed, but continuing with test");
        }

        // Navigate to secure site
        driver.get(url);

        // Verify HTTPS connection
        Assert.assertTrue(driver.getCurrentUrl().startsWith("https://"));

        // Verify no certificate warnings
        Assert.assertFalse(driver.getPageSource().contains("NET::ERR_CERT"));
        Assert.assertFalse(driver.getPageSource().contains("Your connection is not private"));
    }

    @Test(dataProvider = "sslTestSites")
    public void testDifferentSSLScenarios(String url, boolean shouldPass) {
        ChromeOptions options = new ChromeOptions();
        options.setAcceptInsecureCerts(!shouldPass); // Strict for valid certs
        driver = new ChromeDriver(options);

        try {
            driver.get(url);
            Assert.assertTrue(shouldPass, "Expected SSL validation to fail for: " + url);
        } catch (Exception e) {
            Assert.assertFalse(shouldPass, "Expected SSL validation to pass for: " + url);
        }
    }

    @DataProvider(name = "sslTestSites")
    public Object[][] sslTestSites() {
        return new Object[][] {
            {"https://www.google.com", true},           // Valid certificate
            {"https://self-signed.badssl.com", false},  // Self-signed
            {"https://expired.badssl.com", false},      // Expired
            {"https://wrong.host.badssl.com", false}    // Wrong host
        };
    }

    @AfterMethod
    public void tearDown() {
        if (driver != null) {
            driver.quit();
        }
    }

    private MutableCapabilities getBrowserOptions(String browser) {
        switch (browser.toLowerCase()) {
            case "chrome":
                return new ChromeOptions();
            case "firefox":
                return new FirefoxOptions();
            case "edge":
                return new EdgeOptions();
            default:
                throw new IllegalArgumentException("Unsupported browser: " + browser);
        }
    }

    private WebDriver createDriver(String browser, MutableCapabilities options) {
        switch (browser.toLowerCase()) {
            case "chrome":
                return new ChromeDriver((ChromeOptions) options);
            case "firefox":
                return new FirefoxDriver((FirefoxOptions) options);
            case "edge":
                return new EdgeDriver((EdgeOptions) options);
            default:
                throw new IllegalArgumentException("Unsupported browser: " + browser);
        }
    }
}
```

**Follow-up**: What's the difference between setAcceptInsecureCerts() and browser-specific arguments? How do you handle proxy with SSL? How to test SSL certificate expiry? How to handle client certificates?

---

### Q78: How do you handle different types of authentication in Selenium (Basic Auth, NTLM, etc.)?

**Answer**:
Selenium can handle various authentication mechanisms including HTTP Basic Authentication, NTLM (Windows Authentication), OAuth, and form-based authentication. For Basic Auth, you can pass credentials in the URL or use browser capabilities. NTLM requires Windows-specific configurations or browser extensions. OAuth typically involves token management and API integration. Modern approaches use browser DevTools Protocol for authentication, or pre-authenticated sessions with cookies. The choice depends on the application's authentication method and your framework architecture.

**Experience Level**: 6-8 years, 9-12 years
**Difficulty**: Hard
**Companies**: Microsoft, Oracle, SAP, IBM, Banking/Finance companies, Enterprise applications, Government portals

**Code Examples**:

```java
// 1. HTTP Basic Authentication - URL Encoding
public class BasicAuthHandler {

    // Method 1: Credentials in URL
    public static void loginWithBasicAuthURL(WebDriver driver,
            String url, String username, String password) {

        // Format: https://username:password@domain.com
        String[] parts = url.split("://");
        String protocol = parts[0];
        String domain = parts[1];

        String authenticatedURL = protocol + "://" +
            username + ":" + password + "@" + domain;

        driver.get(authenticatedURL);
    }

    // Method 2: Alert-based Basic Auth (older approach)
    public static void loginWithBasicAuthAlert(WebDriver driver,
            String url, String username, String password) {

        driver.get(url);

        // Wait for authentication alert
        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
        Alert authAlert = wait.until(ExpectedConditions.alertIsPresent());

        // This doesn't work directly - alerts can't be typed into
        // This approach is deprecated
    }

    // Method 3: Using Chrome DevTools Protocol (CDP)
    public static void loginWithCDP(ChromeDriver driver,
            String username, String password) {

        // Enable Network domain
        driver.executeCdpCommand("Network.enable", new HashMap<>());

        // Set authentication credentials
        Map<String, Object> credentials = new HashMap<>();
        credentials.put("username", username);
        credentials.put("password", password);

        driver.executeCdpCommand("Network.setExtraHTTPHeaders",
            Collections.singletonMap("headers",
                Collections.singletonMap("Authorization",
                    "Basic " + encodeCredentials(username, password))));
    }

    private static String encodeCredentials(String username, String password) {
        String credentials = username + ":" + password;
        return Base64.getEncoder().encodeToString(credentials.getBytes());
    }
}

// 2. Complete Basic Auth Framework Integration
public class AuthenticationManager {
    private static final Logger logger = LogManager.getLogger(AuthenticationManager.class);

    public static void handleBasicAuth(WebDriver driver,
            String url, String username, String password) {

        try {
            if (driver instanceof ChromeDriver) {
                handleBasicAuthChrome((ChromeDriver) driver, url, username, password);
            } else if (driver instanceof FirefoxDriver) {
                handleBasicAuthFirefox(driver, url, username, password);
            } else {
                // Fallback to URL encoding
                handleBasicAuthURL(driver, url, username, password);
            }
        } catch (Exception e) {
            logger.error("Authentication failed: {}", e.getMessage());
            throw new RuntimeException("Unable to authenticate", e);
        }
    }

    private static void handleBasicAuthChrome(ChromeDriver driver,
            String url, String username, String password) {

        // Use CDP for Chrome
        String encodedAuth = Base64.getEncoder()
            .encodeToString((username + ":" + password).getBytes());

        Map<String, Object> headers = new HashMap<>();
        headers.put("Authorization", "Basic " + encodedAuth);

        driver.executeCdpCommand("Network.enable", new HashMap<>());
        driver.executeCdpCommand("Network.setExtraHTTPHeaders",
            Collections.singletonMap("headers", headers));

        driver.get(url);

        logger.info("Basic Auth successful using CDP");
    }

    private static void handleBasicAuthFirefox(WebDriver driver,
            String url, String username, String password) {

        // Firefox: Use URL encoding
        handleBasicAuthURL(driver, url, username, password);
    }

    private static void handleBasicAuthURL(WebDriver driver,
            String url, String username, String password) {

        // Encode credentials in URL
        String[] parts = url.split("://");
        String authenticatedURL = parts[0] + "://" +
            username + ":" + password + "@" + parts[1];

        driver.get(authenticatedURL);

        // Remove credentials from URL bar (security)
        driver.get(url);

        logger.info("Basic Auth successful using URL encoding");
    }
}

// 3. NTLM Authentication (Windows Authentication)
public class NTLMAuthHandler {

    // Method 1: Using AutoIt for Windows Authentication dialog
    public static void handleNTLMWithAutoIt(WebDriver driver, String url) {
        driver.get(url);

        // Wait for Windows authentication dialog
        try {
            Thread.sleep(2000);

            // Execute AutoIt script to handle Windows auth dialog
            Runtime.getRuntime().exec("path/to/WindowsAuth.exe username password");

            Thread.sleep(2000);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    // Method 2: Using Firefox with NTLM preferences
    public static WebDriver createFirefoxWithNTLM(String domain) {
        FirefoxOptions options = new FirefoxOptions();
        FirefoxProfile profile = new FirefoxProfile();

        // Enable NTLM authentication
        profile.setPreference("network.automatic-ntlm-auth.trusted-uris", domain);
        profile.setPreference("network.automatic-ntlm-auth.allow-non-fqdn", true);
        profile.setPreference("network.negotiate-auth.trusted-uris", domain);
        profile.setPreference("network.negotiate-auth.delegation-uris", domain);
        profile.setPreference("network.http.phishy-userpass-length", 255);

        options.setProfile(profile);

        return new FirefoxDriver(options);
    }

    // Method 3: Using Chrome with Windows SSO
    public static WebDriver createChromeWithNTLM(String domain) {
        ChromeOptions options = new ChromeOptions();

        // Enable Windows authentication
        options.addArguments("--auth-server-whitelist=" + domain);
        options.addArguments("--auth-negotiate-delegate-whitelist=" + domain);

        // Use current Windows credentials
        options.setExperimentalOption("useAutomationExtension", false);

        return new ChromeDriver(options);
    }
}

// 4. OAuth 2.0 Authentication
public class OAuthHandler {
    private static final String CLIENT_ID = "your-client-id";
    private static final String CLIENT_SECRET = "your-client-secret";
    private static final String TOKEN_URL = "https://oauth-provider.com/token";

    public static String getAccessToken(String username, String password) {
        try {
            // Use REST Assured to get OAuth token
            Response response = given()
                .contentType("application/x-www-form-urlencoded")
                .formParam("grant_type", "password")
                .formParam("client_id", CLIENT_ID)
                .formParam("client_secret", CLIENT_SECRET)
                .formParam("username", username)
                .formParam("password", password)
            .when()
                .post(TOKEN_URL)
            .then()
                .statusCode(200)
                .extract().response();

            return response.jsonPath().getString("access_token");

        } catch (Exception e) {
            throw new RuntimeException("Failed to obtain OAuth token", e);
        }
    }

    public static void loginWithOAuth(WebDriver driver, String url, String token) {
        // Method 1: Set token in local storage
        driver.get(url);

        JavascriptExecutor js = (JavascriptExecutor) driver;
        js.executeScript("window.localStorage.setItem('access_token', arguments[0]);", token);

        // Refresh page to use token
        driver.navigate().refresh();
    }

    public static void loginWithOAuthCookie(WebDriver driver,
            String url, String token) {

        // Method 2: Set token as cookie
        driver.get(url);

        Cookie authCookie = new Cookie.Builder("auth_token", token)
            .domain(extractDomain(url))
            .path("/")
            .isSecure(true)
            .isHttpOnly(true)
            .build();

        driver.manage().addCookie(authCookie);

        // Refresh to authenticate
        driver.navigate().refresh();
    }

    private static String extractDomain(String url) {
        try {
            URL parsedUrl = new URL(url);
            return parsedUrl.getHost();
        } catch (MalformedURLException e) {
            throw new RuntimeException("Invalid URL: " + url, e);
        }
    }
}

// 5. Session-Based Authentication (Pre-authenticated cookies)
public class SessionAuthHandler {
    private static final Logger logger = LogManager.getLogger(SessionAuthHandler.class);

    // Get authenticated cookies via API
    public static Set<Cookie> getAuthenticatedCookies(String username, String password) {
        Set<Cookie> cookies = new HashSet<>();

        try {
            // Login via API to get session cookies
            Response response = given()
                .contentType("application/json")
                .body("{\"username\":\"" + username + "\",\"password\":\"" + password + "\"}")
            .when()
                .post("https://api.example.com/login")
            .then()
                .statusCode(200)
                .extract().response();

            // Extract cookies from response
            Map<String, String> apiCookies = response.getCookies();

            for (Map.Entry<String, String> entry : apiCookies.entrySet()) {
                Cookie cookie = new Cookie(entry.getKey(), entry.getValue());
                cookies.add(cookie);
            }

            logger.info("Obtained {} authentication cookies", cookies.size());

        } catch (Exception e) {
            logger.error("Failed to get authenticated cookies: {}", e.getMessage());
        }

        return cookies;
    }

    // Inject pre-authenticated cookies into browser
    public static void injectAuthCookies(WebDriver driver,
            String baseUrl, Set<Cookie> cookies) {

        // Navigate to domain first (required to set cookies)
        driver.get(baseUrl);

        // Inject all authentication cookies
        for (Cookie cookie : cookies) {
            driver.manage().addCookie(cookie);
        }

        logger.info("Injected {} cookies into browser", cookies.size());

        // Refresh to apply authentication
        driver.navigate().refresh();
    }

    // Complete session-based login
    public static void loginWithSession(WebDriver driver,
            String baseUrl, String username, String password) {

        // Get cookies via API
        Set<Cookie> cookies = getAuthenticatedCookies(username, password);

        // Inject cookies into browser
        injectAuthCookies(driver, baseUrl, cookies);

        logger.info("Session-based authentication completed for user: {}", username);
    }
}

// 6. Multi-Factor Authentication (MFA) Handler
public class MFAHandler {
    private static final String TOTP_SECRET = "your-totp-secret";

    public static String generateTOTP() {
        try {
            // Generate time-based one-time password
            TimeBasedOneTimePasswordGenerator totp =
                new TimeBasedOneTimePasswordGenerator();

            Date now = new Date();
            String code = totp.generateOneTimePasswordString(TOTP_SECRET, now);

            return code;

        } catch (Exception e) {
            throw new RuntimeException("Failed to generate TOTP code", e);
        }
    }

    public static void handleMFALogin(WebDriver driver,
            String username, String password) {

        // Step 1: Enter username and password
        driver.findElement(By.id("username")).sendKeys(username);
        driver.findElement(By.id("password")).sendKeys(password);
        driver.findElement(By.id("login-button")).click();

        // Step 2: Wait for MFA page
        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
        WebElement mfaInput = wait.until(
            ExpectedConditions.visibilityOfElementLocated(By.id("mfa-code")));

        // Step 3: Generate and enter TOTP code
        String totpCode = generateTOTP();
        mfaInput.sendKeys(totpCode);

        // Step 4: Submit MFA code
        driver.findElement(By.id("verify-button")).click();
    }
}

// 7. Framework Authentication Factory
public class AuthenticationFactory {
    private static final Logger logger = LogManager.getLogger(AuthenticationFactory.class);

    public enum AuthType {
        BASIC, NTLM, OAUTH, SESSION, MFA, FORM_BASED
    }

    public static void authenticate(WebDriver driver, AuthType authType,
            String url, Map<String, String> credentials) {

        logger.info("Authenticating with {} method", authType);

        switch (authType) {
            case BASIC:
                AuthenticationManager.handleBasicAuth(driver, url,
                    credentials.get("username"), credentials.get("password"));
                break;

            case NTLM:
                WebDriver ntlmDriver = NTLMAuthHandler.createChromeWithNTLM(
                    credentials.get("domain"));
                driver = ntlmDriver;
                driver.get(url);
                break;

            case OAUTH:
                String token = OAuthHandler.getAccessToken(
                    credentials.get("username"), credentials.get("password"));
                OAuthHandler.loginWithOAuth(driver, url, token);
                break;

            case SESSION:
                SessionAuthHandler.loginWithSession(driver, url,
                    credentials.get("username"), credentials.get("password"));
                break;

            case MFA:
                driver.get(url);
                MFAHandler.handleMFALogin(driver,
                    credentials.get("username"), credentials.get("password"));
                break;

            case FORM_BASED:
                handleFormBasedAuth(driver, url, credentials);
                break;

            default:
                throw new IllegalArgumentException("Unsupported auth type: " + authType);
        }

        logger.info("Authentication completed successfully");
    }

    private static void handleFormBasedAuth(WebDriver driver,
            String url, Map<String, String> credentials) {

        driver.get(url);

        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));

        WebElement usernameField = wait.until(
            ExpectedConditions.presenceOfElementLocated(By.id("username")));
        usernameField.sendKeys(credentials.get("username"));

        WebElement passwordField = driver.findElement(By.id("password"));
        passwordField.sendKeys(credentials.get("password"));

        WebElement loginButton = driver.findElement(By.id("login"));
        loginButton.click();
    }
}

// 8. Test Example with Different Auth Types
public class AuthenticationTest {
    private WebDriver driver;

    @Test
    public void testBasicAuthentication() {
        ChromeOptions options = new ChromeOptions();
        driver = new ChromeDriver(options);

        Map<String, String> creds = new HashMap<>();
        creds.put("username", "admin");
        creds.put("password", "admin123");

        AuthenticationFactory.authenticate(driver,
            AuthenticationFactory.AuthType.BASIC,
            "https://the-internet.herokuapp.com/basic_auth",
            creds);

        // Verify authentication succeeded
        Assert.assertTrue(driver.getPageSource()
            .contains("Congratulations"));
    }

    @Test
    public void testOAuthAuthentication() {
        driver = new ChromeDriver();

        Map<String, String> creds = new HashMap<>();
        creds.put("username", "testuser@example.com");
        creds.put("password", "password123");

        AuthenticationFactory.authenticate(driver,
            AuthenticationFactory.AuthType.OAUTH,
            "https://app.example.com",
            creds);

        // Verify logged in
        Assert.assertTrue(driver.getCurrentUrl().contains("/dashboard"));
    }

    @Test
    public void testSessionBasedAuth() {
        driver = new ChromeDriver();

        Map<String, String> creds = new HashMap<>();
        creds.put("username", "testuser");
        creds.put("password", "password123");

        // Faster authentication using session cookies
        AuthenticationFactory.authenticate(driver,
            AuthenticationFactory.AuthType.SESSION,
            "https://app.example.com",
            creds);

        // Verify cookies were set
        Set<Cookie> cookies = driver.manage().getCookies();
        Assert.assertTrue(cookies.size() > 0);

        // Verify authenticated
        Assert.assertFalse(driver.getCurrentUrl().contains("/login"));
    }

    @AfterMethod
    public void tearDown() {
        if (driver != null) {
            driver.quit();
        }
    }
}
```

**Follow-up**: How do you handle certificate-based authentication? How to store credentials securely in framework? How to handle authentication in CI/CD? How to test authentication failures?

---

### Q79: How do you handle file download and file upload in Selenium?

**Answer**:
File download handling in Selenium involves configuring browser preferences to specify download directories, disable download prompts, and verify downloaded files. Different browsers have different configuration methods. File upload is typically handled using sendKeys() on file input elements, but can also use JavaScript, Robot class, or AutoIt for complex scenarios. Verification includes checking file existence, content, size, and format. Modern frameworks integrate with cloud storage and handle downloads in containerized environments.

**Experience Level**: 3-5 years, 6-8 years, 9-12 years
**Difficulty**: Medium
**Companies**: Amazon, Flipkart, Adobe, Oracle, Salesforce, Document management companies, E-commerce companies

**Code Examples**:

```java
// 1. File Download - Chrome Configuration
public class ChromeDownloadHandler {
    private static final String DOWNLOAD_PATH = System.getProperty("user.dir") +
        "/downloads";

    public static WebDriver createChromeForDownload() {
        // Create download directory if it doesn't exist
        new File(DOWNLOAD_PATH).mkdirs();

        ChromeOptions options = new ChromeOptions();

        // Set download preferences
        Map<String, Object> prefs = new HashMap<>();
        prefs.put("download.default_directory", DOWNLOAD_PATH);
        prefs.put("download.prompt_for_download", false);
        prefs.put("download.directory_upgrade", true);
        prefs.put("safebrowsing.enabled", false);
        prefs.put("plugins.always_open_pdf_externally", true); // Download PDF instead of opening

        options.setExperimentalOption("prefs", prefs);

        // Disable download prompt for specific file types
        options.addArguments("--disable-popup-blocking");
        options.addArguments("--disable-extensions");

        return new ChromeDriver(options);
    }

    public static WebDriver createChromeForPDFDownload() {
        ChromeOptions options = new ChromeOptions();

        Map<String, Object> prefs = new HashMap<>();
        prefs.put("download.default_directory", DOWNLOAD_PATH);
        prefs.put("download.prompt_for_download", false);

        // PDF-specific settings
        prefs.put("plugins.always_open_pdf_externally", true);
        prefs.put("plugins.plugins_disabled", Arrays.asList("Chrome PDF Viewer"));

        options.setExperimentalOption("prefs", prefs);

        return new ChromeDriver(options);
    }
}

// 2. File Download - Firefox Configuration
public class FirefoxDownloadHandler {
    private static final String DOWNLOAD_PATH = System.getProperty("user.dir") +
        "/downloads";

    public static WebDriver createFirefoxForDownload() {
        new File(DOWNLOAD_PATH).mkdirs();

        FirefoxOptions options = new FirefoxOptions();
        FirefoxProfile profile = new FirefoxProfile();

        // Set download directory
        profile.setPreference("browser.download.dir", DOWNLOAD_PATH);
        profile.setPreference("browser.download.folderList", 2); // 0=Desktop, 1=Downloads, 2=Custom

        // Disable download prompt
        profile.setPreference("browser.download.manager.showWhenStarting", false);
        profile.setPreference("browser.helperApps.neverAsk.saveToDisk",
            "application/pdf," +
            "application/octet-stream," +
            "application/x-zip-compressed," +
            "application/zip," +
            "text/csv," +
            "text/plain," +
            "application/vnd.ms-excel," +
            "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");

        // PDF settings
        profile.setPreference("pdfjs.disabled", true); // Disable PDF viewer
        profile.setPreference("browser.helperApps.neverAsk.openFile", "application/pdf");

        options.setProfile(profile);

        return new FirefoxDriver(options);
    }
}

// 3. Download Helper Utility
public class DownloadHelper {
    private static final Logger logger = LogManager.getLogger(DownloadHelper.class);
    private static final int TIMEOUT_SECONDS = 60;

    // Wait for file download to complete
    public static boolean waitForDownload(String fileName, int timeoutSeconds) {
        String downloadPath = System.getProperty("user.dir") + "/downloads/" + fileName;
        File file = new File(downloadPath);

        int elapsed = 0;
        while (elapsed < timeoutSeconds) {
            if (file.exists() && !isFileDownloading(downloadPath)) {
                logger.info("File downloaded successfully: {}", fileName);
                return true;
            }

            try {
                Thread.sleep(1000);
                elapsed++;
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                return false;
            }
        }

        logger.error("File download timeout: {}", fileName);
        return false;
    }

    // Check if file is still downloading (check for .crdownload or .part extension)
    private static boolean isFileDownloading(String filePath) {
        File chromeTemp = new File(filePath + ".crdownload"); // Chrome temp
        File firefoxTemp = new File(filePath + ".part");       // Firefox temp

        return chromeTemp.exists() || firefoxTemp.exists();
    }

    // Get most recently downloaded file
    public static File getLatestDownloadedFile(String downloadDir) {
        File dir = new File(downloadDir);
        File[] files = dir.listFiles();

        if (files == null || files.length == 0) {
            return null;
        }

        File lastModified = files[0];
        for (File file : files) {
            if (file.lastModified() > lastModified.lastModified() &&
                !file.getName().endsWith(".crdownload") &&
                !file.getName().endsWith(".part")) {
                lastModified = file;
            }
        }

        return lastModified;
    }

    // Verify downloaded file
    public static boolean verifyDownload(String fileName) {
        String filePath = System.getProperty("user.dir") + "/downloads/" + fileName;
        File file = new File(filePath);

        if (!file.exists()) {
            logger.error("File does not exist: {}", fileName);
            return false;
        }

        if (file.length() == 0) {
            logger.error("File is empty: {}", fileName);
            return false;
        }

        logger.info("File verified - Size: {} bytes", file.length());
        return true;
    }

    // Clean up downloads directory
    public static void cleanDownloadsDirectory() {
        String downloadPath = System.getProperty("user.dir") + "/downloads";
        File dir = new File(downloadPath);

        if (dir.exists()) {
            File[] files = dir.listFiles();
            if (files != null) {
                for (File file : files) {
                    if (file.delete()) {
                        logger.info("Deleted file: {}", file.getName());
                    }
                }
            }
        }
    }

    // Read file content
    public static String readFileContent(String fileName) throws IOException {
        String filePath = System.getProperty("user.dir") + "/downloads/" + fileName;
        return new String(Files.readAllBytes(Paths.get(filePath)));
    }
}

// 4. File Upload Handler
public class FileUploadHandler {
    private static final Logger logger = LogManager.getLogger(FileUploadHandler.class);

    // Method 1: Standard file upload using sendKeys
    public static void uploadFile(WebDriver driver, By fileInputLocator, String filePath) {
        File file = new File(filePath);

        if (!file.exists()) {
            throw new RuntimeException("File not found: " + filePath);
        }

        // Find file input element
        WebElement fileInput = driver.findElement(fileInputLocator);

        // Send absolute file path
        fileInput.sendKeys(file.getAbsolutePath());

        logger.info("File uploaded: {}", filePath);
    }

    // Method 2: Upload with JavaScript (for hidden file inputs)
    public static void uploadFileWithJS(WebDriver driver, By fileInputLocator, String filePath) {
        File file = new File(filePath);

        if (!file.exists()) {
            throw new RuntimeException("File not found: " + filePath);
        }

        WebElement fileInput = driver.findElement(fileInputLocator);

        // Make file input visible if hidden
        JavascriptExecutor js = (JavascriptExecutor) driver;
        js.executeScript("arguments[0].style.display = 'block';", fileInput);
        js.executeScript("arguments[0].style.visibility = 'visible';", fileInput);

        // Upload file
        fileInput.sendKeys(file.getAbsolutePath());

        logger.info("File uploaded using JavaScript: {}", filePath);
    }

    // Method 3: Handle drag-and-drop file upload using JavaScript
    public static void dragAndDropUpload(WebDriver driver, By dropZoneLocator, String filePath) {
        File file = new File(filePath);

        if (!file.exists()) {
            throw new RuntimeException("File not found: " + filePath);
        }

        WebElement dropZone = driver.findElement(dropZoneLocator);

        // JavaScript to simulate drag and drop
        String jsScript =
            "var target = arguments[0];" +
            "var file = arguments[1];" +
            "var dt = new DataTransfer();" +
            "dt.items.add(new File([file], 'filename'));" +
            "var event = new DragEvent('drop', {dataTransfer: dt});" +
            "target.dispatchEvent(event);";

        JavascriptExecutor js = (JavascriptExecutor) driver;

        try {
            String fileContent = new String(Files.readAllBytes(Paths.get(file.getAbsolutePath())));
            js.executeScript(jsScript, dropZone, fileContent);
            logger.info("File drag-and-drop upload completed: {}", filePath);
        } catch (IOException e) {
            logger.error("Failed to read file for upload: {}", e.getMessage());
        }
    }

    // Method 4: Using Robot class (for Windows file dialog)
    public static void uploadFileWithRobot(String filePath) {
        try {
            // Copy file path to clipboard
            StringSelection stringSelection = new StringSelection(filePath);
            Toolkit.getDefaultToolkit().getSystemClipboard()
                .setContents(stringSelection, null);

            Robot robot = new Robot();

            // Press Ctrl+V to paste file path
            robot.keyPress(KeyEvent.VK_CONTROL);
            robot.keyPress(KeyEvent.VK_V);
            robot.keyRelease(KeyEvent.VK_V);
            robot.keyRelease(KeyEvent.VK_CONTROL);

            Thread.sleep(500);

            // Press Enter to confirm
            robot.keyPress(KeyEvent.VK_ENTER);
            robot.keyRelease(KeyEvent.VK_ENTER);

            logger.info("File uploaded using Robot class: {}", filePath);

        } catch (Exception e) {
            logger.error("Robot upload failed: {}", e.getMessage());
        }
    }

    // Verify file upload success
    public static boolean verifyFileUpload(WebDriver driver, By uploadedFileLocator,
            String expectedFileName) {

        try {
            WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
            WebElement uploadedFile = wait.until(
                ExpectedConditions.presenceOfElementLocated(uploadedFileLocator));

            String uploadedText = uploadedFile.getText();

            if (uploadedText.contains(expectedFileName)) {
                logger.info("File upload verified: {}", expectedFileName);
                return true;
            }

        } catch (Exception e) {
            logger.error("Upload verification failed: {}", e.getMessage());
        }

        return false;
    }
}

// 5. Complete Download Test Example
public class DownloadTest {
    private WebDriver driver;
    private static final String DOWNLOAD_DIR = System.getProperty("user.dir") + "/downloads";

    @BeforeMethod
    public void setUp() {
        // Clean downloads directory before test
        DownloadHelper.cleanDownloadsDirectory();

        // Create driver configured for download
        driver = ChromeDownloadHandler.createChromeForDownload();
    }

    @Test
    public void testFileDownload() {
        String fileName = "sample.pdf";

        // Navigate to download page
        driver.get("https://file-examples.com/");

        // Click download button
        driver.findElement(By.linkText("Download Sample PDF")).click();

        // Wait for download to complete
        boolean downloaded = DownloadHelper.waitForDownload(fileName, 30);
        Assert.assertTrue(downloaded, "File download failed");

        // Verify file
        boolean verified = DownloadHelper.verifyDownload(fileName);
        Assert.assertTrue(verified, "File verification failed");
    }

    @Test
    public void testCSVDownload() {
        String fileName = "data.csv";

        driver.get("https://example.com/download");
        driver.findElement(By.id("download-csv")).click();

        // Wait and verify
        DownloadHelper.waitForDownload(fileName, 30);

        // Read and validate CSV content
        try {
            String content = DownloadHelper.readFileContent(fileName);
            Assert.assertTrue(content.contains("Name,Email,Phone"));
        } catch (IOException e) {
            Assert.fail("Failed to read CSV file");
        }
    }

    @Test
    public void testMultipleDownloads() {
        driver.get("https://example.com/downloads");

        // Download multiple files
        List<String> fileNames = Arrays.asList("file1.pdf", "file2.xlsx", "file3.zip");

        for (String fileName : fileNames) {
            driver.findElement(By.linkText(fileName)).click();
            DownloadHelper.waitForDownload(fileName, 30);
        }

        // Verify all files downloaded
        for (String fileName : fileNames) {
            Assert.assertTrue(DownloadHelper.verifyDownload(fileName));
        }
    }

    @AfterMethod
    public void tearDown() {
        if (driver != null) {
            driver.quit();
        }

        // Optional: Clean up after test
        // DownloadHelper.cleanDownloadsDirectory();
    }
}

// 6. Complete Upload Test Example
public class UploadTest {
    private WebDriver driver;
    private static final String TEST_FILE_PATH = System.getProperty("user.dir") +
        "/test-data/sample.pdf";

    @BeforeMethod
    public void setUp() {
        driver = new ChromeDriver();
    }

    @Test
    public void testFileUpload() {
        driver.get("https://the-internet.herokuapp.com/upload");

        // Upload file
        FileUploadHandler.uploadFile(driver, By.id("file-upload"), TEST_FILE_PATH);

        // Click submit
        driver.findElement(By.id("file-submit")).click();

        // Verify upload
        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
        WebElement uploadedFile = wait.until(
            ExpectedConditions.presenceOfElementLocated(By.id("uploaded-files")));

        Assert.assertTrue(uploadedFile.getText().contains("sample.pdf"));
    }

    @Test
    public void testImageUpload() {
        driver.get("https://imgbb.com/");

        String imagePath = System.getProperty("user.dir") + "/test-data/image.jpg";

        // Upload image
        FileUploadHandler.uploadFile(driver, By.name("source"), imagePath);

        // Wait for upload to process
        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(30));
        WebElement uploadSuccess = wait.until(
            ExpectedConditions.presenceOfElementLocated(By.className("upload-success")));

        Assert.assertTrue(uploadSuccess.isDisplayed());
    }

    @Test
    public void testMultipleFileUpload() {
        driver.get("https://blueimp.github.io/jQuery-File-Upload/");

        List<String> filePaths = Arrays.asList(
            System.getProperty("user.dir") + "/test-data/file1.txt",
            System.getProperty("user.dir") + "/test-data/file2.txt"
        );

        // Upload multiple files (if input supports multiple)
        WebElement fileInput = driver.findElement(By.xpath("//input[@type='file']"));
        String files = String.join("\n", filePaths);
        fileInput.sendKeys(files);

        // Verify uploads
        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
        List<WebElement> uploadedFiles = wait.until(
            ExpectedConditions.numberOfElementsToBeMoreThan(
                By.className("template-upload"), 1));

        Assert.assertEquals(uploadedFiles.size(), 2);
    }

    @AfterMethod
    public void tearDown() {
        if (driver != null) {
            driver.quit();
        }
    }
}

// 7. Page Object with Download/Upload
public class DocumentManagementPage {
    private WebDriver driver;
    private DownloadHelper downloadHelper;
    private FileUploadHandler uploadHandler;

    @FindBy(id = "file-upload-input")
    private WebElement fileUploadInput;

    @FindBy(id = "upload-button")
    private WebElement uploadButton;

    @FindBy(linkText = "Download Document")
    private WebElement downloadLink;

    @FindBy(className = "uploaded-file-name")
    private WebElement uploadedFileName;

    public DocumentManagementPage(WebDriver driver) {
        this.driver = driver;
        PageFactory.initElements(driver, this);
        this.downloadHelper = new DownloadHelper();
        this.uploadHandler = new FileUploadHandler();
    }

    public void uploadDocument(String filePath) {
        FileUploadHandler.uploadFile(driver, By.id("file-upload-input"), filePath);
        uploadButton.click();
    }

    public boolean verifyUploadSuccess(String fileName) {
        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
        wait.until(ExpectedConditions.visibilityOf(uploadedFileName));
        return uploadedFileName.getText().contains(fileName);
    }

    public boolean downloadDocument(String fileName) {
        downloadLink.click();
        return DownloadHelper.waitForDownload(fileName, 30);
    }
}
```

**Follow-up**: How to handle file download in headless mode? How to download files in Docker containers? How to handle large file uploads? How to verify downloaded file content?

---

### Q80: How do you handle browser notifications, popups, and permissions in Selenium?

**Answer**:
Browser notifications and permissions dialogs can interrupt test execution if not handled properly. Selenium provides browser-specific capabilities to disable notifications, allow/block location access, camera, microphone, and other permissions. Modern browsers require explicit configuration to handle these automatically. You can set default permissions, handle permission prompts via browser options, or use Chrome DevTools Protocol for advanced control. Proper handling ensures stable test execution without manual intervention.

**Experience Level**: 3-5 years, 6-8 years, 9-12 years
**Difficulty**: Medium
**Companies**: Google, Facebook, Uber, Zomato, Location-based applications, Media streaming companies

**Code Examples**:

```java
// 1. Chrome - Disable Notifications and Handle Permissions
public class ChromeNotificationHandler {

    public static WebDriver createChromeWithNotificationsDisabled() {
        ChromeOptions options = new ChromeOptions();

        // Disable browser notifications
        options.addArguments("--disable-notifications");

        // Disable popup blocking
        options.addArguments("--disable-popup-blocking");

        // Set notification preference
        Map<String, Object> prefs = new HashMap<>();
        prefs.put("profile.default_content_setting_values.notifications", 2); // 1=Allow, 2=Block

        options.setExperimentalOption("prefs", prefs);

        return new ChromeDriver(options);
    }

    public static WebDriver createChromeWithAllPermissions() {
        ChromeOptions options = new ChromeOptions();

        Map<String, Object> prefs = new HashMap<>();

        // Notifications - 1=Allow, 2=Block
        prefs.put("profile.default_content_setting_values.notifications", 1);

        // Geolocation - 1=Allow, 2=Block
        prefs.put("profile.default_content_setting_values.geolocation", 1);

        // Media stream (Camera/Microphone) - 1=Allow, 2=Block
        prefs.put("profile.default_content_setting_values.media_stream_camera", 1);
        prefs.put("profile.default_content_setting_values.media_stream_mic", 1);

        // Automatic downloads
        prefs.put("profile.default_content_setting_values.automatic_downloads", 1);

        // Cookies
        prefs.put("profile.default_content_setting_values.cookies", 1);

        // Images
        prefs.put("profile.default_content_setting_values.images", 1);

        // JavaScript
        prefs.put("profile.default_content_setting_values.javascript", 1);

        // Popups
        prefs.put("profile.default_content_setting_values.popups", 1);

        options.setExperimentalOption("prefs", prefs);

        return new ChromeDriver(options);
    }

    public static WebDriver createChromeWithCustomPermissions(
            Map<String, Integer> permissions) {

        ChromeOptions options = new ChromeOptions();

        Map<String, Object> prefs = new HashMap<>();

        for (Map.Entry<String, Integer> entry : permissions.entrySet()) {
            String key = "profile.default_content_setting_values." + entry.getKey();
            prefs.put(key, entry.getValue());
        }

        options.setExperimentalOption("prefs", prefs);

        return new ChromeDriver(options);
    }
}

// 2. Firefox - Handle Notifications and Permissions
public class FirefoxNotificationHandler {

    public static WebDriver createFirefoxWithNotificationsDisabled() {
        FirefoxOptions options = new FirefoxOptions();
        FirefoxProfile profile = new FirefoxProfile();

        // Disable notifications - 1=Allow, 2=Block, 3=Always Ask
        profile.setPreference("permissions.default.desktop-notification", 2);

        // Disable popup blocker
        profile.setPreference("dom.popup_maximum", 0);
        profile.setPreference("privacy.popups.showBrowserMessage", false);

        options.setProfile(profile);

        return new FirefoxDriver(options);
    }

    public static WebDriver createFirefoxWithGeolocation() {
        FirefoxOptions options = new FirefoxOptions();
        FirefoxProfile profile = new FirefoxProfile();

        // Allow geolocation
        profile.setPreference("geo.enabled", true);
        profile.setPreference("geo.prompt.testing", true);
        profile.setPreference("geo.prompt.testing.allow", true);

        // Set fake geolocation
        profile.setPreference("geo.wifi.uri", "data:application/json,{" +
            "\"location\": {\"lat\": 37.7749, \"lng\": -122.4194}, " +
            "\"accuracy\": 100.0}");

        options.setProfile(profile);

        return new FirefoxDriver(options);
    }

    public static WebDriver createFirefoxWithAllPermissions() {
        FirefoxOptions options = new FirefoxOptions();
        FirefoxProfile profile = new FirefoxProfile();

        // Notifications
        profile.setPreference("permissions.default.desktop-notification", 1);

        // Geolocation
        profile.setPreference("geo.enabled", true);
        profile.setPreference("geo.prompt.testing", true);
        profile.setPreference("geo.prompt.testing.allow", true);

        // Camera and Microphone
        profile.setPreference("permissions.default.camera", 1);
        profile.setPreference("permissions.default.microphone", 1);
        profile.setPreference("media.navigator.permission.disabled", true);

        // Popups
        profile.setPreference("dom.disable_open_during_load", false);

        options.setProfile(profile);

        return new FirefoxDriver(options);
    }
}

// 3. Permission Handler Utility
public class PermissionHandler {
    private static final Logger logger = LogManager.getLogger(PermissionHandler.class);

    public enum Permission {
        NOTIFICATIONS("notifications"),
        GEOLOCATION("geolocation"),
        CAMERA("media_stream_camera"),
        MICROPHONE("media_stream_mic"),
        POPUPS("popups"),
        DOWNLOADS("automatic_downloads"),
        COOKIES("cookies"),
        IMAGES("images"),
        JAVASCRIPT("javascript");

        private final String key;

        Permission(String key) {
            this.key = key;
        }

        public String getKey() {
            return key;
        }
    }

    public static WebDriver createDriverWithPermissions(String browser,
            Map<Permission, Boolean> permissions) {

        switch (browser.toLowerCase()) {
            case "chrome":
                return createChromeWithPermissions(permissions);
            case "firefox":
                return createFirefoxWithPermissions(permissions);
            default:
                throw new IllegalArgumentException("Unsupported browser: " + browser);
        }
    }

    private static WebDriver createChromeWithPermissions(Map<Permission, Boolean> permissions) {
        ChromeOptions options = new ChromeOptions();
        Map<String, Object> prefs = new HashMap<>();

        for (Map.Entry<Permission, Boolean> entry : permissions.entrySet()) {
            String key = "profile.default_content_setting_values." + entry.getKey().getKey();
            int value = entry.getValue() ? 1 : 2; // 1=Allow, 2=Block
            prefs.put(key, value);
            logger.info("Set permission {} = {}", entry.getKey(), value);
        }

        options.setExperimentalOption("prefs", prefs);
        options.addArguments("--disable-popup-blocking");

        return new ChromeDriver(options);
    }

    private static WebDriver createFirefoxWithPermissions(Map<Permission, Boolean> permissions) {
        FirefoxOptions options = new FirefoxOptions();
        FirefoxProfile profile = new FirefoxProfile();

        for (Map.Entry<Permission, Boolean> entry : permissions.entrySet()) {
            Permission perm = entry.getKey();
            boolean allow = entry.getValue();

            switch (perm) {
                case NOTIFICATIONS:
                    profile.setPreference("permissions.default.desktop-notification", allow ? 1 : 2);
                    break;
                case GEOLOCATION:
                    profile.setPreference("geo.enabled", allow);
                    profile.setPreference("geo.prompt.testing.allow", allow);
                    break;
                case CAMERA:
                    profile.setPreference("permissions.default.camera", allow ? 1 : 2);
                    break;
                case MICROPHONE:
                    profile.setPreference("permissions.default.microphone", allow ? 1 : 2);
                    break;
                case POPUPS:
                    profile.setPreference("dom.disable_open_during_load", !allow);
                    break;
            }

            logger.info("Set permission {} = {}", perm, allow);
        }

        options.setProfile(profile);

        return new FirefoxDriver(options);
    }
}

// 4. Geolocation Handler with Chrome DevTools Protocol
public class GeolocationHandler {

    public static void setGeolocation(ChromeDriver driver, double latitude, double longitude) {
        Map<String, Object> coordinates = new HashMap<>();
        coordinates.put("latitude", latitude);
        coordinates.put("longitude", longitude);
        coordinates.put("accuracy", 1);

        driver.executeCdpCommand("Emulation.setGeolocationOverride", coordinates);
    }

    public static void setGeolocationSanFrancisco(ChromeDriver driver) {
        setGeolocation(driver, 37.7749, -122.4194);
    }

    public static void setGeolocationNewYork(ChromeDriver driver) {
        setGeolocation(driver, 40.7128, -74.0060);
    }

    public static void setGeolocationLondon(ChromeDriver driver) {
        setGeolocation(driver, 51.5074, -0.1278);
    }

    public static void clearGeolocation(ChromeDriver driver) {
        driver.executeCdpCommand("Emulation.clearGeolocationOverride", new HashMap<>());
    }
}

// 5. Popup Window Handler
public class PopupHandler {
    private static final Logger logger = LogManager.getLogger(PopupHandler.class);

    public static void handlePopupWindow(WebDriver driver) {
        String mainWindow = driver.getWindowHandle();

        // Wait for popup to appear
        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
        wait.until(ExpectedConditions.numberOfWindowsToBe(2));

        // Get all window handles
        Set<String> windows = driver.getWindowHandles();

        // Switch to popup
        for (String window : windows) {
            if (!window.equals(mainWindow)) {
                driver.switchTo().window(window);
                logger.info("Switched to popup window");
                break;
            }
        }
    }

    public static void closePopupAndReturnToMain(WebDriver driver, String mainWindow) {
        // Close current popup
        driver.close();

        // Switch back to main window
        driver.switchTo().window(mainWindow);

        logger.info("Closed popup and returned to main window");
    }

    public static void handleAllPopups(WebDriver driver) {
        String mainWindow = driver.getWindowHandle();
        Set<String> allWindows = driver.getWindowHandles();

        // Close all windows except main
        for (String window : allWindows) {
            if (!window.equals(mainWindow)) {
                driver.switchTo().window(window);
                driver.close();
                logger.info("Closed popup window: {}", window);
            }
        }

        // Return to main window
        driver.switchTo().window(mainWindow);
    }
}

// 6. Browser Notification Test
public class NotificationTest {
    private WebDriver driver;

    @Test
    public void testNotificationsBlocked() {
        // Create driver with notifications blocked
        driver = ChromeNotificationHandler.createChromeWithNotificationsDisabled();

        // Navigate to site that requests notifications
        driver.get("https://www.bennish.net/web-notifications.html");

        // Try to trigger notification
        driver.findElement(By.id("enable")).click();

        // Verify no notification permission dialog appeared
        // (no alert or permission popup)
        Assert.assertEquals(driver.getWindowHandles().size(), 1);
    }

    @Test
    public void testNotificationsAllowed() {
        // Create driver with notifications allowed
        ChromeOptions options = new ChromeOptions();
        Map<String, Object> prefs = new HashMap<>();
        prefs.put("profile.default_content_setting_values.notifications", 1);
        options.setExperimentalOption("prefs", prefs);

        driver = new ChromeDriver(options);

        driver.get("https://www.bennish.net/web-notifications.html");
        driver.findElement(By.id("enable")).click();

        // Verify notifications are enabled
        String notificationStatus = driver.findElement(By.id("status")).getText();
        Assert.assertTrue(notificationStatus.contains("granted"));
    }

    @AfterMethod
    public void tearDown() {
        if (driver != null) {
            driver.quit();
        }
    }
}

// 7. Geolocation Test
public class GeolocationTest {
    private ChromeDriver driver;

    @Test
    public void testGeolocationSanFrancisco() {
        ChromeOptions options = new ChromeOptions();
        Map<String, Object> prefs = new HashMap<>();
        prefs.put("profile.default_content_setting_values.geolocation", 1);
        options.setExperimentalOption("prefs", prefs);

        driver = new ChromeDriver(options);

        // Set geolocation to San Francisco
        GeolocationHandler.setGeolocationSanFrancisco(driver);

        // Navigate to site that uses geolocation
        driver.get("https://www.where-am-i.net/");

        // Wait for location to load
        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
        wait.until(ExpectedConditions.presenceOfElementLocated(By.className("location")));

        // Verify location
        String location = driver.findElement(By.className("location")).getText();
        Assert.assertTrue(location.contains("San Francisco") ||
                         location.contains("37.77"));
    }

    @Test
    public void testGeolocationChange() {
        ChromeOptions options = new ChromeOptions();
        Map<String, Object> prefs = new HashMap<>();
        prefs.put("profile.default_content_setting_values.geolocation", 1);
        options.setExperimentalOption("prefs", prefs);

        driver = new ChromeDriver(options);

        // Set initial location
        GeolocationHandler.setGeolocationNewYork(driver);
        driver.get("https://www.where-am-i.net/");

        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
        wait.until(ExpectedConditions.presenceOfElementLocated(By.className("location")));

        String location1 = driver.findElement(By.className("location")).getText();

        // Change location
        GeolocationHandler.setGeolocationLondon(driver);
        driver.navigate().refresh();

        wait.until(ExpectedConditions.presenceOfElementLocated(By.className("location")));
        String location2 = driver.findElement(By.className("location")).getText();

        // Verify locations are different
        Assert.assertNotEquals(location1, location2);
    }

    @AfterMethod
    public void tearDown() {
        if (driver != null) {
            driver.quit();
        }
    }
}

// 8. Comprehensive Permission Configuration
public class PermissionConfigTest {
    private WebDriver driver;

    @Test
    public void testAllPermissionsConfigured() {
        // Configure all permissions
        Map<PermissionHandler.Permission, Boolean> permissions = new HashMap<>();
        permissions.put(PermissionHandler.Permission.NOTIFICATIONS, false);
        permissions.put(PermissionHandler.Permission.GEOLOCATION, true);
        permissions.put(PermissionHandler.Permission.CAMERA, false);
        permissions.put(PermissionHandler.Permission.MICROPHONE, false);
        permissions.put(PermissionHandler.Permission.POPUPS, false);

        driver = PermissionHandler.createDriverWithPermissions("chrome", permissions);

        // Navigate to test site
        driver.get("https://permission.site/");

        // Verify permissions are set correctly
        // Test notification permission
        driver.get("https://permission.site/en/notifications");
        Assert.assertTrue(driver.getPageSource().contains("denied") ||
                         !driver.getPageSource().contains("permission-prompt"));
    }

    @AfterMethod
    public void tearDown() {
        if (driver != null) {
            driver.quit();
        }
    }
}
```

**Follow-up**: How to handle camera/microphone permissions? How to test notification functionality? How to handle permission prompts in mobile browsers? How to verify geolocation accuracy?


---

### Q81: How do you perform mobile web testing on desktop browsers using Selenium?

**Answer**:
Mobile web testing on desktop browsers simulates mobile devices by emulating device characteristics like screen size, user agent, touch events, and device orientation. Selenium supports mobile emulation through ChromeOptions and FirefoxOptions, allowing you to test responsive designs without real devices. You can emulate specific devices (iPhone, iPad, Android), test different screen resolutions, simulate touch events, and verify mobile-specific behaviors. This approach is faster and more cost-effective than physical device testing for initial testing phases.

**Experience Level**: 3-5 years, 6-8 years, 9-12 years
**Difficulty**: Medium
**Companies**: Flipkart, Amazon, Google, Facebook, Mobile-first applications, E-commerce companies

**Code Examples**:

```java
// 1. Chrome Mobile Emulation - Specific Devices
public class ChromeMobileEmulation {

    public static WebDriver createChromeAsIPhone() {
        ChromeOptions options = new ChromeOptions();

        Map<String, String> mobileEmulation = new HashMap<>();
        mobileEmulation.put("deviceName", "iPhone 12 Pro");

        options.setExperimentalOption("mobileEmulation", mobileEmulation);

        return new ChromeDriver(options);
    }

    public static WebDriver createChromeAsIPad() {
        ChromeOptions options = new ChromeOptions();

        Map<String, String> mobileEmulation = new HashMap<>();
        mobileEmulation.put("deviceName", "iPad Pro");

        options.setExperimentalOption("mobileEmulation", mobileEmulation);

        return new ChromeDriver(options);
    }

    public static WebDriver createChromeAsPixel5() {
        ChromeOptions options = new ChromeOptions();

        Map<String, String> mobileEmulation = new HashMap<>();
        mobileEmulation.put("deviceName", "Pixel 5");

        options.setExperimentalOption("mobileEmulation", mobileEmulation);

        return new ChromeDriver(options);
    }

    public static WebDriver createChromeAsGalaxyS20() {
        ChromeOptions options = new ChromeOptions();

        Map<String, String> mobileEmulation = new HashMap<>();
        mobileEmulation.put("deviceName", "Samsung Galaxy S20 Ultra");

        options.setExperimentalOption("mobileEmulation", mobileEmulation);

        return new ChromeDriver(options);
    }
}

// 2. Chrome Mobile Emulation - Custom Device Metrics
public class CustomMobileEmulation {

    public static WebDriver createChromeWithCustomDevice(int width, int height, double pixelRatio) {
        ChromeOptions options = new ChromeOptions();

        Map<String, Object> deviceMetrics = new HashMap<>();
        deviceMetrics.put("width", width);
        deviceMetrics.put("height", height);
        deviceMetrics.put("pixelRatio", pixelRatio);

        Map<String, Object> mobileEmulation = new HashMap<>();
        mobileEmulation.put("deviceMetrics", deviceMetrics);
        mobileEmulation.put("userAgent", "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.91 Mobile Safari/537.36");

        options.setExperimentalOption("mobileEmulation", mobileEmulation);

        return new ChromeDriver(options);
    }

    // Common mobile resolutions
    public static WebDriver createIPhoneSEEmulation() {
        return createChromeWithCustomDevice(375, 667, 2.0);
    }

    public static WebDriver createIPhone12ProEmulation() {
        return createChromeWithCustomDevice(390, 844, 3.0);
    }

    public static WebDriver createIPadAirEmulation() {
        return createChromeWithCustomDevice(820, 1180, 2.0);
    }

    public static WebDriver createGalaxyS21Emulation() {
        return createChromeWithCustomDevice(360, 800, 3.0);
    }
}

// 3. Firefox Mobile Emulation
public class FirefoxMobileEmulation {

    public static WebDriver createFirefoxAsIPhone() {
        FirefoxOptions options = new FirefoxOptions();
        FirefoxProfile profile = new FirefoxProfile();

        // Set iPhone user agent
        String iPhoneUserAgent = "Mozilla/5.0 (iPhone; CPU iPhone OS 14_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Mobile/15E148 Safari/604.1";
        profile.setPreference("general.useragent.override", iPhoneUserAgent);

        // Set viewport size
        options.addArguments("--width=375");
        options.addArguments("--height=667");

        options.setProfile(profile);

        return new FirefoxDriver(options);
    }

    public static WebDriver createFirefoxAsAndroid() {
        FirefoxOptions options = new FirefoxOptions();
        FirefoxProfile profile = new FirefoxProfile();

        // Set Android user agent
        String androidUserAgent = "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.91 Mobile Safari/537.36";
        profile.setPreference("general.useragent.override", androidUserAgent);

        // Set viewport size
        options.addArguments("--width=360");
        options.addArguments("--height=800");

        options.setProfile(profile);

        return new FirefoxDriver(options);
    }
}

// 4. Mobile Emulation Factory
public class MobileEmulationFactory {
    private static final Logger logger = LogManager.getLogger(MobileEmulationFactory.class);

    public enum MobileDevice {
        IPHONE_SE("iPhone SE", 375, 667, 2.0),
        IPHONE_12_PRO("iPhone 12 Pro", 390, 844, 3.0),
        IPHONE_14_PRO_MAX("iPhone 14 Pro Max", 430, 932, 3.0),
        IPAD_AIR("iPad Air", 820, 1180, 2.0),
        IPAD_PRO("iPad Pro", 1024, 1366, 2.0),
        PIXEL_5("Pixel 5", 393, 851, 2.75),
        GALAXY_S21("Samsung Galaxy S21", 360, 800, 3.0),
        GALAXY_TAB("Samsung Galaxy Tab", 800, 1280, 2.0);

        private final String name;
        private final int width;
        private final int height;
        private final double pixelRatio;

        MobileDevice(String name, int width, int height, double pixelRatio) {
            this.name = name;
            this.width = width;
            this.height = height;
            this.pixelRatio = pixelRatio;
        }

        public String getName() { return name; }
        public int getWidth() { return width; }
        public int getHeight() { return height; }
        public double getPixelRatio() { return pixelRatio; }
    }

    public static WebDriver createMobileEmulation(MobileDevice device) {
        logger.info("Creating mobile emulation for: {}", device.getName());

        ChromeOptions options = new ChromeOptions();

        Map<String, Object> deviceMetrics = new HashMap<>();
        deviceMetrics.put("width", device.getWidth());
        deviceMetrics.put("height", device.getHeight());
        deviceMetrics.put("pixelRatio", device.getPixelRatio());

        Map<String, Object> mobileEmulation = new HashMap<>();
        mobileEmulation.put("deviceMetrics", deviceMetrics);
        mobileEmulation.put("userAgent", getUserAgent(device));

        options.setExperimentalOption("mobileEmulation", mobileEmulation);

        return new ChromeDriver(options);
    }

    private static String getUserAgent(MobileDevice device) {
        // Return appropriate user agent based on device
        if (device.getName().contains("iPhone") || device.getName().contains("iPad")) {
            return "Mozilla/5.0 (iPhone; CPU iPhone OS 14_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Mobile/15E148 Safari/604.1";
        } else {
            return "Mozilla/5.0 (Linux; Android 11; " + device.getName() + ") AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.91 Mobile Safari/537.36";
        }
    }
}

// 5. Touch Events Simulation
public class TouchEventsHandler {

    public static void performSwipe(WebDriver driver, WebElement element, String direction) {
        JavascriptExecutor js = (JavascriptExecutor) driver;

        String script = "";
        switch (direction.toLowerCase()) {
            case "left":
                script = "arguments[0].scrollLeft += 100;";
                break;
            case "right":
                script = "arguments[0].scrollLeft -= 100;";
                break;
            case "up":
                script = "arguments[0].scrollTop += 100;";
                break;
            case "down":
                script = "arguments[0].scrollTop -= 100;";
                break;
        }

        js.executeScript(script, element);
    }

    public static void simulateTouchTap(WebDriver driver, WebElement element) {
        JavascriptExecutor js = (JavascriptExecutor) driver;

        // Simulate touch event
        String script =
            "var touch = new Touch({" +
            "  identifier: Date.now()," +
            "  target: arguments[0]," +
            "  clientX: arguments[0].getBoundingClientRect().left + arguments[0].offsetWidth / 2," +
            "  clientY: arguments[0].getBoundingClientRect().top + arguments[0].offsetHeight / 2," +
            "  radiusX: 2.5," +
            "  radiusY: 2.5," +
            "  force: 0.5" +
            "});" +
            "var touchEvent = new TouchEvent('touchstart', {" +
            "  touches: [touch]," +
            "  targetTouches: [touch]," +
            "  changedTouches: [touch]" +
            "});" +
            "arguments[0].dispatchEvent(touchEvent);";

        js.executeScript(script, element);
    }

    public static void simulatePinchZoom(WebDriver driver, int zoomLevel) {
        JavascriptExecutor js = (JavascriptExecutor) driver;

        // Simulate pinch zoom using CSS transform
        String script = String.format("document.body.style.zoom='%d%%';", zoomLevel);
        js.executeScript(script);
    }
}

// 6. Device Orientation Handler
public class DeviceOrientationHandler {

    public static void setPortraitOrientation(ChromeDriver driver, int width, int height) {
        Map<String, Object> deviceMetrics = new HashMap<>();
        deviceMetrics.put("width", width);
        deviceMetrics.put("height", height);
        deviceMetrics.put("mobile", true);

        driver.executeCdpCommand("Emulation.setDeviceMetricsOverride", deviceMetrics);
    }

    public static void setLandscapeOrientation(ChromeDriver driver, int width, int height) {
        // Swap width and height for landscape
        Map<String, Object> deviceMetrics = new HashMap<>();
        deviceMetrics.put("width", height);
        deviceMetrics.put("height", width);
        deviceMetrics.put("mobile", true);

        driver.executeCdpCommand("Emulation.setDeviceMetricsOverride", deviceMetrics);
    }

    public static void testOrientationChange(ChromeDriver driver) {
        // Test in portrait
        setPortraitOrientation(driver, 375, 667);
        // Perform tests...

        // Test in landscape
        setLandscapeOrientation(driver, 375, 667);
        // Perform tests...
    }
}

// 7. Mobile-Specific Assertions
public class MobileAssertions {

    public static boolean isResponsiveLayout(WebDriver driver, int mobileWidth) {
        JavascriptExecutor js = (JavascriptExecutor) driver;

        // Check if viewport matches expected mobile width
        Long actualWidth = (Long) js.executeScript("return window.innerWidth;");

        return actualWidth <= mobileWidth;
    }

    public static boolean isTouchEnabled(WebDriver driver) {
        JavascriptExecutor js = (JavascriptExecutor) driver;

        // Check if touch events are supported
        Boolean touchSupported = (Boolean) js.executeScript(
            "return 'ontouchstart' in window || navigator.maxTouchPoints > 0;");

        return touchSupported;
    }

    public static boolean isHamburgerMenuVisible(WebDriver driver) {
        try {
            WebElement hamburgerMenu = driver.findElement(
                By.cssSelector(".hamburger-menu, .mobile-menu-toggle, .navbar-toggler"));
            return hamburgerMenu.isDisplayed();
        } catch (NoSuchElementException e) {
            return false;
        }
    }

    public static String getUserAgent(WebDriver driver) {
        JavascriptExecutor js = (JavascriptExecutor) driver;
        return (String) js.executeScript("return navigator.userAgent;");
    }

    public static boolean isMobileUserAgent(WebDriver driver) {
        String userAgent = getUserAgent(driver);
        return userAgent.toLowerCase().contains("mobile") ||
               userAgent.toLowerCase().contains("android") ||
               userAgent.toLowerCase().contains("iphone");
    }
}

// 8. Complete Mobile Test Example
public class MobileWebTest {
    private WebDriver driver;

    @Test(dataProvider = "mobileDevices")
    public void testResponsiveDesign(MobileEmulationFactory.MobileDevice device) {
        // Create mobile emulation for device
        driver = MobileEmulationFactory.createMobileEmulation(device);

        // Navigate to website
        driver.get("https://www.example.com");

        // Verify responsive layout
        Assert.assertTrue(MobileAssertions.isResponsiveLayout(driver, device.getWidth()),
            "Layout is not responsive for " + device.getName());

        // Verify mobile user agent
        Assert.assertTrue(MobileAssertions.isMobileUserAgent(driver),
            "User agent is not mobile for " + device.getName());

        // Verify mobile-specific elements
        if (device.getWidth() < 768) {
            Assert.assertTrue(MobileAssertions.isHamburgerMenuVisible(driver),
                "Hamburger menu not visible for " + device.getName());
        }
    }

    @Test
    public void testOrientationChange() {
        ChromeDriver driver = (ChromeDriver) MobileEmulationFactory
            .createMobileEmulation(MobileEmulationFactory.MobileDevice.IPHONE_12_PRO);

        driver.get("https://www.example.com");

        // Test portrait orientation
        DeviceOrientationHandler.setPortraitOrientation(driver, 390, 844);
        Assert.assertTrue(driver.findElement(By.className("portrait-layout")).isDisplayed());

        // Test landscape orientation
        DeviceOrientationHandler.setLandscapeOrientation(driver, 390, 844);
        Assert.assertTrue(driver.findElement(By.className("landscape-layout")).isDisplayed());
    }

    @Test
    public void testTouchInteractions() {
        driver = ChromeMobileEmulation.createChromeAsIPhone();
        driver.get("https://www.example.com/carousel");

        // Find carousel element
        WebElement carousel = driver.findElement(By.className("carousel"));

        // Simulate swipe left
        TouchEventsHandler.performSwipe(driver, carousel, "left");

        // Verify carousel moved
        WebElement activeSlide = driver.findElement(By.className("active-slide"));
        Assert.assertEquals(activeSlide.getAttribute("data-slide-index"), "2");
    }

    @Test
    public void testPinchZoom() {
        driver = ChromeMobileEmulation.createChromeAsPixel5();
        driver.get("https://www.example.com");

        // Simulate pinch zoom to 150%
        TouchEventsHandler.simulatePinchZoom(driver, 150);

        // Verify zoom level
        JavascriptExecutor js = (JavascriptExecutor) driver;
        String zoom = (String) js.executeScript("return document.body.style.zoom;");
        Assert.assertEquals(zoom, "150%");
    }

    @Test
    public void testMobileNavigation() {
        driver = MobileEmulationFactory.createMobileEmulation(
            MobileEmulationFactory.MobileDevice.GALAXY_S21);

        driver.get("https://www.example.com");

        // Click hamburger menu
        WebElement hamburger = driver.findElement(By.className("hamburger-menu"));
        hamburger.click();

        // Wait for menu to expand
        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(5));
        WebElement mobileMenu = wait.until(
            ExpectedConditions.visibilityOfElementLocated(By.className("mobile-menu-expanded")));

        // Verify menu is visible
        Assert.assertTrue(mobileMenu.isDisplayed());

        // Click a menu item
        WebElement menuItem = mobileMenu.findElement(By.linkText("Products"));
        menuItem.click();

        // Verify navigation
        Assert.assertTrue(driver.getCurrentUrl().contains("/products"));
    }

    @DataProvider(name = "mobileDevices")
    public Object[][] mobileDevices() {
        return new Object[][] {
            {MobileEmulationFactory.MobileDevice.IPHONE_SE},
            {MobileEmulationFactory.MobileDevice.IPHONE_12_PRO},
            {MobileEmulationFactory.MobileDevice.PIXEL_5},
            {MobileEmulationFactory.MobileDevice.GALAXY_S21},
            {MobileEmulationFactory.MobileDevice.IPAD_AIR}
        };
    }

    @AfterMethod
    public void tearDown() {
        if (driver != null) {
            driver.quit();
        }
    }
}

// 9. Mobile Page Object Example
public class MobileHomePage {
    private WebDriver driver;

    @FindBy(className = "hamburger-menu")
    private WebElement hamburgerMenu;

    @FindBy(className = "mobile-menu")
    private WebElement mobileMenu;

    @FindBy(className = "search-icon-mobile")
    private WebElement searchIcon;

    @FindBy(id = "mobile-search-input")
    private WebElement searchInput;

    public MobileHomePage(WebDriver driver) {
        this.driver = driver;
        PageFactory.initElements(driver, this);
    }

    public void openMobileMenu() {
        hamburgerMenu.click();

        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(5));
        wait.until(ExpectedConditions.visibilityOf(mobileMenu));
    }

    public void searchProduct(String productName) {
        searchIcon.click();

        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(5));
        wait.until(ExpectedConditions.visibilityOf(searchInput));

        searchInput.sendKeys(productName);
        searchInput.sendKeys(Keys.ENTER);
    }

    public boolean isMobileView() {
        return MobileAssertions.isResponsiveLayout(driver, 768);
    }
}
```

**Follow-up**: What are the limitations of mobile emulation vs real device testing? How to test mobile-specific gestures? How to handle device rotation? How to test on multiple screen resolutions?

---

### Q82: What are cross-browser testing strategies and how do you implement them?

**Answer**:
Cross-browser testing ensures your application works consistently across different browsers (Chrome, Firefox, Safari, Edge) and versions. Strategies include using Selenium Grid for parallel browser execution, cloud-based platforms (BrowserStack, Sauce Labs), Docker containers for browser environments, and TestNG parameterization for browser configurations. A robust framework should support browser abstraction, centralized driver management, browser-specific capabilities, and comprehensive test execution across multiple browsers simultaneously.

**Experience Level**: 6-8 years, 9-12 years
**Difficulty**: Medium to Hard
**Companies**: Google, Microsoft, Amazon, Adobe, Major product companies, Enterprise applications

**Code Examples**:

```java
// 1. Browser Factory with Enum
public class BrowserFactory {
    private static final Logger logger = LogManager.getLogger(BrowserFactory.class);

    public enum BrowserType {
        CHROME, FIREFOX, EDGE, SAFARI, IE
    }

    public static WebDriver createBrowser(BrowserType browserType) {
        WebDriver driver;

        switch (browserType) {
            case CHROME:
                driver = createChrome();
                break;

            case FIREFOX:
                driver = createFirefox();
                break;

            case EDGE:
                driver = createEdge();
                break;

            case SAFARI:
                driver = createSafari();
                break;

            case IE:
                driver = createInternetExplorer();
                break;

            default:
                throw new IllegalArgumentException("Unsupported browser: " + browserType);
        }

        logger.info("Created {} browser", browserType);
        driver.manage().window().maximize();
        driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));

        return driver;
    }

    private static WebDriver createChrome() {
        ChromeOptions options = new ChromeOptions();
        options.addArguments("--start-maximized");
        options.addArguments("--disable-notifications");
        options.addArguments("--disable-popup-blocking");
        return new ChromeDriver(options);
    }

    private static WebDriver createFirefox() {
        FirefoxOptions options = new FirefoxOptions();
        options.addArguments("--width=1920");
        options.addArguments("--height=1080");
        return new FirefoxDriver(options);
    }

    private static WebDriver createEdge() {
        EdgeOptions options = new EdgeOptions();
        options.addArguments("--start-maximized");
        options.addArguments("--disable-notifications");
        return new EdgeDriver(options);
    }

    private static WebDriver createSafari() {
        SafariOptions options = new SafariOptions();
        options.setAutomaticInspection(false);
        return new SafariDriver(options);
    }

    private static WebDriver createInternetExplorer() {
        InternetExplorerOptions options = new InternetExplorerOptions();
        options.ignoreZoomSettings();
        options.introduceFlakinessByIgnoringSecurityDomains();
        return new InternetExplorerDriver(options);
    }
}

// 2. Thread-Safe Browser Manager for Parallel Execution
public class ThreadSafeBrowserManager {
    private static ThreadLocal<WebDriver> driver = new ThreadLocal<>();
    private static final Logger logger = LogManager.getLogger(ThreadSafeBrowserManager.class);

    public static void setDriver(BrowserFactory.BrowserType browserType) {
        if (driver.get() != null) {
            driver.get().quit();
        }

        WebDriver newDriver = BrowserFactory.createBrowser(browserType);
        driver.set(newDriver);

        logger.info("Set {} driver for thread: {}", browserType, Thread.currentThread().getId());
    }

    public static WebDriver getDriver() {
        return driver.get();
    }

    public static void quitDriver() {
        if (driver.get() != null) {
            driver.get().quit();
            driver.remove();
            logger.info("Quit driver for thread: {}", Thread.currentThread().getId());
        }
    }
}

// 3. Browser Capabilities Manager
public class BrowserCapabilitiesManager {

    public static ChromeOptions getChromeOptions(boolean headless) {
        ChromeOptions options = new ChromeOptions();

        if (headless) {
            options.addArguments("--headless=new");
        }

        options.addArguments("--start-maximized");
        options.addArguments("--disable-notifications");
        options.addArguments("--disable-popup-blocking");
        options.addArguments("--disable-dev-shm-usage");
        options.addArguments("--no-sandbox");

        // Performance optimizations
        options.setPageLoadStrategy(PageLoadStrategy.NORMAL);

        return options;
    }

    public static FirefoxOptions getFirefoxOptions(boolean headless) {
        FirefoxOptions options = new FirefoxOptions();

        if (headless) {
            options.addArguments("-headless");
        }

        FirefoxProfile profile = new FirefoxProfile();
        profile.setPreference("permissions.default.desktop-notification", 2);
        profile.setPreference("dom.popup_maximum", 0);

        options.setProfile(profile);

        return options;
    }

    public static EdgeOptions getEdgeOptions(boolean headless) {
        EdgeOptions options = new EdgeOptions();

        if (headless) {
            options.addArguments("--headless=new");
        }

        options.addArguments("--start-maximized");
        options.addArguments("--disable-notifications");

        return options;
    }

    public static SafariOptions getSafariOptions() {
        SafariOptions options = new SafariOptions();
        options.setAutomaticInspection(false);
        options.setUseTechnologyPreview(false);
        return options;
    }
}

// 4. TestNG Cross-Browser Tests with Parameterization
public class CrossBrowserTest {
    private WebDriver driver;
    private static final Logger logger = LogManager.getLogger(CrossBrowserTest.class);

    @BeforeMethod
    @Parameters({"browser"})
    public void setUp(String browser) {
        BrowserFactory.BrowserType browserType =
            BrowserFactory.BrowserType.valueOf(browser.toUpperCase());

        driver = BrowserFactory.createBrowser(browserType);
        logger.info("Starting test with browser: {}", browser);
    }

    @Test
    public void testLoginFunctionality() {
        driver.get("https://www.example.com/login");

        // Test login functionality
        driver.findElement(By.id("username")).sendKeys("testuser");
        driver.findElement(By.id("password")).sendKeys("password123");
        driver.findElement(By.id("login-button")).click();

        // Verify login success
        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
        WebElement dashboard = wait.until(
            ExpectedConditions.presenceOfElementLocated(By.id("dashboard")));

        Assert.assertTrue(dashboard.isDisplayed());
    }

    @Test
    public void testSearchFunctionality() {
        driver.get("https://www.example.com");

        // Test search
        WebElement searchBox = driver.findElement(By.id("search"));
        searchBox.sendKeys("Selenium");
        searchBox.sendKeys(Keys.ENTER);

        // Verify search results
        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
        List<WebElement> results = wait.until(
            ExpectedConditions.presenceOfAllElementsLocatedBy(By.className("search-result")));

        Assert.assertTrue(results.size() > 0);
    }

    @AfterMethod
    public void tearDown() {
        if (driver != null) {
            driver.quit();
        }
    }
}

// 5. TestNG XML Configuration for Cross-Browser Testing
/*
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE suite SYSTEM "http://testng.org/testng-1.0.dtd">
<suite name="Cross Browser Test Suite" parallel="tests" thread-count="4">

    <test name="Chrome Tests">
        <parameter name="browser" value="chrome"/>
        <classes>
            <class name="com.tests.CrossBrowserTest"/>
        </classes>
    </test>

    <test name="Firefox Tests">
        <parameter name="browser" value="firefox"/>
        <classes>
            <class name="com.tests.CrossBrowserTest"/>
        </classes>
    </test>

    <test name="Edge Tests">
        <parameter name="browser" value="edge"/>
        <classes>
            <class name="com.tests.CrossBrowserTest"/>
        </classes>
    </test>

    <test name="Safari Tests">
        <parameter name="browser" value="safari"/>
        <classes>
            <class name="com.tests.CrossBrowserTest"/>
        </classes>
    </test>

</suite>
*/

// 6. Browser Compatibility Checker
public class BrowserCompatibilityChecker {
    private static final Logger logger = LogManager.getLogger(BrowserCompatibilityChecker.class);

    public static void checkFeatureSupport(WebDriver driver, String feature) {
        JavascriptExecutor js = (JavascriptExecutor) driver;

        boolean supported = false;

        switch (feature.toLowerCase()) {
            case "localstorage":
                supported = (Boolean) js.executeScript(
                    "return typeof(Storage) !== 'undefined';");
                break;

            case "websocket":
                supported = (Boolean) js.executeScript(
                    "return 'WebSocket' in window;");
                break;

            case "webgl":
                supported = (Boolean) js.executeScript(
                    "return !!window.WebGLRenderingContext;");
                break;

            case "geolocation":
                supported = (Boolean) js.executeScript(
                    "return 'geolocation' in navigator;");
                break;

            case "flexbox":
                supported = (Boolean) js.executeScript(
                    "return CSS.supports('display', 'flex');");
                break;

            case "grid":
                supported = (Boolean) js.executeScript(
                    "return CSS.supports('display', 'grid');");
                break;
        }

        logger.info("Feature '{}' supported: {}", feature, supported);
    }

    public static String getBrowserInfo(WebDriver driver) {
        Capabilities caps = ((RemoteWebDriver) driver).getCapabilities();

        String browserName = caps.getBrowserName();
        String browserVersion = caps.getBrowserVersion();
        String platform = caps.getPlatformName().toString();

        return String.format("Browser: %s %s on %s", browserName, browserVersion, platform);
    }

    public static void takeScreenshotForBrowser(WebDriver driver, String testName) {
        TakesScreenshot screenshot = (TakesScreenshot) driver;
        File srcFile = screenshot.getScreenshotAs(OutputType.FILE);

        Capabilities caps = ((RemoteWebDriver) driver).getCapabilities();
        String browserName = caps.getBrowserName();

        String destPath = "screenshots/" + browserName + "_" + testName + ".png";

        try {
            FileUtils.copyFile(srcFile, new File(destPath));
            logger.info("Screenshot saved: {}", destPath);
        } catch (IOException e) {
            logger.error("Failed to save screenshot: {}", e.getMessage());
        }
    }
}

// 7. Cloud-Based Cross-Browser Testing (BrowserStack Example)
public class BrowserStackIntegration {
    private static final String USERNAME = "your_browserstack_username";
    private static final String ACCESS_KEY = "your_browserstack_access_key";
    private static final String URL = "https://" + USERNAME + ":" + ACCESS_KEY +
        "@hub-cloud.browserstack.com/wd/hub";

    public static WebDriver createBrowserStackDriver(String browser, String version, String os) {
        DesiredCapabilities caps = new DesiredCapabilities();

        caps.setCapability("browser", browser);
        caps.setCapability("browser_version", version);
        caps.setCapability("os", os);
        caps.setCapability("os_version", getOSVersion(os));
        caps.setCapability("resolution", "1920x1080");
        caps.setCapability("name", "Cross Browser Test");
        caps.setCapability("build", "Build 1.0");

        try {
            return new RemoteWebDriver(new URL(URL), caps);
        } catch (MalformedURLException e) {
            throw new RuntimeException("Invalid BrowserStack URL", e);
        }
    }

    private static String getOSVersion(String os) {
        switch (os.toLowerCase()) {
            case "windows":
                return "10";
            case "macos":
                return "Big Sur";
            case "linux":
                return "Ubuntu";
            default:
                return "10";
        }
    }

    public static void setBrowserStackStatus(WebDriver driver, String status, String reason) {
        JavascriptExecutor js = (JavascriptExecutor) driver;
        js.executeScript("browserstack_executor: {\"action\": \"setSessionStatus\", " +
            "\"arguments\": {\"status\":\"" + status + "\", \"reason\": \"" + reason + "\"}}");
    }
}

// 8. Docker-Based Cross-Browser Testing
public class DockerBrowserSetup {

    // docker-compose.yml for Selenium Grid
    /*
    version: '3'
    services:
      selenium-hub:
        image: selenium/hub:latest
        ports:
          - "4444:4444"

      chrome:
        image: selenium/node-chrome:latest
        depends_on:
          - selenium-hub
        environment:
          - SE_EVENT_BUS_HOST=selenium-hub
          - SE_EVENT_BUS_PUBLISH_PORT=4442
          - SE_EVENT_BUS_SUBSCRIBE_PORT=4443

      firefox:
        image: selenium/node-firefox:latest
        depends_on:
          - selenium-hub
        environment:
          - SE_EVENT_BUS_HOST=selenium-hub
          - SE_EVENT_BUS_PUBLISH_PORT=4442
          - SE_EVENT_BUS_SUBSCRIBE_PORT=4443

      edge:
        image: selenium/node-edge:latest
        depends_on:
          - selenium-hub
        environment:
          - SE_EVENT_BUS_HOST=selenium-hub
          - SE_EVENT_BUS_PUBLISH_PORT=4442
          - SE_EVENT_BUS_SUBSCRIBE_PORT=4443
    */

    public static WebDriver createRemoteDriver(String browser) {
        String gridURL = "http://localhost:4444/wd/hub";

        DesiredCapabilities caps = new DesiredCapabilities();
        caps.setBrowserName(browser);

        try {
            return new RemoteWebDriver(new URL(gridURL), caps);
        } catch (MalformedURLException e) {
            throw new RuntimeException("Invalid Grid URL", e);
        }
    }
}

// 9. Complete Cross-Browser Test Suite
@Listeners(CrossBrowserTestListener.class)
public class CompleteCrossBrowserTest {
    private WebDriver driver;

    @BeforeMethod
    @Parameters({"browser", "headless"})
    public void setUp(String browser, @Optional("false") String headless) {
        boolean isHeadless = Boolean.parseBoolean(headless);

        switch (browser.toLowerCase()) {
            case "chrome":
                driver = new ChromeDriver(
                    BrowserCapabilitiesManager.getChromeOptions(isHeadless));
                break;

            case "firefox":
                driver = new FirefoxDriver(
                    BrowserCapabilitiesManager.getFirefoxOptions(isHeadless));
                break;

            case "edge":
                driver = new EdgeDriver(
                    BrowserCapabilitiesManager.getEdgeOptions(isHeadless));
                break;

            case "safari":
                driver = new SafariDriver(
                    BrowserCapabilitiesManager.getSafariOptions());
                break;

            default:
                throw new IllegalArgumentException("Unsupported browser: " + browser);
        }

        driver.manage().window().maximize();
    }

    @Test
    public void testResponsiveDesign() {
        driver.get("https://www.example.com");

        // Test desktop view
        driver.manage().window().setSize(new Dimension(1920, 1080));
        Assert.assertTrue(driver.findElement(By.className("desktop-nav")).isDisplayed());

        // Test tablet view
        driver.manage().window().setSize(new Dimension(768, 1024));
        Assert.assertTrue(driver.findElement(By.className("tablet-nav")).isDisplayed());

        // Test mobile view
        driver.manage().window().setSize(new Dimension(375, 667));
        Assert.assertTrue(driver.findElement(By.className("mobile-nav")).isDisplayed());
    }

    @Test
    public void testBrowserSpecificFeatures() {
        driver.get("https://www.example.com");

        // Check browser info
        String browserInfo = BrowserCompatibilityChecker.getBrowserInfo(driver);
        System.out.println("Testing on: " + browserInfo);

        // Check feature support
        BrowserCompatibilityChecker.checkFeatureSupport(driver, "localstorage");
        BrowserCompatibilityChecker.checkFeatureSupport(driver, "flexbox");
        BrowserCompatibilityChecker.checkFeatureSupport(driver, "grid");
    }

    @AfterMethod
    public void tearDown(ITestResult result) {
        if (result.getStatus() == ITestResult.FAILURE) {
            BrowserCompatibilityChecker.takeScreenshotForBrowser(
                driver, result.getName());
        }

        if (driver != null) {
            driver.quit();
        }
    }
}

// 10. Cross-Browser Test Listener
public class CrossBrowserTestListener implements ITestListener {
    private static final Logger logger = LogManager.getLogger(CrossBrowserTestListener.class);

    @Override
    public void onTestStart(ITestResult result) {
        String browser = result.getTestContext().getCurrentXmlTest()
            .getParameter("browser");
        logger.info("Starting test: {} on browser: {}",
            result.getName(), browser);
    }

    @Override
    public void onTestSuccess(ITestResult result) {
        String browser = result.getTestContext().getCurrentXmlTest()
            .getParameter("browser");
        logger.info("Test passed: {} on browser: {}",
            result.getName(), browser);
    }

    @Override
    public void onTestFailure(ITestResult result) {
        String browser = result.getTestContext().getCurrentXmlTest()
            .getParameter("browser");
        logger.error("Test failed: {} on browser: {} - Reason: {}",
            result.getName(), browser, result.getThrowable().getMessage());
    }
}
```

**Follow-up**: How do you handle browser-specific bugs? How to prioritize browsers for testing? How to test on older browser versions? How to integrate with cloud testing platforms?

---

### Q83: What are common Selenium mistakes and anti-patterns to avoid?

**Answer**:
Common Selenium mistakes include using Thread.sleep() instead of explicit waits, not handling StaleElementReferenceException, poor locator strategies (XPath/CSS), hardcoded waits, lack of synchronization, missing Page Object Model, not implementing proper exception handling, ignoring parallel execution patterns, inadequate logging, and poor framework architecture. Anti-patterns include direct use of WebDriver in tests, not using factory patterns, duplicate code, tight coupling, and ignoring best practices. Understanding and avoiding these mistakes leads to stable, maintainable test automation.

**Experience Level**: 6-8 years, 9-12 years
**Difficulty**: Hard
**Companies**: All major companies ask these in senior interviews

**Code Examples**:

```java
// MISTAKE #1: Using Thread.sleep() - WRONG âŒ
public class BadSynchronization {
    public void loginBadWay(WebDriver driver) throws InterruptedException {
        driver.get("https://example.com/login");

        Thread.sleep(5000); // WRONG - Fixed wait, wastes time
        driver.findElement(By.id("username")).sendKeys("user");

        Thread.sleep(3000); // WRONG
        driver.findElement(By.id("password")).sendKeys("pass");

        Thread.sleep(2000); // WRONG
        driver.findElement(By.id("login")).click();
    }
}

// CORRECT: Using Explicit Waits âœ…
public class GoodSynchronization {
    private WebDriverWait wait;

    public GoodSynchronization(WebDriver driver) {
        this.wait = new WebDriverWait(driver, Duration.ofSeconds(10));
    }

    public void loginGoodWay(WebDriver driver) {
        driver.get("https://example.com/login");

        WebElement username = wait.until(
            ExpectedConditions.visibilityOfElementLocated(By.id("username")));
        username.sendKeys("user");

        WebElement password = wait.until(
            ExpectedConditions.visibilityOfElementLocated(By.id("password")));
        password.sendKeys("pass");

        WebElement loginButton = wait.until(
            ExpectedConditions.elementToBeClickable(By.id("login")));
        loginButton.click();
    }
}

// MISTAKE #2: Not Handling StaleElementReferenceException - WRONG âŒ
public class StaleElementBadHandling {
    public void searchBadWay(WebDriver driver) {
        driver.get("https://example.com");

        WebElement searchBox = driver.findElement(By.id("search"));
        searchBox.sendKeys("Selenium");

        // Page refresh or DOM change happens
        driver.navigate().refresh();

        searchBox.sendKeys("More text"); // WRONG - Will throw StaleElementReferenceException
    }
}

// CORRECT: Proper Stale Element Handling âœ…
public class StaleElementGoodHandling {
    private WebDriver driver;
    private static final int MAX_RETRIES = 3;

    public void searchGoodWay() {
        driver.get("https://example.com");

        // Use retry mechanism
        retryFindElement(By.id("search"), MAX_RETRIES).sendKeys("Selenium");

        driver.navigate().refresh();

        // Re-find element after refresh
        WebElement searchBox = new WebDriverWait(driver, Duration.ofSeconds(10))
            .until(ExpectedConditions.presenceOfElementLocated(By.id("search")));
        searchBox.sendKeys("More text");
    }

    private WebElement retryFindElement(By locator, int retries) {
        for (int i = 0; i < retries; i++) {
            try {
                return driver.findElement(locator);
            } catch (StaleElementReferenceException e) {
                if (i == retries - 1) {
                    throw e;
                }
                // Wait before retry
                try {
                    Thread.sleep(500);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                }
            }
        }
        throw new NoSuchElementException("Element not found after retries: " + locator);
    }
}

// MISTAKE #3: Poor Locator Strategies - WRONG âŒ
public class BadLocators {
    public void clickButtonBadWay(WebDriver driver) {
        // WRONG - Fragile XPath depending on structure
        driver.findElement(By.xpath("/html/body/div[3]/div[2]/form/div[5]/button[1]")).click();

        // WRONG - Complex XPath with indices
        driver.findElement(By.xpath("//div[@class='container']/div[2]/div[3]/span[1]")).click();

        // WRONG - Using text that might change
        driver.findElement(By.linkText("Click Here to Submit Your Form")).click();
    }
}

// CORRECT: Good Locator Strategies âœ…
public class GoodLocators {
    public void clickButtonGoodWay(WebDriver driver) {
        // GOOD - Use ID (most reliable)
        driver.findElement(By.id("submit-button")).click();

        // GOOD - Use CSS with data attributes
        driver.findElement(By.cssSelector("[data-testid='submit-btn']")).click();

        // GOOD - Relative XPath with stable attributes
        driver.findElement(By.xpath("//button[@data-action='submit']")).click();

        // GOOD - Partial link text for flexibility
        driver.findElement(By.partialLinkText("Submit")).click();
    }
}

// MISTAKE #4: Direct WebDriver Usage in Tests - WRONG âŒ
public class TestWithoutPageObject {
    private WebDriver driver;

    @Test
    public void testLoginBadWay() {
        driver.get("https://example.com/login");
        driver.findElement(By.id("username")).sendKeys("testuser");
        driver.findElement(By.id("password")).sendKeys("password123");
        driver.findElement(By.id("login-button")).click();

        // Duplicate code in multiple tests
        Assert.assertTrue(driver.findElement(By.id("dashboard")).isDisplayed());
    }

    @Test
    public void testAnotherLoginBadWay() {
        // Same code duplicated
        driver.get("https://example.com/login");
        driver.findElement(By.id("username")).sendKeys("anotheruser");
        driver.findElement(By.id("password")).sendKeys("pass456");
        driver.findElement(By.id("login-button")).click();
    }
}

// CORRECT: Using Page Object Model âœ…
public class LoginPage {
    private WebDriver driver;
    private WebDriverWait wait;

    @FindBy(id = "username")
    private WebElement usernameField;

    @FindBy(id = "password")
    private WebElement passwordField;

    @FindBy(id = "login-button")
    private WebElement loginButton;

    public LoginPage(WebDriver driver) {
        this.driver = driver;
        this.wait = new WebDriverWait(driver, Duration.ofSeconds(10));
        PageFactory.initElements(driver, this);
    }

    public void login(String username, String password) {
        wait.until(ExpectedConditions.visibilityOf(usernameField));
        usernameField.sendKeys(username);
        passwordField.sendKeys(password);
        loginButton.click();
    }

    public boolean isLoginSuccessful() {
        return wait.until(ExpectedConditions.urlContains("/dashboard"));
    }
}

@Test
public class TestWithPageObject {
    private WebDriver driver;
    private LoginPage loginPage;

    @BeforeMethod
    public void setUp() {
        driver = new ChromeDriver();
        loginPage = new LoginPage(driver);
    }

    @Test
    public void testLoginGoodWay() {
        driver.get("https://example.com/login");
        loginPage.login("testuser", "password123");
        Assert.assertTrue(loginPage.isLoginSuccessful());
    }

    @Test
    public void testAnotherLoginGoodWay() {
        driver.get("https://example.com/login");
        loginPage.login("anotheruser", "pass456");
        Assert.assertTrue(loginPage.isLoginSuccessful());
    }
}

// MISTAKE #5: Not Closing Driver Properly - WRONG âŒ
public class ImproperDriverCleanup {
    @Test
    public void testWithoutCleanup() {
        WebDriver driver = new ChromeDriver();
        driver.get("https://example.com");
        // Test logic...

        // WRONG - No cleanup, driver instances accumulate
        // Memory leaks, browser windows left open
    }
}

// CORRECT: Proper Driver Cleanup âœ…
public class ProperDriverCleanup {
    private WebDriver driver;

    @BeforeMethod
    public void setUp() {
        driver = new ChromeDriver();
    }

    @Test
    public void testWithCleanup() {
        driver.get("https://example.com");
        // Test logic...
    }

    @AfterMethod
    public void tearDown() {
        if (driver != null) {
            driver.quit(); // Closes all windows and ends session
        }
    }
}

// MISTAKE #6: Ignoring NoSuchElementException - WRONG âŒ
public class PoorExceptionHandling {
    public void clickElementBadWay(WebDriver driver) {
        try {
            driver.findElement(By.id("button")).click();
        } catch (Exception e) {
            // WRONG - Catching generic Exception, hiding issues
            System.out.println("Error occurred");
        }
    }
}

// CORRECT: Proper Exception Handling âœ…
public class GoodExceptionHandling {
    private static final Logger logger = LogManager.getLogger(GoodExceptionHandling.class);

    public void clickElementGoodWay(WebDriver driver) {
        try {
            WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
            WebElement button = wait.until(
                ExpectedConditions.elementToBeClickable(By.id("button")));
            button.click();

        } catch (TimeoutException e) {
            logger.error("Element not clickable within timeout: {}", e.getMessage());
            takeScreenshot(driver, "element_not_clickable");
            throw e;

        } catch (NoSuchElementException e) {
            logger.error("Element not found: {}", e.getMessage());
            takeScreenshot(driver, "element_not_found");
            throw e;

        } catch (StaleElementReferenceException e) {
            logger.warn("Stale element, retrying...");
            // Retry logic
            retryClick(driver, By.id("button"));
        }
    }

    private void retryClick(WebDriver driver, By locator) {
        WebElement button = driver.findElement(locator);
        new WebDriverWait(driver, Duration.ofSeconds(10))
            .until(ExpectedConditions.elementToBeClickable(button))
            .click();
    }

    private void takeScreenshot(WebDriver driver, String fileName) {
        File screenshot = ((TakesScreenshot) driver).getScreenshotAs(OutputType.FILE);
        try {
            FileUtils.copyFile(screenshot,
                new File("screenshots/" + fileName + ".png"));
        } catch (IOException e) {
            logger.error("Failed to save screenshot", e);
        }
    }
}

// MISTAKE #7: Hardcoded Test Data - WRONG âŒ
public class HardcodedTestData {
    @Test
    public void testWithHardcodedData() {
        WebDriver driver = new ChromeDriver();
        driver.get("https://example.com/login");

        // WRONG - Hardcoded data in test
        driver.findElement(By.id("username")).sendKeys("john.doe@example.com");
        driver.findElement(By.id("password")).sendKeys("P@ssw0rd123");
        driver.findElement(By.id("login")).click();
    }
}

// CORRECT: Externalized Test Data âœ…
public class ExternalizedTestData {
    @Test(dataProvider = "loginData")
    public void testWithDataProvider(String username, String password, boolean shouldPass) {
        WebDriver driver = new ChromeDriver();
        driver.get("https://example.com/login");

        LoginPage loginPage = new LoginPage(driver);
        loginPage.login(username, password);

        Assert.assertEquals(loginPage.isLoginSuccessful(), shouldPass);
    }

    @DataProvider(name = "loginData")
    public Object[][] getLoginData() {
        return new Object[][] {
            {"valid.user@example.com", "ValidPass123", true},
            {"invalid.user@example.com", "WrongPass", false},
            {"", "password", false},
            {"user@example.com", "", false}
        };
    }
}

// MISTAKE #8: Not Using ThreadLocal for Parallel Execution - WRONG âŒ
public class NonThreadSafeDriver {
    private static WebDriver driver; // WRONG - Shared across threads

    @BeforeMethod
    public void setUp() {
        driver = new ChromeDriver();
    }

    @Test
    public void test1() {
        driver.get("https://example.com");
        // Will cause issues in parallel execution
    }

    @Test
    public void test2() {
        driver.get("https://example.com/page2");
        // Conflicts with test1 in parallel
    }
}

// CORRECT: Thread-Safe Driver with ThreadLocal âœ…
public class ThreadSafeDriver {
    private static ThreadLocal<WebDriver> driver = new ThreadLocal<>();

    @BeforeMethod
    public void setUp() {
        driver.set(new ChromeDriver());
    }

    @Test
    public void test1() {
        driver.get().get("https://example.com");
        // Safe in parallel execution
    }

    @Test
    public void test2() {
        driver.get().get("https://example.com/page2");
        // Each thread has its own driver
    }

    @AfterMethod
    public void tearDown() {
        if (driver.get() != null) {
            driver.get().quit();
            driver.remove();
        }
    }
}

// MISTAKE #9: Poor Logging Practices - WRONG âŒ
public class PoorLogging {
    @Test
    public void testWithoutLogging() {
        WebDriver driver = new ChromeDriver();
        driver.get("https://example.com");
        driver.findElement(By.id("button")).click();
        // No logging - hard to debug failures
    }
}

// CORRECT: Comprehensive Logging âœ…
public class GoodLogging {
    private static final Logger logger = LogManager.getLogger(GoodLogging.class);
    private WebDriver driver;

    @BeforeMethod
    public void setUp() {
        logger.info("Setting up test environment");
        driver = new ChromeDriver();
        logger.info("Chrome driver initialized");
    }

    @Test
    public void testWithLogging() {
        logger.info("Starting test: testWithLogging");

        logger.info("Navigating to https://example.com");
        driver.get("https://example.com");

        logger.info("Clicking button with id 'button'");
        WebElement button = driver.findElement(By.id("button"));
        button.click();

        logger.info("Button clicked successfully");
        logger.info("Test completed successfully");
    }

    @AfterMethod
    public void tearDown(ITestResult result) {
        if (result.getStatus() == ITestResult.FAILURE) {
            logger.error("Test failed: {}", result.getName());
            logger.error("Failure reason: {}", result.getThrowable().getMessage());
        } else {
            logger.info("Test passed: {}", result.getName());
        }

        if (driver != null) {
            logger.info("Closing driver");
            driver.quit();
        }
    }
}

// MISTAKE #10: Not Implementing Retry Mechanism - WRONG âŒ
public class NoRetryMechanism {
    @Test
    public void flakyTest() {
        WebDriver driver = new ChromeDriver();
        driver.get("https://example.com");

        // Flaky element - sometimes not found immediately
        driver.findElement(By.id("dynamic-element")).click();
        // WRONG - Test fails immediately without retry
    }
}

// CORRECT: Retry Analyzer Implementation âœ…
public class RetryAnalyzer implements IRetryAnalyzer {
    private int retryCount = 0;
    private static final int MAX_RETRY = 3;

    @Override
    public boolean retry(ITestResult result) {
        if (retryCount < MAX_RETRY) {
            retryCount++;
            System.out.println("Retrying test: " + result.getName() +
                " (Attempt " + retryCount + " of " + MAX_RETRY + ")");
            return true;
        }
        return false;
    }
}

public class TestWithRetry {
    @Test(retryAnalyzer = RetryAnalyzer.class)
    public void flakyTestWithRetry() {
        WebDriver driver = new ChromeDriver();
        driver.get("https://example.com");

        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
        WebElement element = wait.until(
            ExpectedConditions.elementToBeClickable(By.id("dynamic-element")));
        element.click();
        // Will retry up to 3 times if fails
    }
}

// SUMMARY: Best Practices Checklist âœ…
public class BestPracticesSummary {
    /*
     * âœ… DO:
     * 1. Use explicit waits (WebDriverWait, FluentWait)
     * 2. Implement Page Object Model
     * 3. Use ThreadLocal for parallel execution
     * 4. Handle exceptions properly
     * 5. Externalize test data
     * 6. Implement comprehensive logging
     * 7. Use good locator strategies (ID > CSS > XPath)
     * 8. Close drivers properly (@AfterMethod)
     * 9. Implement retry mechanisms
     * 10. Take screenshots on failure
     *
     * âŒ DON'T:
     * 1. Use Thread.sleep()
     * 2. Ignore StaleElementReferenceException
     * 3. Use fragile XPath with indices
     * 4. Put WebDriver logic directly in tests
     * 5. Leave drivers open
     * 6. Catch generic Exception
     * 7. Hardcode test data
     * 8. Use non-thread-safe drivers in parallel
     * 9. Skip logging
     * 10. Ignore flaky tests without retry
     */
}
```

**Follow-up**: How do you identify flaky tests? How to refactor legacy test code? What code review practices do you follow? How to measure test code quality?

---

### Q84: What are Selenium testing best practices for building stable and maintainable frameworks?

**Answer**:
Selenium best practices include implementing Page Object Model with proper abstraction, using explicit waits strategically, maintaining DRY (Don't Repeat Yourself) principle, implementing proper exception handling and logging, using data-driven testing, ensuring thread safety for parallel execution, implementing retry mechanisms, taking screenshots on failures, using proper assertion libraries, maintaining clean code structure, implementing CI/CD integration, and regular code reviews. A well-architected framework should be scalable, maintainable, reliable, and easy to understand for team members.

**Experience Level**: 6-8 years, 9-12 years
**Difficulty**: Hard
**Companies**: All major product and service companies

**Code Examples**:

```java
// BEST PRACTICE #1: Implement Fluent Page Object Model âœ…
public class FluentLoginPage {
    private WebDriver driver;
    private WebDriverWait wait;

    @FindBy(id = "username")
    private WebElement usernameField;

    @FindBy(id = "password")
    private WebElement passwordField;

    @FindBy(id = "login-button")
    private WebElement loginButton;

    @FindBy(className = "error-message")
    private WebElement errorMessage;

    public FluentLoginPage(WebDriver driver) {
        this.driver = driver;
        this.wait = new WebDriverWait(driver, Duration.ofSeconds(10));
        PageFactory.initElements(driver, this);
    }

    // Fluent interface - returns 'this' for method chaining
    public FluentLoginPage enterUsername(String username) {
        wait.until(ExpectedConditions.visibilityOf(usernameField));
        usernameField.clear();
        usernameField.sendKeys(username);
        return this;
    }

    public FluentLoginPage enterPassword(String password) {
        wait.until(ExpectedConditions.visibilityOf(passwordField));
        passwordField.clear();
        passwordField.sendKeys(password);
        return this;
    }

    public DashboardPage clickLogin() {
        wait.until(ExpectedConditions.elementToBeClickable(loginButton));
        loginButton.click();
        return new DashboardPage(driver);
    }

    public FluentLoginPage clickLoginExpectingFailure() {
        wait.until(ExpectedConditions.elementToBeClickable(loginButton));
        loginButton.click();
        return this;
    }

    public String getErrorMessage() {
        wait.until(ExpectedConditions.visibilityOf(errorMessage));
        return errorMessage.getText();
    }

    public boolean isErrorMessageDisplayed() {
        try {
            return errorMessage.isDisplayed();
        } catch (NoSuchElementException e) {
            return false;
        }
    }
}

// Usage with method chaining
@Test
public void testLoginWithFluentPOM() {
    DashboardPage dashboard = new FluentLoginPage(driver)
        .enterUsername("testuser@example.com")
        .enterPassword("SecurePass123")
        .clickLogin();

    Assert.assertTrue(dashboard.isLoaded());
}

// BEST PRACTICE #2: Base Page with Common Methods âœ…
public abstract class BasePage {
    protected WebDriver driver;
    protected WebDriverWait wait;
    protected static final Logger logger = LogManager.getLogger(BasePage.class);

    public BasePage(WebDriver driver) {
        this.driver = driver;
        this.wait = new WebDriverWait(driver, Duration.ofSeconds(15));
    }

    // Wait for element to be visible
    protected WebElement waitForElement(By locator) {
        logger.info("Waiting for element: {}", locator);
        return wait.until(ExpectedConditions.visibilityOfElementLocated(locator));
    }

    // Wait for element to be clickable
    protected WebElement waitForClickable(By locator) {
        logger.info("Waiting for element to be clickable: {}", locator);
        return wait.until(ExpectedConditions.elementToBeClickable(locator));
    }

    // Safe click with retry
    protected void safeClick(WebElement element) {
        int attempts = 0;
        while (attempts < 3) {
            try {
                wait.until(ExpectedConditions.elementToBeClickable(element));
                element.click();
                logger.info("Successfully clicked element");
                return;
            } catch (StaleElementReferenceException | ElementClickInterceptedException e) {
                attempts++;
                logger.warn("Click attempt {} failed, retrying...", attempts);
                if (attempts >= 3) {
                    throw e;
                }
                sleep(500);
            }
        }
    }

    // Type text with clear
    protected void typeText(WebElement element, String text) {
        wait.until(ExpectedConditions.visibilityOf(element));
        element.clear();
        element.sendKeys(text);
        logger.info("Typed text: {}", text);
    }

    // Scroll to element
    protected void scrollToElement(WebElement element) {
        JavascriptExecutor js = (JavascriptExecutor) driver;
        js.executeScript("arguments[0].scrollIntoView({behavior: 'smooth', block: 'center'});",
            element);
        logger.info("Scrolled to element");
    }

    // Check if element is present
    protected boolean isElementPresent(By locator) {
        try {
            driver.findElement(locator);
            return true;
        } catch (NoSuchElementException e) {
            return false;
        }
    }

    // Get text with wait
    protected String getTextWithWait(WebElement element) {
        wait.until(ExpectedConditions.visibilityOf(element));
        return element.getText();
    }

    // Take screenshot
    protected void takeScreenshot(String fileName) {
        File screenshot = ((TakesScreenshot) driver).getScreenshotAs(OutputType.FILE);
        try {
            String destPath = "screenshots/" + fileName + "_" +
                System.currentTimeMillis() + ".png";
            FileUtils.copyFile(screenshot, new File(destPath));
            logger.info("Screenshot saved: {}", destPath);
        } catch (IOException e) {
            logger.error("Failed to save screenshot", e);
        }
    }

    // Wait for page to load
    protected void waitForPageLoad() {
        wait.until(webDriver -> ((JavascriptExecutor) webDriver)
            .executeScript("return document.readyState").equals("complete"));
        logger.info("Page loaded successfully");
    }

    private void sleep(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}

// BEST PRACTICE #3: Base Test Class with Setup/Teardown âœ…
public abstract class BaseTest {
    protected WebDriver driver;
    protected static final Logger logger = LogManager.getLogger(BaseTest.class);

    @BeforeMethod(alwaysRun = true)
    @Parameters({"browser", "headless"})
    public void setUp(@Optional("chrome") String browser,
                      @Optional("false") String headless) {
        logger.info("Starting test setup");
        logger.info("Browser: {}, Headless: {}", browser, headless);

        driver = DriverManager.getDriver(browser, Boolean.parseBoolean(headless));

        driver.manage().window().maximize();
        driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));
        driver.manage().timeouts().pageLoadTimeout(Duration.ofSeconds(30));

        logger.info("Test setup completed");
    }

    @AfterMethod(alwaysRun = true)
    public void tearDown(ITestResult result) {
        if (result.getStatus() == ITestResult.FAILURE) {
            logger.error("Test FAILED: {}", result.getName());
            logger.error("Failure reason: {}", result.getThrowable().getMessage());

            // Take screenshot on failure
            takeScreenshot(result.getName());
        } else if (result.getStatus() == ITestResult.SUCCESS) {
            logger.info("Test PASSED: {}", result.getName());
        } else if (result.getStatus() == ITestResult.SKIP) {
            logger.warn("Test SKIPPED: {}", result.getName());
        }

        if (driver != null) {
            logger.info("Closing browser");
            driver.quit();
        }
    }

    protected void takeScreenshot(String testName) {
        File screenshot = ((TakesScreenshot) driver).getScreenshotAs(OutputType.FILE);
        try {
            String destPath = "screenshots/" + testName + "_" +
                System.currentTimeMillis() + ".png";
            FileUtils.copyFile(screenshot, new File(destPath));
            logger.info("Screenshot saved: {}", destPath);
        } catch (IOException e) {
            logger.error("Failed to save screenshot", e);
        }
    }
}

// BEST PRACTICE #4: Configuration Management âœ…
public class ConfigurationManager {
    private static Properties properties;
    private static final String CONFIG_FILE = "config.properties";

    static {
        loadProperties();
    }

    private static void loadProperties() {
        properties = new Properties();
        try (InputStream input = ConfigurationManager.class
                .getClassLoader()
                .getResourceAsStream(CONFIG_FILE)) {

            if (input == null) {
                throw new FileNotFoundException("Config file not found: " + CONFIG_FILE);
            }

            properties.load(input);
        } catch (IOException e) {
            throw new RuntimeException("Failed to load configuration", e);
        }
    }

    public static String getProperty(String key) {
        return properties.getProperty(key);
    }

    public static String getProperty(String key, String defaultValue) {
        return properties.getProperty(key, defaultValue);
    }

    public static String getBaseUrl() {
        return getProperty("base.url", "https://www.example.com");
    }

    public static String getBrowser() {
        return getProperty("browser", "chrome");
    }

    public static boolean isHeadless() {
        return Boolean.parseBoolean(getProperty("headless", "false"));
    }

    public static int getImplicitWait() {
        return Integer.parseInt(getProperty("implicit.wait", "10"));
    }

    public static int getExplicitWait() {
        return Integer.parseInt(getProperty("explicit.wait", "15"));
    }

    public static int getPageLoadTimeout() {
        return Integer.parseInt(getProperty("page.load.timeout", "30"));
    }
}

// config.properties file:
/*
base.url=https://www.example.com
browser=chrome
headless=false
implicit.wait=10
explicit.wait=15
page.load.timeout=30
screenshot.on.failure=true
retry.count=3
parallel.threads=4
*/

// BEST PRACTICE #5: Custom Assertions with Soft Assertions âœ…
public class CustomAssertions {
    private SoftAssert softAssert = new SoftAssert();
    private static final Logger logger = LogManager.getLogger(CustomAssertions.class);

    public void assertEquals(Object actual, Object expected, String message) {
        logger.info("Asserting: {} - Expected: {}, Actual: {}", message, expected, actual);
        softAssert.assertEquals(actual, expected, message);
    }

    public void assertTrue(boolean condition, String message) {
        logger.info("Asserting true: {}", message);
        softAssert.assertTrue(condition, message);
    }

    public void assertFalse(boolean condition, String message) {
        logger.info("Asserting false: {}", message);
        softAssert.assertFalse(condition, message);
    }

    public void assertElementDisplayed(WebElement element, String elementName) {
        logger.info("Asserting element displayed: {}", elementName);
        softAssert.assertTrue(element.isDisplayed(),
            elementName + " should be displayed");
    }

    public void assertElementNotDisplayed(WebElement element, String elementName) {
        logger.info("Asserting element not displayed: {}", elementName);
        try {
            softAssert.assertFalse(element.isDisplayed(),
                elementName + " should not be displayed");
        } catch (NoSuchElementException e) {
            // Element not present - assertion passes
            logger.info("{} is not present (as expected)", elementName);
        }
    }

    public void assertURL(WebDriver driver, String expectedURL, String message) {
        logger.info("Asserting URL: {} - Expected: {}", message, expectedURL);
        String actualURL = driver.getCurrentUrl();
        softAssert.assertEquals(actualURL, expectedURL, message);
    }

    public void assertTitle(WebDriver driver, String expectedTitle, String message) {
        logger.info("Asserting title: {} - Expected: {}", message, expectedTitle);
        String actualTitle = driver.getTitle();
        softAssert.assertEquals(actualTitle, expectedTitle, message);
    }

    public void assertAll() {
        logger.info("Performing soft assertion validation");
        softAssert.assertAll();
    }
}

// Usage in test
@Test
public void testWithCustomAssertions() {
    CustomAssertions asserts = new CustomAssertions();

    driver.get("https://www.example.com");

    asserts.assertTitle(driver, "Example Domain", "Page title should match");
    asserts.assertTrue(driver.findElement(By.tagName("h1")).isDisplayed(),
        "Header should be displayed");
    asserts.assertEquals(driver.findElement(By.tagName("h1")).getText(),
        "Example Domain", "Header text should match");

    // All assertions validated at once
    asserts.assertAll();
}

// BEST PRACTICE #6: Test Data Builder Pattern âœ…
public class UserBuilder {
    private String firstName;
    private String lastName;
    private String email;
    private String password;
    private String phoneNumber;
    private String address;

    public UserBuilder withFirstName(String firstName) {
        this.firstName = firstName;
        return this;
    }

    public UserBuilder withLastName(String lastName) {
        this.lastName = lastName;
        return this;
    }

    public UserBuilder withEmail(String email) {
        this.email = email;
        return this;
    }

    public UserBuilder withPassword(String password) {
        this.password = password;
        return this;
    }

    public UserBuilder withPhoneNumber(String phoneNumber) {
        this.phoneNumber = phoneNumber;
        return this;
    }

    public UserBuilder withAddress(String address) {
        this.address = address;
        return this;
    }

    public UserBuilder withRandomData() {
        this.firstName = "Test" + System.currentTimeMillis();
        this.lastName = "User";
        this.email = "testuser" + System.currentTimeMillis() + "@example.com";
        this.password = "SecurePass123!";
        this.phoneNumber = "123-456-7890";
        this.address = "123 Test Street";
        return this;
    }

    public User build() {
        return new User(firstName, lastName, email, password, phoneNumber, address);
    }
}

// Usage
@Test
public void testUserRegistration() {
    User testUser = new UserBuilder()
        .withRandomData()
        .withPassword("CustomPass123!")
        .build();

    RegistrationPage registrationPage = new RegistrationPage(driver);
    registrationPage.registerUser(testUser);

    Assert.assertTrue(registrationPage.isRegistrationSuccessful());
}

// BEST PRACTICE #7: Extent Reports Integration âœ…
public class ExtentReportManager {
    private static ExtentReports extent;
    private static ThreadLocal<ExtentTest> test = new ThreadLocal<>();

    public static void initReport() {
        ExtentSparkReporter sparkReporter = new ExtentSparkReporter("reports/TestReport.html");
        sparkReporter.config().setTheme(Theme.DARK);
        sparkReporter.config().setDocumentTitle("Automation Test Report");
        sparkReporter.config().setReportName("Regression Test Results");

        extent = new ExtentReports();
        extent.attachReporter(sparkReporter);
        extent.setSystemInfo("OS", System.getProperty("os.name"));
        extent.setSystemInfo("User", System.getProperty("user.name"));
        extent.setSystemInfo("Java Version", System.getProperty("java.version"));
    }

    public static void startTest(String testName, String description) {
        ExtentTest extentTest = extent.createTest(testName, description);
        test.set(extentTest);
    }

    public static void logInfo(String message) {
        test.get().log(Status.INFO, message);
    }

    public static void logPass(String message) {
        test.get().log(Status.PASS, message);
    }

    public static void logFail(String message) {
        test.get().log(Status.FAIL, message);
    }

    public static void logWarning(String message) {
        test.get().log(Status.WARNING, message);
    }

    public static void addScreenshot(String screenshotPath) {
        try {
            test.get().addScreenCaptureFromPath(screenshotPath);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static void flushReport() {
        if (extent != null) {
            extent.flush();
        }
    }
}

// Usage in test listener
public class ExtentTestListener implements ITestListener {
    @Override
    public void onStart(ITestContext context) {
        ExtentReportManager.initReport();
    }

    @Override
    public void onTestStart(ITestResult result) {
        ExtentReportManager.startTest(result.getName(),
            result.getMethod().getDescription());
    }

    @Override
    public void onTestSuccess(ITestResult result) {
        ExtentReportManager.logPass("Test passed: " + result.getName());
    }

    @Override
    public void onTestFailure(ITestResult result) {
        ExtentReportManager.logFail("Test failed: " + result.getName());
        ExtentReportManager.logFail("Reason: " + result.getThrowable().getMessage());

        // Attach screenshot
        WebDriver driver = ((BaseTest) result.getInstance()).driver;
        String screenshotPath = captureScreenshot(driver, result.getName());
        ExtentReportManager.addScreenshot(screenshotPath);
    }

    @Override
    public void onFinish(ITestContext context) {
        ExtentReportManager.flushReport();
    }

    private String captureScreenshot(WebDriver driver, String testName) {
        File screenshot = ((TakesScreenshot) driver).getScreenshotAs(OutputType.FILE);
        String destPath = "screenshots/" + testName + "_" +
            System.currentTimeMillis() + ".png";

        try {
            FileUtils.copyFile(screenshot, new File(destPath));
        } catch (IOException e) {
            e.printStackTrace();
        }

        return destPath;
    }
}
```

**Follow-up**: How do you handle test data management? How to implement data-driven testing effectively? How to optimize test execution time? How to ensure test reliability?

---

### Q85: How do you write advanced XPath and CSS selector strategies for complex DOM structures?

**Answer**:
Advanced XPath and CSS selector strategies are essential for handling complex, dynamic, and deeply nested DOM structures. Techniques include using axes (ancestor, sibling, descendant), predicates, logical operators, text functions, attribute manipulation, nth-child selectors, and dynamic element handling. Understanding CSS pseudo-classes, attribute selectors, and XPath functions enables creation of robust, maintainable locators that withstand DOM changes. Best practices include avoiding absolute paths, using relative locators, combining multiple attributes, and leveraging data-testid attributes.

**Experience Level**: 6-8 years, 9-12 years
**Difficulty**: Hard
**Companies**: All major companies, especially complex enterprise applications

**Code Examples**:

```java
// 1. Advanced XPath Techniques
public class AdvancedXPathStrategies {

    // XPath Axes - Finding related elements
    public static class XPathAxes {

        // Find parent of an element
        public static String findParent(String childLocator) {
            return childLocator + "/parent::*";
        }

        // Find ancestor (any level above)
        public static String findAncestor(String elementLocator, String ancestorTag) {
            return elementLocator + "/ancestor::" + ancestorTag;
        }

        // Find following sibling
        public static String findFollowingSibling(String elementLocator, String siblingTag) {
            return elementLocator + "/following-sibling::" + siblingTag;
        }

        // Find preceding sibling
        public static String findPrecedingSibling(String elementLocator, String siblingTag) {
            return elementLocator + "/preceding-sibling::" + siblingTag;
        }

        // Example usage
        public void demonstrateAxes(WebDriver driver) {
            // Find parent of a button
            String parentXPath = "//button[@id='submit']/parent::form";
            WebElement form = driver.findElement(By.xpath(parentXPath));

            // Find ancestor table of a cell
            String ancestorXPath = "//td[@class='data-cell']/ancestor::table";
            WebElement table = driver.findElement(By.xpath(ancestorXPath));

            // Find following sibling
            String siblingXPath = "//label[text()='Username']/following-sibling::input";
            WebElement input = driver.findElement(By.xpath(siblingXPath));
        }
    }

    // XPath Text Functions
    public static class XPathTextFunctions {

        // Exact text match
        public static String exactTextMatch(String text) {
            return String.format("//*[text()='%s']", text);
        }

        // Contains text
        public static String containsText(String text) {
            return String.format("//*[contains(text(), '%s')]", text);
        }

        // Starts with text
        public static String startsWithText(String text) {
            return String.format("//*[starts-with(text(), '%s')]", text);
        }

        // Text with normalize-space (handles whitespace)
        public static String normalizedText(String text) {
            return String.format("//*[normalize-space(text())='%s']", text);
        }

        // Case-insensitive text search
        public static String caseInsensitiveText(String text) {
            return String.format("//*[contains(translate(text(), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), '%s')]",
                text.toLowerCase());
        }

        // Multiple text conditions with OR
        public static String multipleTextOptions(String... texts) {
            StringBuilder xpath = new StringBuilder("//*[");
            for (int i = 0; i < texts.length; i++) {
                xpath.append(String.format("text()='%s'", texts[i]));
                if (i < texts.length - 1) {
                    xpath.append(" or ");
                }
            }
            xpath.append("]");
            return xpath.toString();
        }
    }

    // XPath with Multiple Attributes
    public static class XPathMultipleConditions {

        // AND condition
        public static String andCondition(String tag, String attr1, String val1, String attr2, String val2) {
            return String.format("//%s[@%s='%s' and @%s='%s']", tag, attr1, val1, attr2, val2);
        }

        // OR condition
        public static String orCondition(String tag, String attr1, String val1, String attr2, String val2) {
            return String.format("//%s[@%s='%s' or @%s='%s']", tag, attr1, val1, attr2, val2);
        }

        // Contains with multiple attributes
        public static String multipleContains(String tag, String attr1, String val1, String attr2, String val2) {
            return String.format("//%s[contains(@%s, '%s') and contains(@%s, '%s')]",
                tag, attr1, val1, attr2, val2);
        }

        // Dynamic attribute matching
        public static String dynamicAttributeMatch(String tag, String baseAttr, String baseVal, String dynamicPart) {
            return String.format("//%s[@%s='%s' and contains(@class, '%s')]",
                tag, baseAttr, baseVal, dynamicPart);
        }
    }

    // XPath for Position-Based Selection
    public static class XPathPositionSelectors {

        // First element
        public static String firstElement(String xpath) {
            return "(" + xpath + ")[1]";
        }

        // Last element
        public static String lastElement(String xpath) {
            return "(" + xpath + ")[last()]";
        }

        // Nth element
        public static String nthElement(String xpath, int position) {
            return String.format("(%s)[%d]", xpath, position);
        }

        // Position greater than
        public static String positionGreaterThan(String xpath, int position) {
            return "(" + xpath + ")[position()>" + position + "]";
        }

        // Elements except first
        public static String allExceptFirst(String xpath) {
            return "(" + xpath + ")[position()>1]";
        }
    }

    // Complex XPath Examples
    public static class ComplexXPathExamples {

        // Find button by partial text and class
        public static WebElement findButtonByPartialTextAndClass(WebDriver driver,
                String partialText, String partialClass) {
            String xpath = String.format(
                "//button[contains(text(), '%s') and contains(@class, '%s')]",
                partialText, partialClass);
            return driver.findElement(By.xpath(xpath));
        }

        // Find element by data attribute
        public static WebElement findByDataAttribute(WebDriver driver,
                String dataAttr, String value) {
            String xpath = String.format("//*[@data-%s='%s']", dataAttr, value);
            return driver.findElement(By.xpath(xpath));
        }

        // Find parent with specific child
        public static WebElement findParentWithChild(WebDriver driver,
                String parentTag, String childTag, String childText) {
            String xpath = String.format(
                "//%s[.//%s[contains(text(), '%s')]]",
                parentTag, childTag, childText);
            return driver.findElement(By.xpath(xpath));
        }

        // Find table cell by row and column
        public static WebElement findTableCell(WebDriver driver,
                int row, int col) {
            String xpath = String.format(
                "//table//tr[%d]/td[%d]", row, col);
            return driver.findElement(By.xpath(xpath));
        }

        // Find element with specific attribute pattern
        public static WebElement findByAttributePattern(WebDriver driver,
                String tag, String attr, String pattern) {
            String xpath = String.format(
                "//%s[starts-with(@%s, '%s')]", tag, attr, pattern);
            return driver.findElement(By.xpath(xpath));
        }
    }
}

// 2. Advanced CSS Selector Techniques
public class AdvancedCSSSelectors {

    // CSS Attribute Selectors
    public static class CSSAttributeSelectors {

        // Exact attribute match
        public static String exactMatch(String tag, String attr, String value) {
            return String.format("%s[%s='%s']", tag, attr, value);
        }

        // Contains substring
        public static String containsSubstring(String tag, String attr, String value) {
            return String.format("%s[%s*='%s']", tag, attr, value);
        }

        // Starts with
        public static String startsWith(String tag, String attr, String value) {
            return String.format("%s[%s^='%s']", tag, attr, value);
        }

        // Ends with
        public static String endsWith(String tag, String attr, String value) {
            return String.format("%s[%s$='%s']", tag, attr, value);
        }

        // Multiple attributes
        public static String multipleAttributes(String tag, String attr1, String val1,
                String attr2, String val2) {
            return String.format("%s[%s='%s'][%s='%s']", tag, attr1, val1, attr2, val2);
        }
    }

    // CSS Pseudo-classes
    public static class CSSPseudoClasses {

        // First child
        public static String firstChild(String selector) {
            return selector + ":first-child";
        }

        // Last child
        public static String lastChild(String selector) {
            return selector + ":last-child";
        }

        // Nth child
        public static String nthChild(String selector, int n) {
            return String.format("%s:nth-child(%d)", selector, n);
        }

        // Nth of type
        public static String nthOfType(String selector, int n) {
            return String.format("%s:nth-of-type(%d)", selector, n);
        }

        // Not selector
        public static String notSelector(String selector, String excludeClass) {
            return String.format("%s:not(.%s)", selector, excludeClass);
        }

        // Enabled/Disabled
        public static String enabled(String selector) {
            return selector + ":enabled";
        }

        public static String disabled(String selector) {
            return selector + ":disabled";
        }

        // Checked
        public static String checked(String selector) {
            return selector + ":checked";
        }
    }

    // CSS Combinators
    public static class CSSCombinators {

        // Descendant selector (space)
        public static String descendant(String parent, String child) {
            return parent + " " + child;
        }

        // Direct child selector (>)
        public static String directChild(String parent, String child) {
            return parent + " > " + child;
        }

        // Adjacent sibling (+)
        public static String adjacentSibling(String element, String sibling) {
            return element + " + " + sibling;
        }

        // General sibling (~)
        public static String generalSibling(String element, String sibling) {
            return element + " ~ " + sibling;
        }
    }

    // Complex CSS Examples
    public static class ComplexCSSExamples {

        // Find input after label
        public static WebElement findInputAfterLabel(WebDriver driver, String labelText) {
            // CSS doesn't support text selection, combine with XPath or use attribute
            String css = String.format("label[for='%s'] + input", labelText);
            return driver.findElement(By.cssSelector(css));
        }

        // Find element with multiple classes
        public static WebElement findWithMultipleClasses(WebDriver driver, String... classes) {
            String css = "." + String.join(".", classes);
            return driver.findElement(By.cssSelector(css));
        }

        // Find nth element with specific class
        public static WebElement findNthWithClass(WebDriver driver, String className, int n) {
            String css = String.format(".%s:nth-of-type(%d)", className, n);
            return driver.findElement(By.cssSelector(css));
        }

        // Find button with data attribute
        public static WebElement findButtonWithData(WebDriver driver, String dataAttr, String value) {
            String css = String.format("button[data-%s='%s']", dataAttr, value);
            return driver.findElement(By.cssSelector(css));
        }

        // Find element not having specific class
        public static WebElement findWithoutClass(WebDriver driver, String tag, String excludeClass) {
            String css = String.format("%s:not(.%s)", tag, excludeClass);
            return driver.findElement(By.cssSelector(css));
        }
    }
}

// 3. Dynamic Element Locator Builder
public class DynamicLocatorBuilder {

    public enum LocatorType {
        XPATH, CSS
    }

    public static class LocatorBuilder {
        private StringBuilder locator;
        private LocatorType type;

        public LocatorBuilder(LocatorType type) {
            this.type = type;
            this.locator = new StringBuilder();
        }

        public LocatorBuilder withTag(String tag) {
            if (type == LocatorType.XPATH) {
                locator.append("//").append(tag);
            } else {
                locator.append(tag);
            }
            return this;
        }

        public LocatorBuilder withAttribute(String attr, String value) {
            if (type == LocatorType.XPATH) {
                if (locator.length() > 0 && !locator.toString().contains("[")) {
                    locator.append("[");
                } else if (locator.toString().contains("]")) {
                    locator.deleteCharAt(locator.length() - 1);
                    locator.append(" and ");
                } else {
                    locator.append("[");
                }
                locator.append(String.format("@%s='%s']", attr, value));
            } else {
                locator.append(String.format("[%s='%s']", attr, value));
            }
            return this;
        }

        public LocatorBuilder withContainsAttribute(String attr, String value) {
            if (type == LocatorType.XPATH) {
                if (!locator.toString().contains("[")) {
                    locator.append("[");
                } else {
                    locator.deleteCharAt(locator.length() - 1);
                    locator.append(" and ");
                }
                locator.append(String.format("contains(@%s, '%s')]", attr, value));
            } else {
                locator.append(String.format("[%s*='%s']", attr, value));
            }
            return this;
        }

        public LocatorBuilder withText(String text) {
            if (type == LocatorType.XPATH) {
                if (!locator.toString().contains("[")) {
                    locator.append("[");
                } else {
                    locator.deleteCharAt(locator.length() - 1);
                    locator.append(" and ");
                }
                locator.append(String.format("text()='%s']", text));
            }
            return this;
        }

        public LocatorBuilder withContainsText(String text) {
            if (type == LocatorType.XPATH) {
                if (!locator.toString().contains("[")) {
                    locator.append("[");
                } else {
                    locator.deleteCharAt(locator.length() - 1);
                    locator.append(" and ");
                }
                locator.append(String.format("contains(text(), '%s')]", text));
            }
            return this;
        }

        public LocatorBuilder withIndex(int index) {
            String currentLocator = locator.toString();
            locator = new StringBuilder();
            locator.append("(").append(currentLocator).append(")");
            locator.append(String.format("[%d]", index));
            return this;
        }

        public String build() {
            return locator.toString();
        }

        public By buildBy() {
            String loc = locator.toString();
            return type == LocatorType.XPATH ? By.xpath(loc) : By.cssSelector(loc);
        }
    }

    // Usage examples
    public static void demonstrateBuilder(WebDriver driver) {
        // Build XPath dynamically
        String xpath = new LocatorBuilder(LocatorType.XPATH)
            .withTag("button")
            .withAttribute("type", "submit")
            .withContainsAttribute("class", "btn-primary")
            .withContainsText("Submit")
            .build();

        WebElement button = driver.findElement(By.xpath(xpath));

        // Build CSS dynamically
        String css = new LocatorBuilder(LocatorType.CSS)
            .withTag("input")
            .withAttribute("type", "text")
            .withAttribute("name", "username")
            .build();

        WebElement input = driver.findElement(By.cssSelector(css));
    }
}

// 4. Locator Strategy Helper
public class LocatorStrategyHelper {
    private static final Logger logger = LogManager.getLogger(LocatorStrategyHelper.class);

    // Evaluate and suggest best locator
    public static String suggestBestLocator(WebDriver driver, String elementDescription) {
        logger.info("Analyzing element: {}", elementDescription);

        // Priority: ID > Name > CSS > XPath
        List<String> strategies = new ArrayList<>();

        // Check if element has ID
        if (hasAttribute(driver, elementDescription, "id")) {
            strategies.add("Use By.id() - most reliable");
        }

        // Check if element has unique name
        if (hasAttribute(driver, elementDescription, "name")) {
            strategies.add("Use By.name() - reliable for form elements");
        }

        // Check for data-testid
        if (hasAttribute(driver, elementDescription, "data-testid")) {
            strategies.add("Use CSS with data-testid - good for testing");
        }

        // Check for unique class
        if (hasAttribute(driver, elementDescription, "class")) {
            strategies.add("Use CSS with class - moderate reliability");
        }

        // Fallback to XPath
        strategies.add("Use XPath as fallback - maintain carefully");

        return String.join(", ", strategies);
    }

    private static boolean hasAttribute(WebDriver driver, String elementDescription, String attr) {
        // Simplified check - in real scenario, inspect actual element
        return true;
    }

    // Generate multiple locator alternatives
    public static List<By> generateAlternativeLocators(String tag, String id, String name,
            String className, String text) {
        List<By> locators = new ArrayList<>();

        if (id != null && !id.isEmpty()) {
            locators.add(By.id(id));
            locators.add(By.cssSelector("#" + id));
            locators.add(By.xpath(String.format("//%s[@id='%s']", tag, id)));
        }

        if (name != null && !name.isEmpty()) {
            locators.add(By.name(name));
            locators.add(By.cssSelector(String.format("%s[name='%s']", tag, name)));
            locators.add(By.xpath(String.format("//%s[@name='%s']", tag, name)));
        }

        if (className != null && !className.isEmpty()) {
            locators.add(By.className(className));
            locators.add(By.cssSelector("." + className));
            locators.add(By.xpath(String.format("//%s[@class='%s']", tag, className)));
        }

        if (text != null && !text.isEmpty()) {
            locators.add(By.linkText(text));
            locators.add(By.partialLinkText(text));
            locators.add(By.xpath(String.format("//%s[text()='%s']", tag, text)));
        }

        return locators;
    }

    // Test locator uniqueness
    public static boolean isLocatorUnique(WebDriver driver, By locator) {
        try {
            List<WebElement> elements = driver.findElements(locator);
            return elements.size() == 1;
        } catch (Exception e) {
            logger.error("Error checking locator uniqueness: {}", e.getMessage());
            return false;
        }
    }
}

// 5. Complex Real-World Examples
public class RealWorldLocatorExamples {

    // Example 1: Find element in a dynamic table
    public static WebElement findInDynamicTable(WebDriver driver,
            String columnHeader, String rowText) {
        // Find column index by header
        String headerXPath = String.format("//th[text()='%s']", columnHeader);
        int columnIndex = driver.findElements(By.xpath("//th")).indexOf(
            driver.findElement(By.xpath(headerXPath))) + 1;

        // Find cell in that column for specific row
        String cellXPath = String.format(
            "//tr[td[contains(text(), '%s')]]/td[%d]", rowText, columnIndex);

        return driver.findElement(By.xpath(cellXPath));
    }

    // Example 2: Find nested element with specific structure
    public static WebElement findNestedElement(WebDriver driver) {
        // Find a button inside a div with specific class, inside a form
        String xpath = "//form[@id='myForm']//div[contains(@class, 'button-container')]//button[@type='submit']";
        return driver.findElement(By.xpath(xpath));
    }

    // Example 3: Find element with dynamic ID
    public static WebElement findElementWithDynamicId(WebDriver driver, String idPrefix) {
        String xpath = String.format("//input[starts-with(@id, '%s')]", idPrefix);
        return driver.findElement(By.xpath(xpath));
    }

    // Example 4: Find checkbox by associated label
    public static WebElement findCheckboxByLabel(WebDriver driver, String labelText) {
        // Find label, get 'for' attribute, find checkbox by ID
        String labelXPath = String.format("//label[contains(text(), '%s')]", labelText);
        WebElement label = driver.findElement(By.xpath(labelXPath));
        String forAttribute = label.getAttribute("for");

        return driver.findElement(By.id(forAttribute));
    }

    // Example 5: Find element with multiple partial class matches
    public static WebElement findByMultiplePartialClasses(WebDriver driver,
            String... partialClasses) {
        StringBuilder xpath = new StringBuilder("//div[");
        for (int i = 0; i < partialClasses.length; i++) {
            xpath.append(String.format("contains(@class, '%s')", partialClasses[i]));
            if (i < partialClasses.length - 1) {
                xpath.append(" and ");
            }
        }
        xpath.append("]");

        return driver.findElement(By.xpath(xpath.toString()));
    }
}

// 6. Test Examples
public class AdvancedLocatorTests {
    private WebDriver driver;

    @Test
    public void testComplexXPath() {
        driver.get("https://example.com");

        // Find element using multiple conditions
        String xpath = "//button[@type='submit' and contains(@class, 'primary') and text()='Submit']";
        WebElement button = driver.findElement(By.xpath(xpath));
        button.click();

        Assert.assertTrue(driver.getCurrentUrl().contains("/success"));
    }

    @Test
    public void testDynamicLocatorBuilder() {
        driver.get("https://example.com");

        By locator = new DynamicLocatorBuilder.LocatorBuilder(
            DynamicLocatorBuilder.LocatorType.XPATH)
            .withTag("input")
            .withAttribute("type", "text")
            .withAttribute("name", "username")
            .buildBy();

        WebElement input = driver.findElement(locator);
        input.sendKeys("testuser");

        Assert.assertEquals(input.getAttribute("value"), "testuser");
    }

    @Test
    public void testTableNavigation() {
        driver.get("https://example.com/table");

        // Find cell by row and column
        WebElement cell = RealWorldLocatorExamples.findInDynamicTable(
            driver, "Email", "John Doe");

        Assert.assertTrue(cell.getText().contains("@example.com"));
    }
}
```

**Follow-up**: How do you handle locators for internationalized applications? How to maintain locators when DOM structure changes frequently? What tools help in generating optimal locators? How to test locator performance?

---

### Q86: How do you handle Shadow DOM in Selenium WebDriver?

**Answer**:
Shadow DOM encapsulates a component's internal structure, making it inaccessible via standard Selenium locators. Selenium 4 introduced native Shadow DOM support through `getShadowRoot()` method. For older Selenium versions, JavaScript Executor is required to pierce through shadow boundaries. Modern web components extensively use Shadow DOM, requiring specific strategies to locate and interact with shadowed elements. Understanding Shadow DOM levels (open vs closed), using JavaScript for deep traversal, and implementing wrapper methods are essential for testing modern web applications.

**Experience Level**: 6-8 years, 9-12 years
**Difficulty**: Hard
**Companies**: Companies using Web Components, modern frontend frameworks (Salesforce, Shopify, Polymer apps)

**Code Examples**:

```java
// 1. Shadow DOM Basics - Selenium 4
public class ShadowDOMHandler {
    private WebDriver driver;
    private static final Logger logger = LogManager.getLogger(ShadowDOMHandler.class);

    // Basic Shadow DOM access (Selenium 4+)
    public WebElement accessShadowElement(WebElement host, String selector) {
        SearchContext shadowRoot = host.getShadowRoot();
        return shadowRoot.findElement(By.cssSelector(selector));
    }

    // Example: Access element inside single shadow root
    public void accessSingleShadowDOM() {
        // Find shadow host
        WebElement shadowHost = driver.findElement(By.cssSelector("#shadow-host"));

        // Access shadow root
        SearchContext shadowRoot = shadowHost.getShadowRoot();

        // Find element inside shadow DOM
        WebElement shadowElement = shadowRoot.findElement(By.cssSelector(".shadow-element"));
        shadowElement.click();

        logger.info("Accessed element inside shadow DOM");
    }

    // Nested Shadow DOM (multiple levels)
    public WebElement accessNestedShadowDOM(List<String> hostSelectors, String finalSelector) {
        SearchContext context = driver;

        // Traverse through each shadow host
        for (String hostSelector : hostSelectors) {
            WebElement host = context.findElement(By.cssSelector(hostSelector));
            context = host.getShadowRoot();
        }

        // Find final element
        return context.findElement(By.cssSelector(finalSelector));
    }

    // Example: Navigate through nested shadow DOMs
    public void accessNestedShadowExample() {
        // Level 1: Access first shadow host
        WebElement host1 = driver.findElement(By.cssSelector("#shadow-host-1"));
        SearchContext shadowRoot1 = host1.getShadowRoot();

        // Level 2: Access second shadow host inside first shadow DOM
        WebElement host2 = shadowRoot1.findElement(By.cssSelector("#shadow-host-2"));
        SearchContext shadowRoot2 = host2.getShadowRoot();

        // Level 3: Access final element
        WebElement finalElement = shadowRoot2.findElement(By.cssSelector(".target-element"));
        finalElement.click();

        logger.info("Navigated through nested shadow DOMs");
    }
}

// 2. JavaScript Approach for Shadow DOM (Universal Method)
public class ShadowDOMJavaScript {
    private WebDriver driver;
    private JavascriptExecutor js;

    public ShadowDOMJavaScript(WebDriver driver) {
        this.driver = driver;
        this.js = (JavascriptExecutor) driver;
    }

    // Access shadow element using JavaScript
    public WebElement getShadowElement(String shadowHostSelector, String shadowElementSelector) {
        String script =
            "return document.querySelector(arguments[0])" +
            ".shadowRoot" +
            ".querySelector(arguments[1]);";

        return (WebElement) js.executeScript(script, shadowHostSelector, shadowElementSelector);
    }

    // Access nested shadow element
    public WebElement getNestedShadowElement(String... selectors) {
        // Build JavaScript to traverse multiple shadow DOMs
        StringBuilder script = new StringBuilder("var element = document;");

        for (int i = 0; i < selectors.length - 1; i++) {
            script.append(String.format(
                "element = element.querySelector('%s').shadowRoot;",
                selectors[i]));
        }

        script.append(String.format(
            "return element.querySelector('%s');",
            selectors[selectors.length - 1]));

        return (WebElement) js.executeScript(script.toString());
    }

    // Get all elements inside shadow DOM
    public List<WebElement> getAllShadowElements(String shadowHostSelector,
            String shadowElementsSelector) {
        String script =
            "return document.querySelector(arguments[0])" +
            ".shadowRoot" +
            ".querySelectorAll(arguments[1]);";

        return (List<WebElement>) js.executeScript(script,
            shadowHostSelector, shadowElementsSelector);
    }

    // Deep querySelector (pierces through all shadow boundaries)
    public WebElement deepQuerySelector(String selector) {
        String script =
            "function deepQuerySelector(selector) {" +
            "  function findInShadows(node) {" +
            "    if (node.shadowRoot) {" +
            "      const found = node.shadowRoot.querySelector(selector);" +
            "      if (found) return found;" +
            "      for (const child of node.shadowRoot.querySelectorAll('*')) {" +
            "        const result = findInShadows(child);" +
            "        if (result) return result;" +
            "      }" +
            "    }" +
            "    return null;" +
            "  }" +
            "  return findInShadows(document.body) || document.querySelector(selector);" +
            "}" +
            "return deepQuerySelector(arguments[0]);";

        return (WebElement) js.executeScript(script, selector);
    }

    // Check if element is in shadow DOM
    public boolean isInShadowDOM(WebElement element) {
        String script =
            "function getRootNode(element) {" +
            "  if (element.getRootNode) {" +
            "    return element.getRootNode();" +
            "  }" +
            "  return document;" +
            "}" +
            "var root = getRootNode(arguments[0]);" +
            "return root !== document && root.host !== undefined;";

        return (Boolean) js.executeScript(script, element);
    }
}

// 3. Shadow DOM Wrapper Class
public class ShadowDOMWrapper {
    private WebDriver driver;
    private JavascriptExecutor js;
    private static final Logger logger = LogManager.getLogger(ShadowDOMWrapper.class);

    public ShadowDOMWrapper(WebDriver driver) {
        this.driver = driver;
        this.js = (JavascriptExecutor) driver;
    }

    // Generic method to find shadow element
    public WebElement findShadowElement(String... selectors) {
        if (selectors.length < 2) {
            throw new IllegalArgumentException("Need at least host and element selector");
        }

        try {
            // Try Selenium 4 native method first
            return findShadowElementNative(selectors);
        } catch (Exception e) {
            logger.warn("Native shadow DOM access failed, using JavaScript");
            return findShadowElementJS(selectors);
        }
    }

    // Selenium 4 native approach
    private WebElement findShadowElementNative(String... selectors) {
        SearchContext context = driver;

        for (int i = 0; i < selectors.length - 1; i++) {
            WebElement host = context.findElement(By.cssSelector(selectors[i]));
            context = host.getShadowRoot();
        }

        return context.findElement(By.cssSelector(selectors[selectors.length - 1]));
    }

    // JavaScript fallback approach
    private WebElement findShadowElementJS(String... selectors) {
        StringBuilder script = new StringBuilder("var element = document;");

        for (int i = 0; i < selectors.length - 1; i++) {
            script.append(String.format(
                "element = element.querySelector('%s').shadowRoot;",
                selectors[i]));
        }

        script.append(String.format(
            "return element.querySelector('%s');",
            selectors[selectors.length - 1]));

        return (WebElement) js.executeScript(script.toString());
    }

    // Click shadow element
    public void clickShadowElement(String... selectors) {
        WebElement element = findShadowElement(selectors);
        element.click();
        logger.info("Clicked shadow element");
    }

    // Type text in shadow element
    public void typeShadowElement(String text, String... selectors) {
        WebElement element = findShadowElement(selectors);
        element.clear();
        element.sendKeys(text);
        logger.info("Typed text in shadow element");
    }

    // Get text from shadow element
    public String getShadowElementText(String... selectors) {
        WebElement element = findShadowElement(selectors);
        return element.getText();
    }

    // Check if shadow element exists
    public boolean isShadowElementPresent(String... selectors) {
        try {
            WebElement element = findShadowElement(selectors);
            return element != null;
        } catch (NoSuchElementException e) {
            return false;
        }
    }

    // Wait for shadow element
    public WebElement waitForShadowElement(int timeoutSeconds, String... selectors) {
        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeoutSeconds));

        return wait.until(driver -> {
            try {
                return findShadowElement(selectors);
            } catch (NoSuchElementException e) {
                return null;
            }
        });
    }
}

// 4. Shadow DOM Page Object Example
public class ShadowDOMPage extends BasePage {
    private ShadowDOMWrapper shadowDOM;

    // Shadow host selectors
    private static final String CUSTOM_COMPONENT = "custom-component";
    private static final String INNER_COMPONENT = "inner-component";

    // Shadow element selectors
    private static final String USERNAME_INPUT = "input[name='username']";
    private static final String PASSWORD_INPUT = "input[name='password']";
    private static final String LOGIN_BUTTON = "button.login-btn";

    public ShadowDOMPage(WebDriver driver) {
        super(driver);
        this.shadowDOM = new ShadowDOMWrapper(driver);
    }

    public void login(String username, String password) {
        // Access username input inside shadow DOM
        shadowDOM.typeShadowElement(username, CUSTOM_COMPONENT, USERNAME_INPUT);

        // Access password input inside nested shadow DOM
        shadowDOM.typeShadowElement(password,
            CUSTOM_COMPONENT, INNER_COMPONENT, PASSWORD_INPUT);

        // Click login button
        shadowDOM.clickShadowElement(CUSTOM_COMPONENT, LOGIN_BUTTON);

        logger.info("Performed login through shadow DOM elements");
    }

    public String getErrorMessage() {
        return shadowDOM.getShadowElementText(CUSTOM_COMPONENT, ".error-message");
    }

    public boolean isLoginButtonEnabled() {
        WebElement button = shadowDOM.findShadowElement(CUSTOM_COMPONENT, LOGIN_BUTTON);
        return button.isEnabled();
    }
}

// 5. Handling Closed Shadow DOM
public class ClosedShadowDOMHandler {
    private JavascriptExecutor js;

    public ClosedShadowDOMHandler(WebDriver driver) {
        this.js = (JavascriptExecutor) driver;
    }

    // Closed shadow roots are not accessible via standard methods
    // This is a workaround (may not work for all cases)
    public WebElement accessClosedShadowDOM(String hostSelector, String elementSelector) {
        // Store reference to shadowRoot during creation (requires modifying page)
        String script =
            "var host = document.querySelector(arguments[0]);" +
            "if (host._shadowRoot) {" +  // Assuming shadowRoot was stored
            "  return host._shadowRoot.querySelector(arguments[1]);" +
            "}" +
            "return null;";

        return (WebElement) js.executeScript(script, hostSelector, elementSelector);
    }

    // Alternative: Patch Element.attachShadow to store reference
    public void patchAttachShadow() {
        String script =
            "const originalAttachShadow = Element.prototype.attachShadow;" +
            "Element.prototype.attachShadow = function(init) {" +
            "  const shadowRoot = originalAttachShadow.call(this, init);" +
            "  this._shadowRoot = shadowRoot;" +
            "  return shadowRoot;" +
            "};";

        js.executeScript(script);
    }
}

// 6. Shadow DOM Utility Methods
public class ShadowDOMUtils {

    // Expand all shadow roots on page (for debugging)
    public static void expandAllShadowRoots(WebDriver driver) {
        JavascriptExecutor js = (JavascriptExecutor) driver;

        String script =
            "function expandShadowRoots(node) {" +
            "  if (node.shadowRoot) {" +
            "    node.shadowRoot._expanded = true;" +
            "    Array.from(node.shadowRoot.children).forEach(expandShadowRoots);" +
            "  }" +
            "  Array.from(node.children).forEach(expandShadowRoots);" +
            "}" +
            "expandShadowRoots(document.body);";

        js.executeScript(script);
    }

    // Count shadow roots on page
    public static int countShadowRoots(WebDriver driver) {
        JavascriptExecutor js = (JavascriptExecutor) driver;

        String script =
            "function countShadows(node) {" +
            "  let count = 0;" +
            "  if (node.shadowRoot) {" +
            "    count++;" +
            "    Array.from(node.shadowRoot.children).forEach(child => {" +
            "      count += countShadows(child);" +
            "    });" +
            "  }" +
            "  Array.from(node.children).forEach(child => {" +
            "    count += countShadows(child);" +
            "  });" +
            "  return count;" +
            "}" +
            "return countShadows(document.body);";

        Long count = (Long) js.executeScript(script);
        return count.intValue();
    }

    // Get shadow DOM structure (for debugging)
    public static String getShadowDOMStructure(WebDriver driver) {
        JavascriptExecutor js = (JavascriptExecutor) driver;

        String script =
            "function getStructure(node, indent = '') {" +
            "  let structure = indent + node.tagName;" +
            "  if (node.id) structure += '#' + node.id;" +
            "  if (node.className) structure += '.' + node.className.split(' ').join('.');" +
            "  structure += '\\n';" +
            "" +
            "  if (node.shadowRoot) {" +
            "    structure += indent + ' [Shadow Root]\\n';" +
            "    Array.from(node.shadowRoot.children).forEach(child => {" +
            "      structure += getStructure(child, indent + '  ');" +
            "    });" +
            "  }" +
            "" +
            "  Array.from(node.children).forEach(child => {" +
            "    structure += getStructure(child, indent + '  ');" +
            "  });" +
            "" +
            "  return structure;" +
            "}" +
            "return getStructure(document.body);";

        return (String) js.executeScript(script);
    }
}

// 7. Test Examples
public class ShadowDOMTests {
    private WebDriver driver;
    private ShadowDOMWrapper shadowDOM;

    @BeforeMethod
    public void setUp() {
        driver = new ChromeDriver();
        shadowDOM = new ShadowDOMWrapper(driver);
    }

    @Test
    public void testSingleShadowDOM() {
        driver.get("https://example.com/shadow-dom");

        // Access element in single shadow DOM
        WebElement element = shadowDOM.findShadowElement(
            "#shadow-host",
            ".shadow-element"
        );

        element.click();
        Assert.assertTrue(element.getAttribute("class").contains("active"));
    }

    @Test
    public void testNestedShadowDOM() {
        driver.get("https://example.com/nested-shadow");

        // Navigate through nested shadow DOMs
        shadowDOM.clickShadowElement(
            "#outer-host",
            "#inner-host",
            "button.submit"
        );

        // Verify action
        String message = shadowDOM.getShadowElementText(
            "#outer-host",
            "#inner-host",
            ".success-message"
        );

        Assert.assertEquals(message, "Success!");
    }

    @Test
    public void testShadowDOMPageObject() {
        driver.get("https://example.com/login");

        ShadowDOMPage loginPage = new ShadowDOMPage(driver);
        loginPage.login("testuser", "password123");

        Assert.assertTrue(driver.getCurrentUrl().contains("/dashboard"));
    }

    @Test
    public void testWaitForShadowElement() {
        driver.get("https://example.com/dynamic-shadow");

        // Wait for shadow element to appear
        WebElement element = shadowDOM.waitForShadowElement(10,
            "#shadow-host",
            ".dynamic-element"
        );

        Assert.assertNotNull(element);
        Assert.assertTrue(element.isDisplayed());
    }

    @AfterMethod
    public void tearDown() {
        if (driver != null) {
            driver.quit();
        }
    }
}
```

**Follow-up**: How do you handle closed shadow DOM? What are the limitations of shadow DOM testing? How to debug shadow DOM elements? How does shadow DOM affect test performance?

---

### Q87: How do you handle advanced iFrame scenarios including nested iFrames and dynamic iFrames?

**Answer**:
iFrames (inline frames) require explicit context switching in Selenium using `switchTo().frame()`. Advanced scenarios include nested iFrames (frames within frames), dynamically loaded iFrames, unnamed iFrames, iFrames with changing indices, and cross-origin iFrames. Proper iFrame handling requires understanding frame hierarchy, implementing wait strategies for frame availability, switching back to parent/default content, handling frame refreshes, and managing frame timeouts. Modern applications may have complex frame structures requiring systematic navigation strategies.

**Experience Level**: 3-5 years, 6-8 years, 9-12 years
**Difficulty**: Medium to Hard
**Companies**: Applications with embedded content, legacy applications, banking applications

**Code Examples**:

```java
// 1. Basic iFrame Handling
public class BasiciFrameHandler {
    private WebDriver driver;
    private WebDriverWait wait;

    public BasiciFrameHandler(WebDriver driver) {
        this.driver = driver;
        this.wait = new WebDriverWait(driver, Duration.ofSeconds(10));
    }

    // Switch to frame by index
    public void switchToFrameByIndex(int index) {
        wait.until(ExpectedConditions.frameToBeAvailableAndSwitchToIt(index));
    }

    // Switch to frame by name or ID
    public void switchToFrameByNameOrId(String nameOrId) {
        wait.until(ExpectedConditions.frameToBeAvailableAndSwitchToIt(nameOrId));
    }

    // Switch to frame by WebElement
    public void switchToFrameByElement(WebElement frameElement) {
        wait.until(ExpectedConditions.frameToBeAvailableAndSwitchToIt(frameElement));
    }

    // Switch back to default content
    public void switchToDefaultContent() {
        driver.switchTo().defaultContent();
    }

    // Switch to parent frame
    public void switchToParentFrame() {
        driver.switchTo().parentFrame();
    }

    // Complete example
    public void accessElementIniFrame() {
        // Find frame element
        WebElement frameElement = driver.findElement(By.id("myFrame"));

        // Switch to frame
        switchToFrameByElement(frameElement);

        // Interact with elements inside frame
        WebElement element = driver.findElement(By.id("element-in-frame"));
        element.click();

        // Switch back to main content
        switchToDefaultContent();
    }
}

// 2. Nested iFrame Handler
public class NestedIFrameHandler {
    private WebDriver driver;
    private WebDriverWait wait;
    private Stack<String> frameStack;
    private static final Logger logger = LogManager.getLogger(NestedIFrameHandler.class);

    public NestedIFrameHandler(WebDriver driver) {
        this.driver = driver;
        this.wait = new WebDriverWait(driver, Duration.ofSeconds(15));
        this.frameStack = new Stack<>();
    }

    // Navigate through nested frames
    public void switchToNestedFrame(String... frameIdentifiers) {
        // First, switch to default content
        driver.switchTo().defaultContent();
        frameStack.clear();

        // Navigate through each frame level
        for (String identifier : frameIdentifiers) {
            wait.until(ExpectedConditions.frameToBeAvailableAndSwitchToIt(identifier));
            frameStack.push(identifier);
            logger.info("Switched to frame: {}", identifier);
        }
    }

    // Navigate through nested frames by WebElements
    public void switchToNestedFrameByElements(List<By> frameLocators) {
        driver.switchTo().defaultContent();

        for (By locator : frameLocators) {
            WebElement frame = wait.until(ExpectedConditions.presenceOfElementLocated(locator));
            wait.until(ExpectedConditions.frameToBeAvailableAndSwitchToIt(frame));
            logger.info("Switched to frame: {}", locator);
        }
    }

    // Navigate up one level in frame hierarchy
    public void switchToParentFrame() {
        if (!frameStack.isEmpty()) {
            driver.switchTo().parentFrame();
            frameStack.pop();
            logger.info("Switched to parent frame");
        } else {
            logger.warn("Already at default content");
        }
    }

    // Navigate to root (default content)
    public void switchToRoot() {
        driver.switchTo().defaultContent();
        frameStack.clear();
        logger.info("Switched to default content");
    }

    // Get current frame depth
    public int getFrameDepth() {
        return frameStack.size();
    }

    // Example: Access element in deeply nested frame
    public void accessDeepNestedElement() {
        // Navigate through 3 levels of frames
        switchToNestedFrame("frame1", "frame2", "frame3");

        // Access element in deepest frame
        WebElement element = driver.findElement(By.id("deep-element"));
        element.click();

        // Navigate back to root
        switchToRoot();
    }
}

// 3. Dynamic iFrame Handler
public class DynamiciFrameHandler {
    private WebDriver driver;
    private WebDriverWait wait;

    public DynamiciFrameHandler(WebDriver driver) {
        this.driver = driver;
        this.wait = new WebDriverWait(driver, Duration.ofSeconds(15));
    }

    // Wait for frame to load and switch
    public void waitAndSwitchToFrame(By frameLocator) {
        // Wait for frame element to be present
        WebElement frame = wait.until(ExpectedConditions.presenceOfElementLocated(frameLocator));

        // Wait for frame to be available and switch
        wait.until(ExpectedConditions.frameToBeAvailableAndSwitchToIt(frame));
    }

    // Wait for frame with specific attribute
    public void waitForFrameWithAttribute(String attribute, String value) {
        By frameLocator = By.cssSelector(String.format("iframe[%s='%s']", attribute, value));
        waitAndSwitchToFrame(frameLocator);
    }

    // Switch to frame by partial src
    public void switchToFrameByPartialSrc(String partialSrc) {
        By frameLocator = By.cssSelector(String.format("iframe[src*='%s']", partialSrc));
        waitAndSwitchToFrame(frameLocator);
    }

    // Wait for frame content to load
    public void waitForFrameContent(String frameId, By contentLocator) {
        // Switch to frame
        wait.until(ExpectedConditions.frameToBeAvailableAndSwitchToIt(frameId));

        // Wait for specific content inside frame
        wait.until(ExpectedConditions.presenceOfElementLocated(contentLocator));
    }

    // Handle dynamically added frames
    public void handleDynamicFrame(int expectedFrameCount, String targetFrameSrc) {
        // Wait for expected number of frames
        wait.until(driver -> {
            List<WebElement> frames = driver.findElements(By.tagName("iframe"));
            return frames.size() >= expectedFrameCount;
        });

        // Find and switch to specific frame
        List<WebElement> frames = driver.findElements(By.tagName("iframe"));
        for (WebElement frame : frames) {
            String src = frame.getAttribute("src");
            if (src != null && src.contains(targetFrameSrc)) {
                driver.switchTo().frame(frame);
                break;
            }
        }
    }
}

// 4. iFrame Utility Class
public class IFrameUtils {
    private static final Logger logger = LogManager.getLogger(IFrameUtils.class);

    // Get total frame count
    public static int getFrameCount(WebDriver driver) {
        List<WebElement> frames = driver.findElements(By.tagName("iframe"));
        logger.info("Found {} frames", frames.size());
        return frames.size();
    }

    // Get frame details
    public static List<Map<String, String>> getFrameDetails(WebDriver driver) {
        List<Map<String, String>> frameDetails = new ArrayList<>();
        List<WebElement> frames = driver.findElements(By.tagName("iframe"));

        for (int i = 0; i < frames.size(); i++) {
            WebElement frame = frames.get(i);
            Map<String, String> details = new HashMap<>();
            details.put("index", String.valueOf(i));
            details.put("id", frame.getAttribute("id"));
            details.put("name", frame.getAttribute("name"));
            details.put("src", frame.getAttribute("src"));
            details.put("title", frame.getAttribute("title"));
            frameDetails.add(details);
        }

        return frameDetails;
    }

    // Print frame hierarchy
    public static void printFrameHierarchy(WebDriver driver) {
        printFrameHierarchy(driver, "", 0);
    }

    private static void printFrameHierarchy(WebDriver driver, String indent, int level) {
        List<WebElement> frames = driver.findElements(By.tagName("iframe"));

        for (int i = 0; i < frames.size(); i++) {
            WebElement frame = frames.get(i);
            String frameInfo = String.format("%sFrame %d: id=%s, name=%s, src=%s",
                indent,
                i,
                frame.getAttribute("id"),
                frame.getAttribute("name"),
                frame.getAttribute("src"));
            logger.info(frameInfo);

            // Switch into frame and print its children
            driver.switchTo().frame(frame);
            printFrameHierarchy(driver, indent + "  ", level + 1);
            driver.switchTo().parentFrame();
        }
    }

    // Check if element is in frame
    public static boolean isElementInFrame(WebDriver driver, By elementLocator) {
        try {
            driver.findElement(elementLocator);
            return false; // Found in current context
        } catch (NoSuchElementException e) {
            // Check in all frames
            List<WebElement> frames = driver.findElements(By.tagName("iframe"));
            for (WebElement frame : frames) {
                driver.switchTo().frame(frame);
                try {
                    driver.findElement(elementLocator);
                    driver.switchTo().defaultContent();
                    return true; // Found in frame
                } catch (NoSuchElementException ex) {
                    driver.switchTo().defaultContent();
                }
            }
            return false; // Not found anywhere
        }
    }

    // Find frame containing element
    public static WebElement findFrameContainingElement(WebDriver driver, By elementLocator) {
        List<WebElement> frames = driver.findElements(By.tagName("iframe"));

        for (WebElement frame : frames) {
            try {
                driver.switchTo().frame(frame);
                driver.findElement(elementLocator);
                driver.switchTo().defaultContent();
                return frame; // Element found in this frame
            } catch (NoSuchElementException e) {
                driver.switchTo().defaultContent();
            }
        }

        throw new NoSuchElementException("Element not found in any frame");
    }
}

// 5. iFrame Page Object Example
public class IFramePage extends BasePage {
    private NestedIFrameHandler frameHandler;

    // Frame locators
    private static final String MAIN_FRAME = "main-frame";
    private static final String CONTENT_FRAME = "content-frame";

    // Element locators inside frames
    @FindBy(id = "element-in-main-frame")
    private WebElement mainFrameElement;

    @FindBy(id = "element-in-nested-frame")
    private WebElement nestedFrameElement;

    public IFramePage(WebDriver driver) {
        super(driver);
        this.frameHandler = new NestedIFrameHandler(driver);
    }

    public void interactWithMainFrame() {
        // Switch to main frame
        frameHandler.switchToNestedFrame(MAIN_FRAME);

        // Re-initialize elements in frame context
        PageFactory.initElements(driver, this);

        // Interact with element
        mainFrameElement.click();

        // Switch back
        frameHandler.switchToRoot();
    }

    public void interactWithNestedFrame() {
        // Navigate through nested frames
        frameHandler.switchToNestedFrame(MAIN_FRAME, CONTENT_FRAME);

        // Re-initialize elements
        PageFactory.initElements(driver, this);

        // Interact with element in nested frame
        nestedFrameElement.sendKeys("test");

        // Navigate back
        frameHandler.switchToRoot();
    }

    public String getTextFromFrame(String... frameHierarchy) {
        frameHandler.switchToNestedFrame(frameHierarchy);

        String text = driver.findElement(By.className("frame-text")).getText();

        frameHandler.switchToRoot();

        return text;
    }
}

// 6. Advanced iFrame Scenarios
public class AdvancediFrameScenarios {
    private WebDriver driver;
    private WebDriverWait wait;

    public AdvancediFrameScenarios(WebDriver driver) {
        this.driver = driver;
        this.wait = new WebDriverWait(driver, Duration.ofSeconds(15));
    }

    // Scenario 1: Handle frame that refreshes
    public void handleRefreshingFrame(String frameId) {
        for (int i = 0; i < 3; i++) {
            try {
                wait.until(ExpectedConditions.frameToBeAvailableAndSwitchToIt(frameId));

                // Perform action
                WebElement element = wait.until(
                    ExpectedConditions.presenceOfElementLocated(By.id("element")));
                element.click();

                driver.switchTo().defaultContent();
                break;
            } catch (StaleElementReferenceException e) {
                driver.switchTo().defaultContent();
                // Wait before retry
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                }
            }
        }
    }

    // Scenario 2: Handle multiple frames with same content
    public void handleMultipleSimilarFrames(String targetContent) {
        List<WebElement> frames = driver.findElements(By.tagName("iframe"));

        for (WebElement frame : frames) {
            driver.switchTo().frame(frame);

            try {
                WebElement element = driver.findElement(By.tagName("body"));
                if (element.getText().contains(targetContent)) {
                    // Found the right frame
                    return;
                }
            } catch (NoSuchElementException e) {
                // Continue searching
            }

            driver.switchTo().defaultContent();
        }

        throw new NoSuchElementException("Frame with content not found: " + targetContent);
    }

    // Scenario 3: Switch between sibling frames
    public void switchBetweenSiblingFrames(String frame1Id, String frame2Id) {
        // Switch to first frame
        wait.until(ExpectedConditions.frameToBeAvailableAndSwitchToIt(frame1Id));
        WebElement element1 = driver.findElement(By.id("data"));
        String data = element1.getText();

        // Switch back to parent, then to sibling frame
        driver.switchTo().parentFrame();
        wait.until(ExpectedConditions.frameToBeAvailableAndSwitchToIt(frame2Id));

        // Use data from first frame
        WebElement element2 = driver.findElement(By.id("input"));
        element2.sendKeys(data);

        driver.switchTo().defaultContent();
    }

    // Scenario 4: Handle cross-origin frames (limited access)
    public void handleCrossOriginFrame(String frameId) {
        try {
            wait.until(ExpectedConditions.frameToBeAvailableAndSwitchToIt(frameId));

            // Limited operations possible with cross-origin frames
            // Can switch but may not access content

            driver.switchTo().defaultContent();
        } catch (WebDriverException e) {
            // Cross-origin frame may not be accessible
            throw new RuntimeException("Cannot access cross-origin frame", e);
        }
    }

    // Scenario 5: Handle frameset (deprecated but still used)
    public void handleFrameset(String topFrameName, String bottomFrameName) {
        // Switch to top frame in frameset
        wait.until(ExpectedConditions.frameToBeAvailableAndSwitchToIt(topFrameName));
        WebElement topElement = driver.findElement(By.id("top-content"));
        topElement.click();

        // Switch to default, then to bottom frame
        driver.switchTo().defaultContent();
        wait.until(ExpectedConditions.frameToBeAvailableAndSwitchToIt(bottomFrameName));
        WebElement bottomElement = driver.findElement(By.id("bottom-content"));
        bottomElement.click();

        driver.switchTo().defaultContent();
    }
}

// 7. Test Examples
public class IFrameTests {
    private WebDriver driver;
    private NestedIFrameHandler frameHandler;

    @BeforeMethod
    public void setUp() {
        driver = new ChromeDriver();
        frameHandler = new NestedIFrameHandler(driver);
    }

    @Test
    public void testBasicFrame() {
        driver.get("https://the-internet.herokuapp.com/iframe");

        // Switch to frame
        driver.switchTo().frame("mce_0_ifr");

        // Interact with element in frame
        WebElement editor = driver.findElement(By.id("tinymce"));
        editor.clear();
        editor.sendKeys("Test content");

        // Switch back
        driver.switchTo().defaultContent();

        Assert.assertTrue(driver.getTitle().contains("Frame"));
    }

    @Test
    public void testNestedFrames() {
        driver.get("https://the-internet.herokuapp.com/nested_frames");

        // Navigate to nested frame
        frameHandler.switchToNestedFrame("frame-top", "frame-middle");

        // Get text from nested frame
        WebElement content = driver.findElement(By.id("content"));
        String text = content.getText();

        Assert.assertEquals(text, "MIDDLE");

        // Switch back
        frameHandler.switchToRoot();
    }

    @Test
    public void testDynamicFrame() {
        driver.get("https://example.com/dynamic-frame");

        DynamiciFrameHandler dynamicHandler = new DynamiciFrameHandler(driver);

        // Wait for frame and switch
        dynamicHandler.switchToFrameByPartialSrc("content");

        // Verify frame content loaded
        WebElement element = new WebDriverWait(driver, Duration.ofSeconds(10))
            .until(ExpectedConditions.presenceOfElementLocated(By.className("frame-content")));

        Assert.assertTrue(element.isDisplayed());

        driver.switchTo().defaultContent();
    }

    @Test
    public void testFrameHierarchy() {
        driver.get("https://example.com/frames");

        // Print frame structure for debugging
        IFrameUtils.printFrameHierarchy(driver);

        // Get frame count
        int frameCount = IFrameUtils.getFrameCount(driver);
        Assert.assertTrue(frameCount > 0);
    }

    @AfterMethod
    public void tearDown() {
        if (driver != null) {
            driver.quit();
        }
    }
}
```

**Follow-up**: How do you handle frameset vs iframe? What are cross-origin frame limitations? How to debug frame-related issues? How does frame switching affect test performance?

---

### Q88: How do you handle Web Components and Custom Elements in Selenium?

**Answer**:
Web Components are reusable custom HTML elements built using standard web technologies including Custom Elements, Shadow DOM, and HTML Templates. Testing web components requires understanding component lifecycle, accessing shadow DOM, handling custom events, testing component slots, and verifying component attributes/properties. Modern frameworks like Lit, Polymer, and Stencil extensively use web components. Selenium testing must account for encapsulation, custom element registration, attribute vs property differences, and component state management.

**Experience Level**: 6-8 years, 9-12 years
**Difficulty**: Hard
**Companies**: Modern frontend applications, Design System companies (Salesforce Lightning, Shopify Polaris)

**Code Examples**:

```java
// 1. Web Component Basics
public class WebComponentHandler {
    private WebDriver driver;
    private JavascriptExecutor js;
    private ShadowDOMWrapper shadowDOM;

    public WebComponentHandler(WebDriver driver) {
        this.driver = driver;
        this.js = (JavascriptExecutor) driver;
        this.shadowDOM = new ShadowDOMWrapper(driver);
    }

    // Check if element is a custom element
    public boolean isCustomElement(WebElement element) {
        String script =
            "return arguments[0].tagName.includes('-') && " +
            "customElements.get(arguments[0].tagName.toLowerCase()) !== undefined;";

        return (Boolean) js.executeScript(script, element);
    }

    // Wait for custom element to be defined
    public void waitForCustomElementDefined(String tagName) {
        String script =
            "return customElements.whenDefined(arguments[0]);";

        js.executeAsync(script, tagName);
    }

    // Get custom element definition
    public boolean isElementDefined(String tagName) {
        String script =
            "return customElements.get(arguments[0]) !== undefined;";

        return (Boolean) js.executeScript(script, tagName);
    }

    // Access custom element property (not attribute)
    public Object getElementProperty(WebElement element, String property) {
        String script =
            "return arguments[0][arguments[1]];";

        return js.executeScript(script, element, property);
    }

    // Set custom element property
    public void setElementProperty(WebElement element, String property, Object value) {
        String script =
            "arguments[0][arguments[1]] = arguments[2];";

        js.executeScript(script, element, property, value);
    }

    // Trigger custom event
    public void triggerCustomEvent(WebElement element, String eventName, Map<String, Object> detail) {
        String detailJson = new Gson().toJson(detail);

        String script =
            "var event = new CustomEvent(arguments[1], { detail: " + detailJson + " });" +
            "arguments[0].dispatchEvent(event);";

        js.executeScript(script, element, eventName);
    }

    // Wait for custom event
    public void waitForCustomEvent(WebElement element, String eventName, int timeoutSeconds) {
        String script =
            "var element = arguments[0];" +
            "var eventName = arguments[1];" +
            "var callback = arguments[2];" +
            "" +
            "element.addEventListener(eventName, function handler(event) {" +
            "  element.removeEventListener(eventName, handler);" +
            "  callback(event.detail);" +
            "});";

        js.executeAsyncScript(script, element, eventName);
    }
}

// 2. Custom Element Locators
public class CustomElementLocators {

    // Find custom element by tag name
    public static By customElement(String tagName) {
        return By.cssSelector(tagName);
    }

    // Find custom element with attribute
    public static By customElementWithAttribute(String tagName, String attr, String value) {
        return By.cssSelector(String.format("%s[%s='%s']", tagName, attr, value));
    }

    // Find custom element with slot
    public static By customElementSlot(String tagName, String slotName) {
        return By.cssSelector(String.format("%s [slot='%s']", tagName, slotName));
    }

    // Find element inside custom element's shadow DOM
    public static String[] customElementShadow(String tagName, String shadowSelector) {
        return new String[]{tagName, shadowSelector};
    }
}

// 3. Web Component Page Object
public class WebComponentPage extends BasePage {
    private WebComponentHandler componentHandler;
    private ShadowDOMWrapper shadowDOM;

    // Custom element selectors
    private static final String USER_CARD = "user-card";
    private static final String MODAL_DIALOG = "modal-dialog";
    private static final String DATA_TABLE = "data-table";

    public WebComponentPage(WebDriver driver) {
        super(driver);
        this.componentHandler = new WebComponentHandler(driver);
        this.shadowDOM = new ShadowDOMWrapper(driver);
    }

    // Interact with user-card component
    public void clickUserCard(String userId) {
        // Find user card by attribute
        By cardLocator = CustomElementLocators.customElementWithAttribute(
            USER_CARD, "user-id", userId);

        WebElement card = driver.findElement(cardLocator);

        // Access button inside shadow DOM
        WebElement button = shadowDOM.findShadowElement(
            USER_CARD + "[user-id='" + userId + "']",
            "button.card-action"
        );

        button.click();
    }

    // Get user card data
    public Map<String, Object> getUserCardData(String userId) {
        WebElement card = driver.findElement(
            By.cssSelector(USER_CARD + "[user-id='" + userId + "']"));

        Map<String, Object> data = new HashMap<>();
        data.put("name", componentHandler.getElementProperty(card, "userName"));
        data.put("email", componentHandler.getElementProperty(card, "userEmail"));
        data.put("active", componentHandler.getElementProperty(card, "isActive"));

        return data;
    }

    // Open modal dialog component
    public void openModal(String title, String content) {
        // Find or create modal
        WebElement modal = driver.findElement(By.cssSelector(MODAL_DIALOG));

        // Set properties
        componentHandler.setElementProperty(modal, "title", title);
        componentHandler.setElementProperty(modal, "content", content);
        componentHandler.setElementProperty(modal, "open", true);
    }

    // Close modal and wait for closed event
    public void closeModal() {
        WebElement modal = driver.findElement(By.cssSelector(MODAL_DIALOG));

        // Click close button in shadow DOM
        WebElement closeBtn = shadowDOM.findShadowElement(
            MODAL_DIALOG,
            "button.close-btn"
        );

        closeBtn.click();

        // Wait for modal to close
        new WebDriverWait(driver, Duration.ofSeconds(5))
            .until(driver -> {
                Boolean isOpen = (Boolean) componentHandler.getElementProperty(modal, "open");
                return !isOpen;
            });
    }

    // Interact with data-table component
    public void sortTable(String columnName) {
        WebElement table = driver.findElement(By.cssSelector(DATA_TABLE));

        // Find column header in shadow DOM and click
        WebElement header = shadowDOM.findShadowElement(
            DATA_TABLE,
            String.format("th[data-column='%s']", columnName)
        );

        header.click();

        // Wait for sorted event
        componentHandler.waitForCustomEvent(table, "sorted", 5);
    }

    public List<String> getTableColumnData(String columnName) {
        WebElement table = driver.findElement(By.cssSelector(DATA_TABLE));

        // Access table data through component property
        List<?> data = (List<?>) componentHandler.getElementProperty(table, "data");

        List<String> columnData = new ArrayList<>();
        for (Object row : data) {
            Map<String, Object> rowMap = (Map<String, Object>) row;
            columnData.add(rowMap.get(columnName).toString());
        }

        return columnData;
    }
}

// 4. Component Testing Utilities
public class ComponentTestUtils {

    // Wait for component to be fully loaded
    public static void waitForComponentReady(WebDriver driver, WebElement component) {
        JavascriptExecutor js = (JavascriptExecutor) driver;

        // Wait for component's connectedCallback to complete
        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
        wait.until(d -> {
            String script =
                "return arguments[0].shadowRoot !== null && " +
                "arguments[0].getAttribute('ready') === 'true';";
            return (Boolean) js.executeScript(script, component);
        });
    }

    // Get component lifecycle state
    public static String getComponentLifecycleState(WebDriver driver, WebElement component) {
        JavascriptExecutor js = (JavascriptExecutor) driver;

        String script =
            "if (!arguments[0].isConnected) return 'disconnected';" +
            "if (arguments[0].shadowRoot === null) return 'not-attached';" +
            "return 'ready';";

        return (String) js.executeScript(script, component);
    }

    // Trigger component update
    public static void triggerComponentUpdate(WebDriver driver, WebElement component) {
        JavascriptExecutor js = (JavascriptExecutor) driver;

        String script =
            "if (arguments[0].requestUpdate) {" +
            "  arguments[0].requestUpdate();" +
            "} else if (arguments[0].forceUpdate) {" +
            "  arguments[0].forceUpdate();" +
            "}";

        js.executeScript(script, component);
    }

    // Get all slots in component
    public static List<String> getComponentSlots(WebDriver driver, WebElement component) {
        JavascriptExecutor js = (JavascriptExecutor) driver;

        String script =
            "var slots = arguments[0].shadowRoot.querySelectorAll('slot');" +
            "return Array.from(slots).map(slot => slot.getAttribute('name') || 'default');";

        return (List<String>) js.executeScript(script, component);
    }

    // Check if slot has content
    public static boolean hasSlotContent(WebDriver driver, WebElement component, String slotName) {
        JavascriptExecutor js = (JavascriptExecutor) driver;

        String script =
            "var slot = arguments[0].shadowRoot.querySelector('slot[name=\"' + arguments[1] + '\"]');" +
            "if (!slot) return false;" +
            "var assigned = slot.assignedNodes();" +
            "return assigned.length > 0;";

        return (Boolean) js.executeScript(script, component, slotName);
    }
}

// 5. Lit Component Handler (Specific to Lit framework)
public class LitComponentHandler extends WebComponentHandler {

    public LitComponentHandler(WebDriver driver) {
        super(driver);
    }

    // Wait for Lit component to complete update
    public void waitForLitUpdate(WebElement component) {
        String script =
            "var callback = arguments[1];" +
            "arguments[0].updateComplete.then(() => callback());";

        js.executeAsyncScript(script, component);
    }

    // Get Lit component state
    public Map<String, Object> getLitComponentState(WebElement component) {
        String script =
            "var props = {};" +
            "for (let key in arguments[0]) {" +
            "  if (arguments[0].constructor.properties && " +
            "      arguments[0].constructor.properties[key]) {" +
            "    props[key] = arguments[0][key];" +
            "  }" +
            "}" +
            "return props;";

        return (Map<String, Object>) js.executeScript(script, component);
    }

    // Update Lit component property and wait
    public void updateLitProperty(WebElement component, String property, Object value) {
        setElementProperty(component, property, value);
        waitForLitUpdate(component);
    }
}

// 6. Complex Web Component Test Scenarios
public class ComplexWebComponentScenarios {
    private WebDriver driver;
    private WebComponentHandler componentHandler;
    private ShadowDOMWrapper shadowDOM;

    public ComplexWebComponentScenarios(WebDriver driver) {
        this.driver = driver;
        this.componentHandler = new WebComponentHandler(driver);
        this.shadowDOM = new ShadowDOMWrapper(driver);
    }

    // Scenario 1: Test component with slots
    public void testComponentWithSlots() {
        driver.get("https://example.com/components");

        // Find component
        WebElement card = driver.findElement(By.cssSelector("custom-card"));

        // Add content to header slot
        JavascriptExecutor js = (JavascriptExecutor) driver;
        String script =
            "var header = document.createElement('h2');" +
            "header.setAttribute('slot', 'header');" +
            "header.textContent = 'Test Header';" +
            "arguments[0].appendChild(header);";
        js.executeScript(script, card);

        // Verify slot content rendered
        WebElement headerInShadow = shadowDOM.findShadowElement(
            "custom-card",
            "slot[name='header']"
        );

        Assert.assertTrue(headerInShadow.isDisplayed());
    }

    // Scenario 2: Test component communication
    public void testComponentCommunication() {
        // Component A dispatches event
        WebElement componentA = driver.findElement(By.cssSelector("component-a"));

        Map<String, Object> eventData = new HashMap<>();
        eventData.put("message", "Hello");
        eventData.put("timestamp", System.currentTimeMillis());

        componentHandler.triggerCustomEvent(componentA, "data-updated", eventData);

        // Component B receives event and updates
        WebElement componentB = driver.findElement(By.cssSelector("component-b"));

        // Verify Component B received and processed event
        String message = (String) componentHandler.getElementProperty(componentB, "receivedMessage");
        Assert.assertEquals(message, "Hello");
    }

    // Scenario 3: Test dynamic component creation
    public void testDynamicComponentCreation() {
        JavascriptExecutor js = (JavascriptExecutor) driver;

        // Create component dynamically
        String script =
            "var component = document.createElement('dynamic-component');" +
            "component.setAttribute('data-id', '123');" +
            "component.setAttribute('title', 'Test Component');" +
            "document.body.appendChild(component);" +
            "return component;";

        WebElement component = (WebElement) js.executeScript(script);

        // Wait for component to be defined and rendered
        ComponentTestUtils.waitForComponentReady(driver, component);

        // Interact with component
        WebElement button = shadowDOM.findShadowElement(
            "dynamic-component[data-id='123']",
            "button.action-btn"
        );

        button.click();

        // Verify action
        Boolean actionCompleted = (Boolean) componentHandler.getElementProperty(
            component, "actionCompleted");
        Assert.assertTrue(actionCompleted);
    }

    // Scenario 4: Test component lifecycle
    public void testComponentLifecycle() {
        WebElement component = driver.findElement(By.cssSelector("lifecycle-component"));

        // Component is connected
        Assert.assertEquals(
            ComponentTestUtils.getComponentLifecycleState(driver, component),
            "ready"
        );

        // Remove component
        JavascriptExecutor js = (JavascriptExecutor) driver;
        js.executeScript("arguments[0].remove();", component);

        // Verify disconnected
        try {
            component.isDisplayed();
            Assert.fail("Component should be removed");
        } catch (StaleElementReferenceException e) {
            // Expected - component was removed
        }
    }

    // Scenario 5: Test form-associated custom element
    public void testFormAssociatedElement() {
        WebElement form = driver.findElement(By.cssSelector("form"));
        WebElement customInput = form.findElement(By.cssSelector("custom-input"));

        // Set value on custom input
        componentHandler.setElementProperty(customInput, "value", "test@example.com");

        // Submit form
        form.submit();

        // Verify form data includes custom element value
        String formData = (String) ((JavascriptExecutor) driver).executeScript(
            "return new FormData(arguments[0]).get('email');", form);

        Assert.assertEquals(formData, "test@example.com");
    }
}

// 7. Test Examples
public class WebComponentTests {
    private WebDriver driver;
    private WebComponentHandler componentHandler;
    private WebComponentPage componentPage;

    @BeforeMethod
    public void setUp() {
        driver = new ChromeDriver();
        componentHandler = new WebComponentHandler(driver);
        componentPage = new WebComponentPage(driver);
    }

    @Test
    public void testCustomElementDetection() {
        driver.get("https://example.com/components");

        WebElement component = driver.findElement(By.cssSelector("custom-button"));

        // Verify it's a custom element
        Assert.assertTrue(componentHandler.isCustomElement(component));

        // Verify it's defined
        Assert.assertTrue(componentHandler.isElementDefined("custom-button"));
    }

    @Test
    public void testComponentProperties() {
        driver.get("https://example.com/components");

        WebElement component = driver.findElement(By.cssSelector("user-profile"));

        // Set properties
        componentHandler.setElementProperty(component, "userId", "12345");
        componentHandler.setElementProperty(component, "showAvatar", true);

        // Verify properties
        String userId = (String) componentHandler.getElementProperty(component, "userId");
        Boolean showAvatar = (Boolean) componentHandler.getElementProperty(component, "showAvatar");

        Assert.assertEquals(userId, "12345");
        Assert.assertTrue(showAvatar);
    }

    @Test
    public void testComponentEvents() {
        driver.get("https://example.com/components");

        WebElement button = driver.findElement(By.cssSelector("custom-button"));

        // Trigger custom event
        Map<String, Object> eventDetail = new HashMap<>();
        eventDetail.put("action", "clicked");
        eventDetail.put("count", 1);

        componentHandler.triggerCustomEvent(button, "button-clicked", eventDetail);

        // Verify event was handled
        Integer clickCount = (Integer) componentHandler.getElementProperty(button, "clickCount");
        Assert.assertEquals(clickCount.intValue(), 1);
    }

    @Test
    public void testComponentPageObject() {
        driver.get("https://example.com/dashboard");

        // Test user card interaction
        componentPage.clickUserCard("user-123");

        // Verify modal opened
        Boolean modalOpen = (Boolean) componentHandler.getElementProperty(
            driver.findElement(By.cssSelector("modal-dialog")),
            "open"
        );

        Assert.assertTrue(modalOpen);

        // Close modal
        componentPage.closeModal();
    }

    @AfterMethod
    public void tearDown() {
        if (driver != null) {
            driver.quit();
        }
    }
}
```

**Follow-up**: How do you test component accessibility? How to handle component versioning? What's the difference between attributes and properties in web components? How to test component performance?

---

### **Q89: How do you capture and handle browser console logs and JavaScript errors in Selenium?** (6-8 Years, 9-12 Years)
**Companies**: Google, Microsoft, Amazon, Adobe, Flipkart, Paytm
**Difficulty**: Hard

**Answer**: Browser console logs and JavaScript errors are critical for debugging frontend issues and monitoring application health. Selenium 4 provides robust APIs to capture console logs, JavaScript errors, network logs, and browser warnings. This is particularly important for detecting client-side issues that might not cause test failures but indicate problems. The approach varies by browser, with Chrome/Edge offering the most comprehensive logging capabilities through ChromeDriver. For advanced monitoring, Chrome DevTools Protocol (CDP) provides real-time access to console events, network activity, and performance metrics. Implementing log capturing helps identify flaky tests caused by JavaScript errors, performance issues, and browser warnings.

**Code Example**:

```java
// 1. Console Log Handler (Chrome/Edge)
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.devtools.DevTools;
import org.openqa.selenium.devtools.v120.log.Log;
import org.openqa.selenium.devtools.v120.runtime.Runtime;
import org.openqa.selenium.devtools.v120.runtime.model.ConsoleAPICalled;
import org.openqa.selenium.logging.LogEntries;
import org.openqa.selenium.logging.LogEntry;
import org.openqa.selenium.logging.LogType;

import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.logging.Level;

public class ConsoleLogHandler {
    private ChromeDriver driver;
    private DevTools devTools;
    private List<LogEntry> capturedLogs;
    private List<String> jsErrors;
    private List<String> networkErrors;
    private boolean isMonitoring = false;

    public ConsoleLogHandler(ChromeDriver driver) {
        this.driver = driver;
        this.capturedLogs = new CopyOnWriteArrayList<>();
        this.jsErrors = new CopyOnWriteArrayList<>();
        this.networkErrors = new CopyOnWriteArrayList<>();
        this.devTools = driver.getDevTools();
        this.devTools.createSession();
    }

    // Enable console log capturing using CDP
    public void enableConsoleLogging() {
        // Enable Runtime domain for console events
        devTools.send(Runtime.enable());

        // Listen for console API calls (console.log, console.error, etc.)
        devTools.addListener(Runtime.consoleAPICalled(), consoleEvent -> {
            String type = consoleEvent.getType().toString();
            String message = consoleEvent.getArgs().toString();
            String timestamp = consoleEvent.getTimestamp().toString();

            LogEntry logEntry = new LogEntry(
                Level.parse(type.toUpperCase()),
                timestamp,
                message
            );

            capturedLogs.add(logEntry);

            // Capture JavaScript errors specifically
            if ("error".equalsIgnoreCase(type)) {
                jsErrors.add(message);
                System.err.println("JavaScript Error: " + message);
            }
        });

        // Listen for JavaScript exceptions
        devTools.addListener(Runtime.exceptionThrown(), exception -> {
            String errorMessage = exception.getExceptionDetails().getException().getDescription().orElse("Unknown error");
            String stackTrace = exception.getExceptionDetails().getStackTrace().toString();
            String fullError = String.format("Exception: %s\nStack: %s", errorMessage, stackTrace);

            jsErrors.add(fullError);
            System.err.println("JavaScript Exception: " + fullError);
        });

        // Enable Log domain for browser logs
        devTools.send(Log.enable());

        // Listen for log entries
        devTools.addListener(Log.entryAdded(), logEntry -> {
            String level = logEntry.getLevel().toString();
            String text = logEntry.getText();
            String source = logEntry.getSource().toString();

            if ("error".equalsIgnoreCase(level)) {
                if (source.contains("network")) {
                    networkErrors.add(text);
                } else {
                    jsErrors.add(text);
                }
            }

            System.out.println(String.format("[%s] %s: %s", source, level, text));
        });

        isMonitoring = true;
        System.out.println("Console logging enabled via DevTools Protocol");
    }

    // Get browser logs using traditional LoggingPreferences
    public List<LogEntry> getBrowserLogs() {
        LogEntries logEntries = driver.manage().logs().get(LogType.BROWSER);
        List<LogEntry> logs = new ArrayList<>();

        for (LogEntry entry : logEntries) {
            logs.add(entry);

            // Capture errors
            if (entry.getLevel() == Level.SEVERE) {
                jsErrors.add(entry.getMessage());
            }
        }

        return logs;
    }

    // Get console logs by type
    public List<LogEntry> getLogsByType(String type) {
        return capturedLogs.stream()
            .filter(log -> log.getLevel().toString().equalsIgnoreCase(type))
            .collect(Collectors.toList());
    }

    // Get JavaScript errors
    public List<String> getJavaScriptErrors() {
        return new ArrayList<>(jsErrors);
    }

    // Get network errors
    public List<String> getNetworkErrors() {
        return new ArrayList<>(networkErrors);
    }

    // Check if page has JavaScript errors
    public boolean hasJavaScriptErrors() {
        return !jsErrors.isEmpty();
    }

    // Get error count
    public int getErrorCount() {
        return jsErrors.size();
    }

    // Clear captured logs
    public void clearLogs() {
        capturedLogs.clear();
        jsErrors.clear();
        networkErrors.clear();
    }

    // Get all logs as formatted string
    public String getFormattedLogs() {
        StringBuilder sb = new StringBuilder();
        sb.append("=== Browser Console Logs ===\n");

        for (LogEntry log : capturedLogs) {
            sb.append(String.format("[%s] %s: %s\n",
                new Date(log.getTimestamp()),
                log.getLevel(),
                log.getMessage()
            ));
        }

        return sb.toString();
    }

    // Verify no console errors on page
    public void assertNoConsoleErrors() {
        List<String> errors = getJavaScriptErrors();
        if (!errors.isEmpty()) {
            throw new AssertionError(
                String.format("Found %d console errors:\n%s",
                    errors.size(),
                    String.join("\n", errors)
                )
            );
        }
    }

    // Close DevTools session
    public void close() {
        if (devTools != null && isMonitoring) {
            devTools.close();
            isMonitoring = false;
        }
    }
}

// 2. Network Log Monitor
import org.openqa.selenium.devtools.v120.network.Network;
import org.openqa.selenium.devtools.v120.network.model.*;

public class NetworkLogMonitor {
    private ChromeDriver driver;
    private DevTools devTools;
    private List<RequestInfo> requests;
    private List<ResponseInfo> responses;
    private List<String> failedRequests;

    public NetworkLogMonitor(ChromeDriver driver) {
        this.driver = driver;
        this.devTools = driver.getDevTools();
        this.devTools.createSession();
        this.requests = new CopyOnWriteArrayList<>();
        this.responses = new CopyOnWriteArrayList<>();
        this.failedRequests = new CopyOnWriteArrayList<>();
    }

    // Enable network monitoring
    public void enableNetworkMonitoring() {
        devTools.send(Network.enable(Optional.empty(), Optional.empty(), Optional.empty()));

        // Listen for request sent
        devTools.addListener(Network.requestWillBeSent(), request -> {
            RequestInfo info = new RequestInfo(
                request.getRequestId().toString(),
                request.getRequest().getUrl(),
                request.getRequest().getMethod(),
                request.getType().toString(),
                System.currentTimeMillis()
            );
            requests.add(info);
            System.out.println("Request: " + request.getRequest().getMethod() + " " + request.getRequest().getUrl());
        });

        // Listen for response received
        devTools.addListener(Network.responseReceived(), response -> {
            ResponseInfo info = new ResponseInfo(
                response.getRequestId().toString(),
                response.getResponse().getUrl(),
                response.getResponse().getStatus(),
                response.getResponse().getStatusText(),
                System.currentTimeMillis()
            );
            responses.add(info);

            // Capture failed requests
            if (response.getResponse().getStatus() >= 400) {
                String error = String.format("Failed request: %s (Status: %d %s)",
                    response.getResponse().getUrl(),
                    response.getResponse().getStatus(),
                    response.getResponse().getStatusText()
                );
                failedRequests.add(error);
                System.err.println(error);
            }
        });

        // Listen for loading failed
        devTools.addListener(Network.loadingFailed(), event -> {
            String error = String.format("Loading failed: %s (Error: %s)",
                event.getRequestId(),
                event.getErrorText()
            );
            failedRequests.add(error);
            System.err.println(error);
        });

        System.out.println("Network monitoring enabled");
    }

    // Get all requests
    public List<RequestInfo> getAllRequests() {
        return new ArrayList<>(requests);
    }

    // Get requests by URL pattern
    public List<RequestInfo> getRequestsByUrl(String urlPattern) {
        return requests.stream()
            .filter(req -> req.getUrl().contains(urlPattern))
            .collect(Collectors.toList());
    }

    // Get failed requests
    public List<String> getFailedRequests() {
        return new ArrayList<>(failedRequests);
    }

    // Check for failed requests
    public boolean hasFailedRequests() {
        return !failedRequests.isEmpty();
    }

    // Get requests by type (XHR, Fetch, Document, etc.)
    public List<RequestInfo> getRequestsByType(String type) {
        return requests.stream()
            .filter(req -> req.getType().equalsIgnoreCase(type))
            .collect(Collectors.toList());
    }

    // Clear logs
    public void clearLogs() {
        requests.clear();
        responses.clear();
        failedRequests.clear();
    }

    // Helper classes
    public static class RequestInfo {
        private String requestId;
        private String url;
        private String method;
        private String type;
        private long timestamp;

        public RequestInfo(String requestId, String url, String method, String type, long timestamp) {
            this.requestId = requestId;
            this.url = url;
            this.method = method;
            this.type = type;
            this.timestamp = timestamp;
        }

        // Getters
        public String getRequestId() { return requestId; }
        public String getUrl() { return url; }
        public String getMethod() { return method; }
        public String getType() { return type; }
        public long getTimestamp() { return timestamp; }
    }

    public static class ResponseInfo {
        private String requestId;
        private String url;
        private int status;
        private String statusText;
        private long timestamp;

        public ResponseInfo(String requestId, String url, int status, String statusText, long timestamp) {
            this.requestId = requestId;
            this.url = url;
            this.status = status;
            this.statusText = statusText;
            this.timestamp = timestamp;
        }

        // Getters
        public String getRequestId() { return requestId; }
        public String getUrl() { return url; }
        public int getStatus() { return status; }
        public String getStatusText() { return statusText; }
        public long getTimestamp() { return timestamp; }
    }
}

// 3. Performance Log Analyzer
public class PerformanceLogAnalyzer {
    private ChromeDriver driver;

    public PerformanceLogAnalyzer(ChromeDriver driver) {
        this.driver = driver;
    }

    // Get performance logs
    public List<LogEntry> getPerformanceLogs() {
        LogEntries logEntries = driver.manage().logs().get(LogType.PERFORMANCE);
        List<LogEntry> performanceLogs = new ArrayList<>();

        for (LogEntry entry : logEntries) {
            performanceLogs.add(entry);
        }

        return performanceLogs;
    }

    // Analyze page load performance
    public Map<String, Long> analyzePageLoadTimes() {
        Map<String, Long> metrics = new HashMap<>();

        String script = "var performance = window.performance || window.mozPerformance || " +
                       "window.msPerformance || window.webkitPerformance || {};" +
                       "var timing = performance.timing || {};" +
                       "return {" +
                       "  'navigationStart': timing.navigationStart," +
                       "  'domContentLoaded': timing.domContentLoadedEventEnd - timing.navigationStart," +
                       "  'loadComplete': timing.loadEventEnd - timing.navigationStart," +
                       "  'domInteractive': timing.domInteractive - timing.navigationStart," +
                       "  'firstPaint': performance.getEntriesByType('paint')[0] ? " +
                       "    performance.getEntriesByType('paint')[0].startTime : 0" +
                       "};";

        JavascriptExecutor js = (JavascriptExecutor) driver;
        Map<String, Object> timings = (Map<String, Object>) js.executeScript(script);

        for (Map.Entry<String, Object> entry : timings.entrySet()) {
            metrics.put(entry.getKey(), ((Number) entry.getValue()).longValue());
        }

        return metrics;
    }

    // Get resource timing information
    public List<Map<String, Object>> getResourceTimings() {
        JavascriptExecutor js = (JavascriptExecutor) driver;

        String script = "var resources = performance.getEntriesByType('resource');" +
                       "return resources.map(function(r) {" +
                       "  return {" +
                       "    'name': r.name," +
                       "    'duration': r.duration," +
                       "    'size': r.transferSize," +
                       "    'type': r.initiatorType" +
                       "  };" +
                       "});";

        return (List<Map<String, Object>>) js.executeScript(script);
    }
}

// 4. Page Object with Console Log Validation
public class ConsoleLogPage {
    private ChromeDriver driver;
    private ConsoleLogHandler logHandler;
    private NetworkLogMonitor networkMonitor;

    public ConsoleLogPage(ChromeDriver driver) {
        this.driver = driver;
        this.logHandler = new ConsoleLogHandler(driver);
        this.networkMonitor = new NetworkLogMonitor(driver);
    }

    // Navigate with console monitoring
    public void navigateWithMonitoring(String url) {
        logHandler.enableConsoleLogging();
        networkMonitor.enableNetworkMonitoring();
        driver.get(url);
    }

    // Perform action and capture logs
    public void performActionAndCaptureLogs(Runnable action) {
        logHandler.clearLogs();
        networkMonitor.clearLogs();

        action.run();

        // Wait for any async operations
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    // Verify no errors after action
    public void verifyNoErrorsAfterAction(Runnable action) {
        performActionAndCaptureLogs(action);

        if (logHandler.hasJavaScriptErrors()) {
            throw new AssertionError("JavaScript errors detected: " + logHandler.getJavaScriptErrors());
        }

        if (networkMonitor.hasFailedRequests()) {
            throw new AssertionError("Network errors detected: " + networkMonitor.getFailedRequests());
        }
    }

    // Get log summary
    public String getLogSummary() {
        StringBuilder summary = new StringBuilder();
        summary.append("=== Log Summary ===\n");
        summary.append("JavaScript Errors: ").append(logHandler.getErrorCount()).append("\n");
        summary.append("Failed Network Requests: ").append(networkMonitor.getFailedRequests().size()).append("\n");
        summary.append("Total Requests: ").append(networkMonitor.getAllRequests().size()).append("\n");

        return summary.toString();
    }

    // Close handlers
    public void close() {
        logHandler.close();
    }
}

// 5. Test Examples
public class ConsoleLogTests {
    private ChromeDriver driver;
    private ConsoleLogHandler logHandler;
    private NetworkLogMonitor networkMonitor;
    private PerformanceLogAnalyzer performanceAnalyzer;

    @BeforeMethod
    public void setUp() {
        ChromeOptions options = new ChromeOptions();
        options.setCapability("goog:loggingPrefs",
            Collections.singletonMap("browser", "ALL"));

        driver = new ChromeDriver(options);
        logHandler = new ConsoleLogHandler(driver);
        networkMonitor = new NetworkLogMonitor(driver);
        performanceAnalyzer = new PerformanceLogAnalyzer(driver);
    }

    @Test
    public void testCaptureConsoleErrors() {
        logHandler.enableConsoleLogging();

        driver.get("https://example.com");

        // Trigger JavaScript error intentionally
        JavascriptExecutor js = (JavascriptExecutor) driver;
        try {
            js.executeScript("throw new Error('Test error');");
        } catch (Exception e) {
            // Expected
        }

        // Verify error was captured
        List<String> errors = logHandler.getJavaScriptErrors();
        Assert.assertTrue(errors.size() > 0, "Should capture JavaScript errors");
    }

    @Test
    public void testVerifyNoConsoleErrors() {
        logHandler.enableConsoleLogging();

        driver.get("https://example.com");

        // Perform actions
        driver.findElement(By.id("submit")).click();

        // Verify no console errors
        logHandler.assertNoConsoleErrors();
    }

    @Test
    public void testMonitorNetworkRequests() {
        networkMonitor.enableNetworkMonitoring();

        driver.get("https://example.com/api-test");

        // Get all API requests
        List<NetworkLogMonitor.RequestInfo> apiRequests =
            networkMonitor.getRequestsByUrl("/api/");

        Assert.assertTrue(apiRequests.size() > 0, "Should capture API requests");

        // Verify no failed requests
        Assert.assertEquals(networkMonitor.getFailedRequests().size(), 0,
            "Should have no failed requests");
    }

    @Test
    public void testCaptureFailedNetworkRequests() {
        networkMonitor.enableNetworkMonitoring();

        driver.get("https://example.com");

        // Trigger failed request
        JavascriptExecutor js = (JavascriptExecutor) driver;
        js.executeScript("fetch('/nonexistent-endpoint');");

        // Wait for request to fail
        new WebDriverWait(driver, Duration.ofSeconds(5))
            .until(d -> networkMonitor.hasFailedRequests());

        List<String> failedRequests = networkMonitor.getFailedRequests();
        Assert.assertTrue(failedRequests.size() > 0, "Should capture failed requests");
    }

    @Test
    public void testAnalyzePagePerformance() {
        driver.get("https://example.com");

        // Analyze performance
        Map<String, Long> metrics = performanceAnalyzer.analyzePageLoadTimes();

        Assert.assertTrue(metrics.get("loadComplete") > 0, "Should have load time");
        Assert.assertTrue(metrics.get("domContentLoaded") < 5000,
            "DOM should load within 5 seconds");

        // Get resource timings
        List<Map<String, Object>> resources = performanceAnalyzer.getResourceTimings();
        Assert.assertTrue(resources.size() > 0, "Should have resource timings");

        // Find slow resources
        for (Map<String, Object> resource : resources) {
            Double duration = (Double) resource.get("duration");
            if (duration > 3000) {
                System.out.println("Slow resource: " + resource.get("name") +
                    " (" + duration + "ms)");
            }
        }
    }

    @Test
    public void testBrowserLogsTraditionalMethod() {
        driver.get("https://example.com");

        // Trigger console messages
        JavascriptExecutor js = (JavascriptExecutor) driver;
        js.executeScript("console.log('Test log message');");
        js.executeScript("console.warn('Test warning');");
        js.executeScript("console.error('Test error');");

        // Get browser logs
        List<LogEntry> browserLogs = logHandler.getBrowserLogs();

        Assert.assertTrue(browserLogs.size() > 0, "Should capture browser logs");

        // Filter errors
        List<LogEntry> errors = browserLogs.stream()
            .filter(log -> log.getLevel() == Level.SEVERE)
            .collect(Collectors.toList());

        Assert.assertTrue(errors.size() > 0, "Should have error logs");
    }

    @AfterMethod
    public void tearDown() {
        if (logHandler != null) {
            System.out.println("\n" + logHandler.getFormattedLogs());
            logHandler.close();
        }

        if (driver != null) {
            driver.quit();
        }
    }
}

// 6. Utility Methods
public class ConsoleLogUtils {
    // Wait for no new console errors
    public static void waitForNoNewErrors(ConsoleLogHandler handler, int timeoutSeconds) {
        int initialErrorCount = handler.getErrorCount();
        long endTime = System.currentTimeMillis() + (timeoutSeconds * 1000);

        while (System.currentTimeMillis() < endTime) {
            if (handler.getErrorCount() == initialErrorCount) {
                return;
            }
            initialErrorCount = handler.getErrorCount();
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        throw new RuntimeException("Console errors continued to occur");
    }

    // Save logs to file
    public static void saveLogsToFile(ConsoleLogHandler handler, String filePath) {
        try (FileWriter writer = new FileWriter(filePath)) {
            writer.write(handler.getFormattedLogs());
            System.out.println("Logs saved to: " + filePath);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // Filter logs by keyword
    public static List<String> filterLogsByKeyword(List<LogEntry> logs, String keyword) {
        return logs.stream()
            .map(LogEntry::getMessage)
            .filter(msg -> msg.contains(keyword))
            .collect(Collectors.toList());
    }
}
```

**Follow-up**: How do you handle console logs in Firefox vs Chrome? How to capture logs from service workers? What's the difference between browser logs and performance logs? How to integrate console monitoring into CI/CD?

---

### **Q90: How do you monitor and intercept network traffic in Selenium tests?** (6-8 Years, 9-12 Years)
**Companies**: Google, Microsoft, Amazon, Netflix, Uber, Adobe
**Difficulty**: Hard

**Answer**: Network traffic monitoring and interception in Selenium is achieved through Chrome DevTools Protocol (CDP) in Selenium 4, enabling comprehensive control over network requests and responses. This capability is crucial for API testing at the UI level, mocking backend responses, testing offline scenarios, and validating request/response payloads. CDP Network domain provides methods to intercept, modify, block, or mock network requests before they reach the server. This is particularly valuable for testing error scenarios, simulating slow networks, testing with different response data, and validating that UI makes correct API calls. For cross-browser support, tools like BrowserMob Proxy can capture HTTP traffic, though CDP offers more fine-grained control. Network monitoring helps identify performance bottlenecks, failed requests, and validates end-to-end data flow in tests.

**Code Example**:

```java
// 1. Network Interceptor using Chrome DevTools Protocol
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.devtools.DevTools;
import org.openqa.selenium.devtools.v120.fetch.Fetch;
import org.openqa.selenium.devtools.v120.fetch.model.*;
import org.openqa.selenium.devtools.v120.network.Network;
import org.openqa.selenium.devtools.v120.network.model.*;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Predicate;

public class NetworkInterceptor {
    private ChromeDriver driver;
    private DevTools devTools;
    private Map<String, RequestPattern> interceptPatterns;
    private Map<String, MockResponse> mockResponses;
    private Map<String, RequestDetails> capturedRequests;
    private boolean isIntercepting = false;

    public NetworkInterceptor(ChromeDriver driver) {
        this.driver = driver;
        this.devTools = driver.getDevTools();
        this.devTools.createSession();
        this.interceptPatterns = new ConcurrentHashMap<>();
        this.mockResponses = new ConcurrentHashMap<>();
        this.capturedRequests = new ConcurrentHashMap<>();
    }

    // Enable network interception
    public void enableInterception() {
        // Enable Fetch domain for request interception
        devTools.send(Fetch.enable(
            Optional.of(Arrays.asList(
                new RequestPattern(
                    Optional.of("*"),
                    Optional.empty(),
                    Optional.empty()
                )
            )),
            Optional.of(false)
        ));

        // Handle intercepted requests
        devTools.addListener(Fetch.requestPaused(), request -> {
            RequestId requestId = request.getRequestId();
            String url = request.getRequest().getUrl();
            String method = request.getRequest().getMethod();

            // Capture request details
            RequestDetails details = new RequestDetails(
                requestId.toString(),
                url,
                method,
                request.getRequest().getHeaders(),
                request.getRequest().getPostData().orElse(null)
            );
            capturedRequests.put(url, details);

            System.out.println("Intercepted: " + method + " " + url);

            // Check if we should mock this request
            MockResponse mockResponse = findMockResponse(url);
            if (mockResponse != null) {
                fulfillRequestWithMock(requestId, mockResponse);
            } else {
                // Continue with original request
                devTools.send(Fetch.continueRequest(
                    requestId,
                    Optional.empty(),
                    Optional.empty(),
                    Optional.empty(),
                    Optional.empty(),
                    Optional.empty()
                ));
            }
        });

        isIntercepting = true;
        System.out.println("Network interception enabled");
    }

    // Add mock response for URL pattern
    public void mockResponse(String urlPattern, MockResponse response) {
        mockResponses.put(urlPattern, response);
        System.out.println("Mock added for pattern: " + urlPattern);
    }

    // Mock API response with JSON
    public void mockJsonResponse(String urlPattern, String jsonBody, int statusCode) {
        Map<String, Object> headers = new HashMap<>();
        headers.put("Content-Type", "application/json");

        MockResponse mock = new MockResponse(
            statusCode,
            "OK",
            headers,
            jsonBody
        );

        mockResponse(urlPattern, mock);
    }

    // Block requests matching pattern
    public void blockRequest(String urlPattern) {
        MockResponse blockResponse = new MockResponse(
            403,
            "Blocked by test",
            new HashMap<>(),
            ""
        );

        mockResponse(urlPattern, blockResponse);
    }

    // Modify request headers
    public void modifyRequestHeaders(String urlPattern, Map<String, String> newHeaders) {
        interceptPatterns.put(urlPattern, new RequestPattern(
            Optional.of(urlPattern),
            Optional.empty(),
            Optional.empty()
        ));

        devTools.addListener(Fetch.requestPaused(), request -> {
            if (request.getRequest().getUrl().contains(urlPattern)) {
                // Continue with modified headers
                List<HeaderEntry> headers = new ArrayList<>();
                newHeaders.forEach((key, value) ->
                    headers.add(new HeaderEntry(key, value))
                );

                devTools.send(Fetch.continueRequest(
                    request.getRequestId(),
                    Optional.empty(),
                    Optional.of(headers),
                    Optional.empty(),
                    Optional.empty(),
                    Optional.empty()
                ));
            }
        });
    }

    // Simulate network delay
    public void simulateNetworkDelay(int milliseconds) {
        devTools.send(Network.enable(Optional.empty(), Optional.empty(), Optional.empty()));
        devTools.send(Network.emulateNetworkConditions(
            false,  // offline
            100,    // latency in ms
            -1,     // download throughput
            -1,     // upload throughput
            Optional.empty()
        ));
    }

    // Simulate offline mode
    public void simulateOffline() {
        devTools.send(Network.enable(Optional.empty(), Optional.empty(), Optional.empty()));
        devTools.send(Network.emulateNetworkConditions(
            true,   // offline
            0,
            0,
            0,
            Optional.empty()
        ));
    }

    // Simulate slow 3G
    public void simulateSlow3G() {
        devTools.send(Network.enable(Optional.empty(), Optional.empty(), Optional.empty()));
        devTools.send(Network.emulateNetworkConditions(
            false,
            2000,      // 2 second latency
            50 * 1024,  // 50 KB/s download
            50 * 1024,  // 50 KB/s upload
            Optional.empty()
        ));
    }

    // Get captured request details
    public RequestDetails getRequestDetails(String url) {
        return capturedRequests.entrySet().stream()
            .filter(entry -> entry.getKey().contains(url))
            .map(Map.Entry::getValue)
            .findFirst()
            .orElse(null);
    }

    // Verify request was made
    public boolean wasRequestMade(String urlPattern) {
        return capturedRequests.keySet().stream()
            .anyMatch(url -> url.contains(urlPattern));
    }

    // Get all requests matching pattern
    public List<RequestDetails> getRequestsByPattern(String pattern) {
        return capturedRequests.values().stream()
            .filter(req -> req.getUrl().contains(pattern))
            .collect(Collectors.toList());
    }

    // Clear captured requests
    public void clearCapturedRequests() {
        capturedRequests.clear();
    }

    // Disable interception
    public void disableInterception() {
        if (isIntercepting) {
            devTools.send(Fetch.disable());
            isIntercepting = false;
            System.out.println("Network interception disabled");
        }
    }

    // Helper method to find mock response
    private MockResponse findMockResponse(String url) {
        return mockResponses.entrySet().stream()
            .filter(entry -> url.contains(entry.getKey()))
            .map(Map.Entry::getValue)
            .findFirst()
            .orElse(null);
    }

    // Fulfill request with mock response
    private void fulfillRequestWithMock(RequestId requestId, MockResponse mock) {
        List<HeaderEntry> headers = new ArrayList<>();
        mock.getHeaders().forEach((key, value) ->
            headers.add(new HeaderEntry(key, String.valueOf(value)))
        );

        devTools.send(Fetch.fulfillRequest(
            requestId,
            mock.getStatusCode(),
            Optional.of(headers),
            Optional.empty(),
            Optional.of(Base64.getEncoder().encodeToString(mock.getBody().getBytes())),
            Optional.empty()
        ));

        System.out.println("Fulfilled with mock: " + mock.getStatusCode() + " " + mock.getStatusText());
    }

    // Helper classes
    public static class RequestDetails {
        private String requestId;
        private String url;
        private String method;
        private Map<String, Object> headers;
        private String body;

        public RequestDetails(String requestId, String url, String method,
                            Map<String, Object> headers, String body) {
            this.requestId = requestId;
            this.url = url;
            this.method = method;
            this.headers = headers;
            this.body = body;
        }

        // Getters
        public String getRequestId() { return requestId; }
        public String getUrl() { return url; }
        public String getMethod() { return method; }
        public Map<String, Object> getHeaders() { return headers; }
        public String getBody() { return body; }

        @Override
        public String toString() {
            return String.format("%s %s\nHeaders: %s\nBody: %s",
                method, url, headers, body);
        }
    }

    public static class MockResponse {
        private int statusCode;
        private String statusText;
        private Map<String, Object> headers;
        private String body;

        public MockResponse(int statusCode, String statusText,
                          Map<String, Object> headers, String body) {
            this.statusCode = statusCode;
            this.statusText = statusText;
            this.headers = headers;
            this.body = body;
        }

        // Getters
        public int getStatusCode() { return statusCode; }
        public String getStatusText() { return statusText; }
        public Map<String, Object> getHeaders() { return headers; }
        public String getBody() { return body; }
    }
}

// 2. API Call Validator
public class APICallValidator {
    private NetworkInterceptor interceptor;
    private List<APIAssertion> assertions;

    public APICallValidator(NetworkInterceptor interceptor) {
        this.interceptor = interceptor;
        this.assertions = new ArrayList<>();
    }

    // Add assertion for API call
    public void expectAPICall(String endpoint, String method) {
        assertions.add(new APIAssertion(endpoint, method, true));
    }

    // Assert API call was NOT made
    public void expectNoAPICall(String endpoint) {
        assertions.add(new APIAssertion(endpoint, null, false));
    }

    // Verify all assertions
    public void verifyAllAssertions() {
        for (APIAssertion assertion : assertions) {
            if (assertion.shouldBeCalled) {
                Assert.assertTrue(
                    interceptor.wasRequestMade(assertion.endpoint),
                    "Expected API call not made: " + assertion.endpoint
                );

                if (assertion.method != null) {
                    RequestDetails request = interceptor.getRequestDetails(assertion.endpoint);
                    Assert.assertEquals(
                        request.getMethod(),
                        assertion.method,
                        "Wrong HTTP method for: " + assertion.endpoint
                    );
                }
            } else {
                Assert.assertFalse(
                    interceptor.wasRequestMade(assertion.endpoint),
                    "Unexpected API call made: " + assertion.endpoint
                );
            }
        }
    }

    // Verify request payload
    public void verifyRequestPayload(String endpoint, String expectedPayload) {
        RequestDetails request = interceptor.getRequestDetails(endpoint);
        Assert.assertNotNull(request, "Request not found: " + endpoint);
        Assert.assertEquals(request.getBody(), expectedPayload,
            "Request payload mismatch");
    }

    // Verify request header
    public void verifyRequestHeader(String endpoint, String headerName, String expectedValue) {
        RequestDetails request = interceptor.getRequestDetails(endpoint);
        Assert.assertNotNull(request, "Request not found: " + endpoint);

        Object actualValue = request.getHeaders().get(headerName);
        Assert.assertEquals(actualValue, expectedValue,
            "Header mismatch for " + headerName);
    }

    private static class APIAssertion {
        String endpoint;
        String method;
        boolean shouldBeCalled;

        APIAssertion(String endpoint, String method, boolean shouldBeCalled) {
            this.endpoint = endpoint;
            this.method = method;
            this.shouldBeCalled = shouldBeCalled;
        }
    }
}

// 3. Network Traffic Recorder
public class NetworkTrafficRecorder {
    private ChromeDriver driver;
    private DevTools devTools;
    private List<NetworkTransaction> transactions;
    private boolean isRecording = false;

    public NetworkTrafficRecorder(ChromeDriver driver) {
        this.driver = driver;
        this.devTools = driver.getDevTools();
        this.devTools.createSession();
        this.transactions = new CopyOnWriteArrayList<>();
    }

    // Start recording
    public void startRecording() {
        devTools.send(Network.enable(Optional.empty(), Optional.empty(), Optional.empty()));

        Map<RequestId, NetworkTransaction> pendingTransactions = new ConcurrentHashMap<>();

        // Capture request
        devTools.addListener(Network.requestWillBeSent(), event -> {
            NetworkTransaction transaction = new NetworkTransaction();
            transaction.setRequestId(event.getRequestId().toString());
            transaction.setUrl(event.getRequest().getUrl());
            transaction.setMethod(event.getRequest().getMethod());
            transaction.setRequestHeaders(event.getRequest().getHeaders());
            transaction.setRequestTime(System.currentTimeMillis());

            pendingTransactions.put(event.getRequestId(), transaction);
        });

        // Capture response
        devTools.addListener(Network.responseReceived(), event -> {
            RequestId requestId = event.getRequestId();
            NetworkTransaction transaction = pendingTransactions.get(requestId);

            if (transaction != null) {
                transaction.setStatusCode(event.getResponse().getStatus());
                transaction.setResponseHeaders(event.getResponse().getHeaders());
                transaction.setResponseTime(System.currentTimeMillis());
                transaction.calculateDuration();

                transactions.add(transaction);
                pendingTransactions.remove(requestId);
            }
        });

        // Capture response body
        devTools.addListener(Network.loadingFinished(), event -> {
            RequestId requestId = event.getRequestId();

            try {
                Network.GetResponseBodyResponse responseBody =
                    devTools.send(Network.getResponseBody(requestId));

                transactions.stream()
                    .filter(t -> t.getRequestId().equals(requestId.toString()))
                    .findFirst()
                    .ifPresent(t -> t.setResponseBody(responseBody.getBody()));
            } catch (Exception e) {
                // Response body not available
            }
        });

        isRecording = true;
        System.out.println("Network recording started");
    }

    // Stop recording
    public void stopRecording() {
        if (isRecording) {
            devTools.send(Network.disable());
            isRecording = false;
            System.out.println("Network recording stopped");
        }
    }

    // Get all transactions
    public List<NetworkTransaction> getAllTransactions() {
        return new ArrayList<>(transactions);
    }

    // Get transactions by URL pattern
    public List<NetworkTransaction> getTransactionsByUrl(String urlPattern) {
        return transactions.stream()
            .filter(t -> t.getUrl().contains(urlPattern))
            .collect(Collectors.toList());
    }

    // Get slow requests (duration > threshold)
    public List<NetworkTransaction> getSlowRequests(long thresholdMs) {
        return transactions.stream()
            .filter(t -> t.getDuration() > thresholdMs)
            .collect(Collectors.toList());
    }

    // Get failed requests
    public List<NetworkTransaction> getFailedRequests() {
        return transactions.stream()
            .filter(t -> t.getStatusCode() >= 400)
            .collect(Collectors.toList());
    }

    // Export to HAR format (simplified)
    public String exportToHAR() {
        // Simplified HAR export
        StringBuilder har = new StringBuilder();
        har.append("{\n  \"log\": {\n    \"entries\": [\n");

        for (int i = 0; i < transactions.size(); i++) {
            NetworkTransaction t = transactions.get(i);
            har.append("      {\n");
            har.append("        \"request\": {\n");
            har.append("          \"method\": \"").append(t.getMethod()).append("\",\n");
            har.append("          \"url\": \"").append(t.getUrl()).append("\"\n");
            har.append("        },\n");
            har.append("        \"response\": {\n");
            har.append("          \"status\": ").append(t.getStatusCode()).append(",\n");
            har.append("          \"time\": ").append(t.getDuration()).append("\n");
            har.append("        }\n");
            har.append("      }");

            if (i < transactions.size() - 1) {
                har.append(",");
            }
            har.append("\n");
        }

        har.append("    ]\n  }\n}");
        return har.toString();
    }

    // Clear recorded transactions
    public void clearTransactions() {
        transactions.clear();
    }

    // Network Transaction class
    public static class NetworkTransaction {
        private String requestId;
        private String url;
        private String method;
        private Map<String, Object> requestHeaders;
        private Map<String, Object> responseHeaders;
        private int statusCode;
        private String responseBody;
        private long requestTime;
        private long responseTime;
        private long duration;

        // Getters and setters
        public String getRequestId() { return requestId; }
        public void setRequestId(String requestId) { this.requestId = requestId; }

        public String getUrl() { return url; }
        public void setUrl(String url) { this.url = url; }

        public String getMethod() { return method; }
        public void setMethod(String method) { this.method = method; }

        public Map<String, Object> getRequestHeaders() { return requestHeaders; }
        public void setRequestHeaders(Map<String, Object> headers) { this.requestHeaders = headers; }

        public Map<String, Object> getResponseHeaders() { return responseHeaders; }
        public void setResponseHeaders(Map<String, Object> headers) { this.responseHeaders = headers; }

        public int getStatusCode() { return statusCode; }
        public void setStatusCode(int statusCode) { this.statusCode = statusCode; }

        public String getResponseBody() { return responseBody; }
        public void setResponseBody(String body) { this.responseBody = body; }

        public long getRequestTime() { return requestTime; }
        public void setRequestTime(long time) { this.requestTime = time; }

        public long getResponseTime() { return responseTime; }
        public void setResponseTime(long time) { this.responseTime = time; }

        public long getDuration() { return duration; }
        public void calculateDuration() { this.duration = responseTime - requestTime; }

        @Override
        public String toString() {
            return String.format("%s %s - Status: %d, Duration: %dms",
                method, url, statusCode, duration);
        }
    }
}

// 4. Test Examples
public class NetworkInterceptionTests {
    private ChromeDriver driver;
    private NetworkInterceptor interceptor;
    private APICallValidator validator;
    private NetworkTrafficRecorder recorder;

    @BeforeMethod
    public void setUp() {
        driver = new ChromeDriver();
        interceptor = new NetworkInterceptor(driver);
        validator = new APICallValidator(interceptor);
        recorder = new NetworkTrafficRecorder(driver);
    }

    @Test
    public void testMockAPIResponse() {
        interceptor.enableInterception();

        // Mock user API response
        String mockJson = "{\"id\": 1, \"name\": \"Test User\", \"email\": \"test@example.com\"}";
        interceptor.mockJsonResponse("/api/user", mockJson, 200);

        driver.get("https://example.com/profile");

        // Verify mocked data is displayed
        WebElement userName = driver.findElement(By.id("user-name"));
        Assert.assertEquals(userName.getText(), "Test User");
    }

    @Test
    public void testBlockAPIRequest() {
        interceptor.enableInterception();

        // Block analytics requests
        interceptor.blockRequest("/analytics");

        driver.get("https://example.com");

        // Verify analytics request was blocked
        Assert.assertTrue(interceptor.wasRequestMade("/analytics"));

        RequestDetails request = interceptor.getRequestDetails("/analytics");
        // Request would show 403 status in logs
    }

    @Test
    public void testVerifyAPICallsMade() {
        interceptor.enableInterception();

        // Setup expectations
        validator.expectAPICall("/api/products", "GET");
        validator.expectAPICall("/api/cart", "POST");
        validator.expectNoAPICall("/api/admin");

        // Perform actions
        driver.get("https://example.com/shop");
        driver.findElement(By.cssSelector(".add-to-cart")).click();

        // Verify all assertions
        validator.verifyAllAssertions();
    }

    @Test
    public void testSimulateNetworkConditions() {
        interceptor.enableInterception();

        // Simulate slow 3G
        interceptor.simulateSlow3G();

        long startTime = System.currentTimeMillis();
        driver.get("https://example.com");
        long loadTime = System.currentTimeMillis() - startTime;

        // Verify page took longer to load
        Assert.assertTrue(loadTime > 2000, "Page should load slowly on 3G");
    }

    @Test
    public void testSimulateOfflineMode() {
        interceptor.enableInterception();

        driver.get("https://example.com");

        // Go offline
        interceptor.simulateOffline();

        // Try to navigate - should fail or show offline page
        driver.navigate().to("https://example.com/another-page");

        // Verify offline handling
        Assert.assertTrue(
            driver.getPageSource().contains("offline") ||
            driver.getPageSource().contains("No internet"),
            "Should show offline message"
        );
    }

    @Test
    public void testRecordNetworkTraffic() {
        recorder.startRecording();

        driver.get("https://example.com");

        recorder.stopRecording();

        // Analyze recorded traffic
        List<NetworkTrafficRecorder.NetworkTransaction> transactions =
            recorder.getAllTransactions();

        Assert.assertTrue(transactions.size() > 0, "Should record network traffic");

        // Find slow requests
        List<NetworkTrafficRecorder.NetworkTransaction> slowRequests =
            recorder.getSlowRequests(1000);

        for (NetworkTrafficRecorder.NetworkTransaction transaction : slowRequests) {
            System.out.println("Slow request: " + transaction);
        }

        // Export to HAR
        String har = recorder.exportToHAR();
        Assert.assertNotNull(har);
    }

    @Test
    public void testModifyRequestHeaders() {
        interceptor.enableInterception();

        // Add custom header to all API requests
        Map<String, String> customHeaders = new HashMap<>();
        customHeaders.put("X-Test-Header", "test-value");
        customHeaders.put("Authorization", "Bearer test-token");

        interceptor.modifyRequestHeaders("/api/", customHeaders);

        driver.get("https://example.com");

        // Verify custom header was sent
        RequestDetails request = interceptor.getRequestDetails("/api/");
        Assert.assertNotNull(request);
        // Header would be in request details
    }

    @Test
    public void testVerifyRequestPayload() {
        interceptor.enableInterception();

        driver.get("https://example.com/form");

        // Fill and submit form
        driver.findElement(By.id("name")).sendKeys("Test User");
        driver.findElement(By.id("email")).sendKeys("test@example.com");
        driver.findElement(By.id("submit")).click();

        // Verify correct payload was sent
        String expectedPayload = "{\"name\":\"Test User\",\"email\":\"test@example.com\"}";
        validator.verifyRequestPayload("/api/submit", expectedPayload);
    }

    @AfterMethod
    public void tearDown() {
        if (interceptor != null) {
            interceptor.disableInterception();
        }

        if (driver != null) {
            driver.quit();
        }
    }
}
```

**Follow-up**: How to use BrowserMob Proxy for network capture? How to intercept WebSocket traffic? What are the limitations of CDP network interception? How to validate GraphQL requests in Selenium?

---

### **Q91: How do you handle PDF testing and validation in Selenium?** (6-8 Years, 9-12 Years)
**Companies**: Amazon, Microsoft, Adobe, Oracle, Salesforce, Flipkart
**Difficulty**: Hard

**Answer**: PDF testing in Selenium involves multiple approaches depending on requirements: viewing PDFs in browser, downloading and validating content, extracting text, verifying structure, and comparing PDFs. Modern browsers can render PDFs natively, allowing basic validation through Selenium. For comprehensive PDF testing, Apache PDFBox library enables text extraction, metadata validation, page count verification, and content comparison. PDF testing scenarios include: verifying invoice generation, validating report content, checking digital signatures, testing PDF forms, and ensuring accessibility compliance. For cross-browser PDF handling, different strategies are needed as Firefox, Chrome, and Edge have varying native PDF support. PDF validation should cover: content accuracy, formatting integrity, embedded images, hyperlinks, bookmarks, and file size optimization. Integration with reporting frameworks helps capture PDF validation results with screenshots.

**Code Example**:

```java
// 1. PDF Handler using Apache PDFBox
import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.text.PDFTextStripper;
import org.apache.pdfbox.pdmodel.PDDocumentInformation;
import org.apache.pdfbox.pdmodel.encryption.AccessPermission;

import java.io.*;
import java.net.URL;
import java.util.*;

public class PDFHandler {
    private String pdfFilePath;
    private PDDocument document;

    public PDFHandler(String pdfFilePath) throws IOException {
        this.pdfFilePath = pdfFilePath;
        this.document = PDDocument.load(new File(pdfFilePath));
    }

    // Load PDF from URL
    public static PDFHandler loadFromURL(String url) throws IOException {
        URL pdfUrl = new URL(url);
        PDDocument document = PDDocument.load(pdfUrl.openStream());

        // Save temporarily
        String tempPath = System.getProperty("java.io.tmpdir") + "/temp.pdf";
        document.save(tempPath);
        document.close();

        return new PDFHandler(tempPath);
    }

    // Extract all text from PDF
    public String extractAllText() throws IOException {
        PDFTextStripper stripper = new PDFTextStripper();
        return stripper.getText(document);
    }

    // Extract text from specific page
    public String extractTextFromPage(int pageNumber) throws IOException {
        PDFTextStripper stripper = new PDFTextStripper();
        stripper.setStartPage(pageNumber);
        stripper.setEndPage(pageNumber);
        return stripper.getText(document);
    }

    // Extract text from page range
    public String extractTextFromPages(int startPage, int endPage) throws IOException {
        PDFTextStripper stripper = new PDFTextStripper();
        stripper.setStartPage(startPage);
        stripper.setEndPage(endPage);
        return stripper.getText(document);
    }

    // Get total page count
    public int getPageCount() {
        return document.getNumberOfPages();
    }

    // Get PDF metadata
    public Map<String, String> getMetadata() {
        Map<String, String> metadata = new HashMap<>();
        PDDocumentInformation info = document.getDocumentInformation();

        metadata.put("Title", info.getTitle());
        metadata.put("Author", info.getAuthor());
        metadata.put("Subject", info.getSubject());
        metadata.put("Keywords", info.getKeywords());
        metadata.put("Creator", info.getCreator());
        metadata.put("Producer", info.getProducer());
        metadata.put("CreationDate", info.getCreationDate() != null ?
            info.getCreationDate().toString() : "");
        metadata.put("ModificationDate", info.getModificationDate() != null ?
            info.getModificationDate().toString() : "");

        return metadata;
    }

    // Check if PDF is encrypted
    public boolean isEncrypted() {
        return document.isEncrypted();
    }

    // Get access permissions
    public Map<String, Boolean> getAccessPermissions() throws IOException {
        Map<String, Boolean> permissions = new HashMap<>();

        if (document.isEncrypted()) {
            AccessPermission ap = document.getCurrentAccessPermission();
            permissions.put("canPrint", ap.canPrint());
            permissions.put("canModify", ap.canModify());
            permissions.put("canExtractContent", ap.canExtractContent());
            permissions.put("canAssembleDocument", ap.canAssembleDocument());
            permissions.put("canFillInForm", ap.canFillInForm());
        }

        return permissions;
    }

    // Search for text in PDF
    public boolean containsText(String searchText) throws IOException {
        String fullText = extractAllText();
        return fullText.contains(searchText);
    }

    // Get all occurrences of text
    public List<Integer> findTextOccurrences(String searchText) throws IOException {
        List<Integer> pageNumbers = new ArrayList<>();

        for (int i = 1; i <= getPageCount(); i++) {
            String pageText = extractTextFromPage(i);
            if (pageText.contains(searchText)) {
                pageNumbers.add(i);
            }
        }

        return pageNumbers;
    }

    // Compare two PDFs
    public static boolean comparePDFs(String pdf1Path, String pdf2Path) throws IOException {
        PDFHandler pdf1 = new PDFHandler(pdf1Path);
        PDFHandler pdf2 = new PDFHandler(pdf2Path);

        // Compare page count
        if (pdf1.getPageCount() != pdf2.getPageCount()) {
            pdf1.close();
            pdf2.close();
            return false;
        }

        // Compare text content
        String text1 = pdf1.extractAllText();
        String text2 = pdf2.extractAllText();

        pdf1.close();
        pdf2.close();

        return text1.equals(text2);
    }

    // Get file size
    public long getFileSize() {
        File pdfFile = new File(pdfFilePath);
        return pdfFile.length();
    }

    // Verify PDF structure
    public boolean verifyStructure() {
        try {
            // Basic structural checks
            return document.getNumberOfPages() > 0 &&
                   document.getDocumentCatalog() != null;
        } catch (Exception e) {
            return false;
        }
    }

    // Close PDF document
    public void close() throws IOException {
        if (document != null) {
            document.close();
        }
    }
}

// 2. PDF Download Handler
public class PDFDownloadHandler {
    private WebDriver driver;
    private String downloadPath;

    public PDFDownloadHandler(WebDriver driver, String downloadPath) {
        this.driver = driver;
        this.downloadPath = downloadPath;
    }

    // Configure Chrome for PDF download
    public static ChromeDriver createChromeForPDFDownload(String downloadPath) {
        ChromeOptions options = new ChromeOptions();

        Map<String, Object> prefs = new HashMap<>();
        prefs.put("download.default_directory", downloadPath);
        prefs.put("download.prompt_for_download", false);
        prefs.put("plugins.always_open_pdf_externally", true);  // Download instead of view
        prefs.put("plugins.plugins_disabled", Arrays.asList("Chrome PDF Viewer"));

        options.setExperimentalOption("prefs", prefs);

        return new ChromeDriver(options);
    }

    // Configure Firefox for PDF download
    public static FirefoxDriver createFirefoxForPDFDownload(String downloadPath) {
        FirefoxOptions options = new FirefoxOptions();
        FirefoxProfile profile = new FirefoxProfile();

        profile.setPreference("browser.download.folderList", 2);
        profile.setPreference("browser.download.dir", downloadPath);
        profile.setPreference("browser.helperApps.neverAsk.saveToDisk", "application/pdf");
        profile.setPreference("pdfjs.disabled", true);  // Disable PDF viewer

        options.setProfile(profile);

        return new FirefoxDriver(options);
    }

    // Trigger PDF download
    public String downloadPDF(String downloadUrl) {
        driver.get(downloadUrl);

        // Wait for download to complete
        String fileName = waitForDownload(30);

        return downloadPath + "/" + fileName;
    }

    // Click element to download PDF
    public String downloadPDFByClick(WebElement element) {
        element.click();

        // Wait for download
        String fileName = waitForDownload(30);

        return downloadPath + "/" + fileName;
    }

    // Wait for PDF download to complete
    private String waitForDownload(int timeoutSeconds) {
        long endTime = System.currentTimeMillis() + (timeoutSeconds * 1000);

        while (System.currentTimeMillis() < endTime) {
            File folder = new File(downloadPath);
            File[] files = folder.listFiles((dir, name) ->
                name.endsWith(".pdf") && !name.endsWith(".crdownload"));

            if (files != null && files.length > 0) {
                // Return the most recently downloaded file
                Arrays.sort(files, Comparator.comparingLong(File::lastModified).reversed());
                return files[0].getName();
            }

            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        throw new RuntimeException("PDF download timed out");
    }

    // Delete downloaded file
    public void deleteDownloadedFile(String filePath) {
        File file = new File(filePath);
        if (file.exists()) {
            file.delete();
        }
    }

    // Clear download folder
    public void clearDownloadFolder() {
        File folder = new File(downloadPath);
        File[] files = folder.listFiles();

        if (files != null) {
            for (File file : files) {
                file.delete();
            }
        }
    }
}

// 3. PDF Browser Viewer Handler
public class PDFBrowserViewer {
    private WebDriver driver;
    private WebDriverWait wait;

    public PDFBrowserViewer(WebDriver driver) {
        this.driver = driver;
        this.wait = new WebDriverWait(driver, Duration.ofSeconds(10));
    }

    // Open PDF in browser
    public void openPDFInBrowser(String pdfUrl) {
        driver.get(pdfUrl);

        // Wait for PDF to load
        wait.until(d -> ((JavascriptExecutor) d).executeScript("return document.readyState")
            .equals("complete"));
    }

    // Check if PDF is displayed (Chrome native viewer)
    public boolean isPDFDisplayed() {
        try {
            // Chrome embeds PDF in an <embed> tag
            WebElement embed = driver.findElement(By.tagName("embed"));
            return embed.getAttribute("type").equals("application/pdf");
        } catch (NoSuchElementException e) {
            return false;
        }
    }

    // Get PDF viewer element
    public WebElement getPDFViewerElement() {
        return driver.findElement(By.tagName("embed"));
    }

    // Extract PDF URL from embed
    public String getPDFUrl() {
        WebElement embed = getPDFViewerElement();
        return embed.getAttribute("src");
    }

    // Take screenshot of PDF in browser
    public void takeScreenshot(String filePath) throws IOException {
        File screenshot = ((TakesScreenshot) driver).getScreenshotAs(OutputType.FILE);
        FileUtils.copyFile(screenshot, new File(filePath));
    }

    // Verify PDF loads without error
    public boolean verifyPDFLoadsSuccessfully(String pdfUrl) {
        try {
            openPDFInBrowser(pdfUrl);
            return isPDFDisplayed();
        } catch (Exception e) {
            return false;
        }
    }
}

// 4. PDF Assertion Helper
public class PDFAssertions {
    private PDFHandler pdfHandler;

    public PDFAssertions(String pdfFilePath) throws IOException {
        this.pdfHandler = new PDFHandler(pdfFilePath);
    }

    // Assert PDF contains text
    public void assertContainsText(String expectedText) throws IOException {
        Assert.assertTrue(
            pdfHandler.containsText(expectedText),
            "PDF does not contain expected text: " + expectedText
        );
    }

    // Assert page count
    public void assertPageCount(int expectedCount) {
        Assert.assertEquals(
            pdfHandler.getPageCount(),
            expectedCount,
            "PDF page count mismatch"
        );
    }

    // Assert PDF is not encrypted
    public void assertNotEncrypted() {
        Assert.assertFalse(
            pdfHandler.isEncrypted(),
            "PDF should not be encrypted"
        );
    }

    // Assert PDF has valid structure
    public void assertValidStructure() {
        Assert.assertTrue(
            pdfHandler.verifyStructure(),
            "PDF has invalid structure"
        );
    }

    // Assert metadata
    public void assertMetadata(String key, String expectedValue) {
        Map<String, String> metadata = pdfHandler.getMetadata();
        Assert.assertEquals(
            metadata.get(key),
            expectedValue,
            "PDF metadata mismatch for key: " + key
        );
    }

    // Assert file size
    public void assertFileSizeWithinRange(long minBytes, long maxBytes) {
        long actualSize = pdfHandler.getFileSize();
        Assert.assertTrue(
            actualSize >= minBytes && actualSize <= maxBytes,
            String.format("PDF file size %d bytes is outside expected range [%d, %d]",
                actualSize, minBytes, maxBytes)
        );
    }

    // Assert text on specific page
    public void assertTextOnPage(int pageNumber, String expectedText) throws IOException {
        String pageText = pdfHandler.extractTextFromPage(pageNumber);
        Assert.assertTrue(
            pageText.contains(expectedText),
            String.format("Page %d does not contain expected text: %s", pageNumber, expectedText)
        );
    }

    // Close
    public void close() throws IOException {
        pdfHandler.close();
    }
}

// 5. Page Object with PDF handling
public class InvoicePage {
    private WebDriver driver;
    private PDFDownloadHandler downloadHandler;
    private String downloadPath;

    @FindBy(id = "download-invoice")
    private WebElement downloadButton;

    @FindBy(id = "view-invoice")
    private WebElement viewButton;

    @FindBy(id = "invoice-number")
    private WebElement invoiceNumber;

    public InvoicePage(WebDriver driver, String downloadPath) {
        this.driver = driver;
        this.downloadPath = downloadPath;
        this.downloadHandler = new PDFDownloadHandler(driver, downloadPath);
        PageFactory.initElements(driver, this);
    }

    // Download invoice PDF
    public String downloadInvoice() {
        return downloadHandler.downloadPDFByClick(downloadButton);
    }

    // View invoice in browser
    public void viewInvoice() {
        viewButton.click();
    }

    // Get invoice number from UI
    public String getInvoiceNumber() {
        return invoiceNumber.getText();
    }

    // Download and validate invoice
    public void downloadAndValidateInvoice(String expectedInvoiceNumber, double expectedAmount)
            throws IOException {
        String pdfPath = downloadInvoice();

        PDFAssertions assertions = new PDFAssertions(pdfPath);

        // Validate content
        assertions.assertContainsText("INVOICE");
        assertions.assertContainsText(expectedInvoiceNumber);
        assertions.assertContainsText(String.format("$%.2f", expectedAmount));
        assertions.assertPageCount(1);

        assertions.close();

        // Cleanup
        downloadHandler.deleteDownloadedFile(pdfPath);
    }
}

// 6. Test Examples
public class PDFTests {
    private ChromeDriver driver;
    private PDFDownloadHandler downloadHandler;
    private PDFBrowserViewer pdfViewer;
    private String downloadPath;

    @BeforeMethod
    public void setUp() {
        downloadPath = System.getProperty("user.dir") + "/downloads";
        new File(downloadPath).mkdirs();

        driver = PDFDownloadHandler.createChromeForPDFDownload(downloadPath);
        downloadHandler = new PDFDownloadHandler(driver, downloadPath);
        pdfViewer = new PDFBrowserViewer(driver);
    }

    @Test
    public void testDownloadAndValidatePDF() throws IOException {
        driver.get("https://example.com/invoices");

        // Download PDF
        String pdfPath = downloadHandler.downloadPDF("https://example.com/invoice.pdf");

        // Validate PDF
        PDFAssertions assertions = new PDFAssertions(pdfPath);
        assertions.assertPageCount(2);
        assertions.assertContainsText("Invoice #12345");
        assertions.assertContainsText("Total: $150.00");
        assertions.assertValidStructure();
        assertions.close();
    }

    @Test
    public void testViewPDFInBrowser() {
        pdfViewer.openPDFInBrowser("https://example.com/document.pdf");

        // Verify PDF loads
        Assert.assertTrue(pdfViewer.isPDFDisplayed(), "PDF should be displayed");

        // Take screenshot
        try {
            pdfViewer.takeScreenshot(downloadPath + "/pdf-screenshot.png");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Test
    public void testExtractPDFContent() throws IOException {
        String pdfPath = downloadHandler.downloadPDF("https://example.com/report.pdf");

        PDFHandler handler = new PDFHandler(pdfPath);

        // Extract and verify content
        String fullText = handler.extractAllText();
        Assert.assertTrue(fullText.contains("Annual Report"), "Should contain report title");

        // Verify page count
        Assert.assertEquals(handler.getPageCount(), 10, "Report should have 10 pages");

        // Verify metadata
        Map<String, String> metadata = handler.getMetadata();
        Assert.assertEquals(metadata.get("Author"), "Company Name");

        handler.close();
    }

    @Test
    public void testComparePDFs() throws IOException {
        String pdf1 = downloadHandler.downloadPDF("https://example.com/doc1.pdf");
        String pdf2 = downloadHandler.downloadPDF("https://example.com/doc2.pdf");

        boolean areEqual = PDFHandler.comparePDFs(pdf1, pdf2);
        Assert.assertTrue(areEqual, "PDFs should be identical");
    }

    @Test
    public void testPDFPageObject() throws IOException {
        driver.get("https://example.com/orders/12345");

        InvoicePage invoicePage = new InvoicePage(driver, downloadPath);
        String invoiceNumber = invoicePage.getInvoiceNumber();

        // Download and validate
        invoicePage.downloadAndValidateInvoice(invoiceNumber, 150.00);
    }

    @AfterMethod
    public void tearDown() {
        if (downloadHandler != null) {
            downloadHandler.clearDownloadFolder();
        }

        if (driver != null) {
            driver.quit();
        }
    }
}
```

**Follow-up**: How to handle password-protected PDFs? How to validate PDF images and charts? What tools can compare visual differences in PDFs? How to test PDF forms and fillable fields?

---

### **Q92: How do you integrate database validation with Selenium tests?** (6-8 Years, 9-12 Years)
**Companies**: Amazon, Oracle, SAP, Microsoft, Flipkart, Paytm
**Difficulty**: Hard

**Answer**: Database integration in Selenium tests is essential for comprehensive end-to-end validation, enabling test data setup, verifying backend data persistence, validating business logic, and cleaning up test data. JDBC (Java Database Connectivity) provides the standard API for connecting to databases (MySQL, PostgreSQL, Oracle, SQL Server, MongoDB). Common use cases include: verifying data after form submission, setting up test data before test execution, validating data transformations, checking audit logs, and ensuring data consistency across UI and backend. Best practices include: using separate test databases, implementing connection pooling, creating reusable database utilities, handling transactions properly, and securing database credentials. For optimal test isolation, database state should be restored after each test. Integration with TestNG DataProvider enables data-driven testing from databases, while connection management utilities ensure proper resource cleanup.

**Code Example**:

```java
// 1. Database Connection Manager
import java.sql.*;
import java.util.*;
import javax.sql.DataSource;
import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;

public class DatabaseManager {
    private static DatabaseManager instance;
    private DataSource dataSource;
    private Properties dbProperties;

    private DatabaseManager() {
        loadDatabaseProperties();
        initializeConnectionPool();
    }

    // Singleton instance
    public static synchronized DatabaseManager getInstance() {
        if (instance == null) {
            instance = new DatabaseManager();
        }
        return instance;
    }

    // Load database properties from config file
    private void loadDatabaseProperties() {
        dbProperties = new Properties();
        try (InputStream input = getClass().getClassLoader()
                .getResourceAsStream("database.properties")) {
            dbProperties.load(input);
        } catch (IOException e) {
            throw new RuntimeException("Failed to load database properties", e);
        }
    }

    // Initialize HikariCP connection pool
    private void initializeConnectionPool() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(dbProperties.getProperty("db.url"));
        config.setUsername(dbProperties.getProperty("db.username"));
        config.setPassword(dbProperties.getProperty("db.password"));
        config.setDriverClassName(dbProperties.getProperty("db.driver"));

        // Pool configuration
        config.setMaximumPoolSize(10);
        config.setMinimumIdle(2);
        config.setConnectionTimeout(30000);
        config.setIdleTimeout(600000);
        config.setMaxLifetime(1800000);

        this.dataSource = new HikariDataSource(config);
    }

    // Get database connection from pool
    public Connection getConnection() throws SQLException {
        return dataSource.getConnection();
    }

    // Execute SELECT query and return ResultSet
    public ResultSet executeQuery(String query, Object... params) throws SQLException {
        Connection connection = getConnection();
        PreparedStatement statement = prepareStatement(connection, query, params);
        return statement.executeQuery();
    }

    // Execute INSERT/UPDATE/DELETE and return affected rows
    public int executeUpdate(String query, Object... params) throws SQLException {
        try (Connection connection = getConnection();
             PreparedStatement statement = prepareStatement(connection, query, params)) {
            return statement.executeUpdate();
        }
    }

    // Prepare statement with parameters
    private PreparedStatement prepareStatement(Connection connection, String query, Object... params)
            throws SQLException {
        PreparedStatement statement = connection.prepareStatement(query);

        for (int i = 0; i < params.length; i++) {
            statement.setObject(i + 1, params[i]);
        }

        return statement;
    }

    // Close connection pool
    public void closeConnectionPool() {
        if (dataSource instanceof HikariDataSource) {
            ((HikariDataSource) dataSource).close();
        }
    }
}

// 2. Database Query Handler
public class DatabaseQueryHandler {
    private DatabaseManager dbManager;

    public DatabaseQueryHandler() {
        this.dbManager = DatabaseManager.getInstance();
    }

    // Get single value from query
    public Object getSingleValue(String query, Object... params) throws SQLException {
        try (Connection connection = dbManager.getConnection();
             PreparedStatement statement = connection.prepareStatement(query)) {

            setParameters(statement, params);

            try (ResultSet rs = statement.executeQuery()) {
                if (rs.next()) {
                    return rs.getObject(1);
                }
            }
        }

        return null;
    }

    // Get single row as Map
    public Map<String, Object> getSingleRow(String query, Object... params) throws SQLException {
        try (Connection connection = dbManager.getConnection();
             PreparedStatement statement = connection.prepareStatement(query)) {

            setParameters(statement, params);

            try (ResultSet rs = statement.executeQuery()) {
                if (rs.next()) {
                    return resultSetToMap(rs);
                }
            }
        }

        return null;
    }

    // Get multiple rows as List of Maps
    public List<Map<String, Object>> getMultipleRows(String query, Object... params)
            throws SQLException {
        List<Map<String, Object>> rows = new ArrayList<>();

        try (Connection connection = dbManager.getConnection();
             PreparedStatement statement = connection.prepareStatement(query)) {

            setParameters(statement, params);

            try (ResultSet rs = statement.executeQuery()) {
                while (rs.next()) {
                    rows.add(resultSetToMap(rs));
                }
            }
        }

        return rows;
    }

    // Check if record exists
    public boolean recordExists(String table, String whereClause, Object... params)
            throws SQLException {
        String query = String.format("SELECT COUNT(*) FROM %s WHERE %s", table, whereClause);
        Object count = getSingleValue(query, params);
        return count != null && ((Number) count).intValue() > 0;
    }

    // Get record count
    public int getRecordCount(String table, String whereClause, Object... params)
            throws SQLException {
        String query = String.format("SELECT COUNT(*) FROM %s WHERE %s", table, whereClause);
        Object count = getSingleValue(query, params);
        return count != null ? ((Number) count).intValue() : 0;
    }

    // Insert record
    public int insertRecord(String table, Map<String, Object> columnValues) throws SQLException {
        StringBuilder columns = new StringBuilder();
        StringBuilder placeholders = new StringBuilder();
        List<Object> values = new ArrayList<>();

        columnValues.forEach((column, value) -> {
            if (columns.length() > 0) {
                columns.append(", ");
                placeholders.append(", ");
            }
            columns.append(column);
            placeholders.append("?");
            values.add(value);
        });

        String query = String.format("INSERT INTO %s (%s) VALUES (%s)",
            table, columns, placeholders);

        return dbManager.executeUpdate(query, values.toArray());
    }

    // Update record
    public int updateRecord(String table, Map<String, Object> columnValues,
                          String whereClause, Object... whereParams) throws SQLException {
        StringBuilder setClause = new StringBuilder();
        List<Object> values = new ArrayList<>();

        columnValues.forEach((column, value) -> {
            if (setClause.length() > 0) {
                setClause.append(", ");
            }
            setClause.append(column).append(" = ?");
            values.add(value);
        });

        values.addAll(Arrays.asList(whereParams));

        String query = String.format("UPDATE %s SET %s WHERE %s",
            table, setClause, whereClause);

        return dbManager.executeUpdate(query, values.toArray());
    }

    // Delete record
    public int deleteRecord(String table, String whereClause, Object... params)
            throws SQLException {
        String query = String.format("DELETE FROM %s WHERE %s", table, whereClause);
        return dbManager.executeUpdate(query, params);
    }

    // Helper: Set prepared statement parameters
    private void setParameters(PreparedStatement statement, Object... params)
            throws SQLException {
        for (int i = 0; i < params.length; i++) {
            statement.setObject(i + 1, params[i]);
        }
    }

    // Helper: Convert ResultSet row to Map
    private Map<String, Object> resultSetToMap(ResultSet rs) throws SQLException {
        Map<String, Object> row = new HashMap<>();
        ResultSetMetaData metaData = rs.getMetaData();
        int columnCount = metaData.getColumnCount();

        for (int i = 1; i <= columnCount; i++) {
            String columnName = metaData.getColumnName(i);
            Object value = rs.getObject(i);
            row.put(columnName, value);
        }

        return row;
    }
}

// 3. Test Data Manager
public class TestDataManager {
    private DatabaseQueryHandler queryHandler;
    private List<TestDataRecord> testDataRecords;

    public TestDataManager() {
        this.queryHandler = new DatabaseQueryHandler();
        this.testDataRecords = new ArrayList<>();
    }

    // Insert test user
    public Map<String, Object> insertTestUser(String username, String email, String password)
            throws SQLException {
        Map<String, Object> user = new HashMap<>();
        user.put("username", username);
        user.put("email", email);
        user.put("password", password);
        user.put("created_at", new Timestamp(System.currentTimeMillis()));
        user.put("is_active", true);

        int userId = queryHandler.insertRecord("users", user);

        // Track for cleanup
        testDataRecords.add(new TestDataRecord("users", "id", userId));

        user.put("id", userId);
        return user;
    }

    // Insert test order
    public Map<String, Object> insertTestOrder(int userId, String productName, double amount)
            throws SQLException {
        Map<String, Object> order = new HashMap<>();
        order.put("user_id", userId);
        order.put("product_name", productName);
        order.put("amount", amount);
        order.put("status", "pending");
        order.put("order_date", new Timestamp(System.currentTimeMillis()));

        int orderId = queryHandler.insertRecord("orders", order);

        testDataRecords.add(new TestDataRecord("orders", "id", orderId));

        order.put("id", orderId);
        return order;
    }

    // Get test user by email
    public Map<String, Object> getTestUserByEmail(String email) throws SQLException {
        return queryHandler.getSingleRow("SELECT * FROM users WHERE email = ?", email);
    }

    // Clean up all test data
    public void cleanupAllTestData() throws SQLException {
        // Delete in reverse order to handle foreign key constraints
        Collections.reverse(testDataRecords);

        for (TestDataRecord record : testDataRecords) {
            queryHandler.deleteRecord(record.getTable(),
                record.getIdColumn() + " = ?",
                record.getIdValue());
        }

        testDataRecords.clear();
        System.out.println("Test data cleaned up successfully");
    }

    // Helper class to track test data
    private static class TestDataRecord {
        private String table;
        private String idColumn;
        private Object idValue;

        public TestDataRecord(String table, String idColumn, Object idValue) {
            this.table = table;
            this.idColumn = idColumn;
            this.idValue = idValue;
        }

        public String getTable() { return table; }
        public String getIdColumn() { return idColumn; }
        public Object getIdValue() { return idValue; }
    }
}

// 4. Database Assertions
public class DatabaseAssertions {
    private DatabaseQueryHandler queryHandler;

    public DatabaseAssertions() {
        this.queryHandler = new DatabaseQueryHandler();
    }

    // Assert record exists
    public void assertRecordExists(String table, String whereClause, Object... params)
            throws SQLException {
        boolean exists = queryHandler.recordExists(table, whereClause, params);
        Assert.assertTrue(exists,
            String.format("Record not found in table %s with condition: %s", table, whereClause));
    }

    // Assert record does not exist
    public void assertRecordDoesNotExist(String table, String whereClause, Object... params)
            throws SQLException {
        boolean exists = queryHandler.recordExists(table, whereClause, params);
        Assert.assertFalse(exists,
            String.format("Record should not exist in table %s with condition: %s",
                table, whereClause));
    }

    // Assert record count
    public void assertRecordCount(String table, int expectedCount, String whereClause,
                                Object... params) throws SQLException {
        int actualCount = queryHandler.getRecordCount(table, whereClause, params);
        Assert.assertEquals(actualCount, expectedCount,
            String.format("Record count mismatch in table %s", table));
    }

    // Assert column value
    public void assertColumnValue(String table, String column, Object expectedValue,
                                 String whereClause, Object... params) throws SQLException {
        String query = String.format("SELECT %s FROM %s WHERE %s", column, table, whereClause);
        Object actualValue = queryHandler.getSingleValue(query, params);
        Assert.assertEquals(actualValue, expectedValue,
            String.format("Column value mismatch for %s.%s", table, column));
    }

    // Assert data matches UI
    public void assertDataMatchesUI(Map<String, Object> dbData, Map<String, String> uiData) {
        for (Map.Entry<String, String> entry : uiData.entrySet()) {
            String key = entry.getKey();
            String uiValue = entry.getValue();
            Object dbValue = dbData.get(key);

            Assert.assertEquals(String.valueOf(dbValue), uiValue,
                String.format("Data mismatch for field: %s", key));
        }
    }
}

// 5. Page Object with Database Validation
public class UserRegistrationPage {
    private WebDriver driver;
    private TestDataManager testDataManager;
    private DatabaseAssertions dbAssertions;

    @FindBy(id = "username")
    private WebElement usernameField;

    @FindBy(id = "email")
    private WebElement emailField;

    @FindBy(id = "password")
    private WebElement passwordField;

    @FindBy(id = "register")
    private WebElement registerButton;

    @FindBy(id = "success-message")
    private WebElement successMessage;

    public UserRegistrationPage(WebDriver driver) {
        this.driver = driver;
        this.testDataManager = new TestDataManager();
        this.dbAssertions = new DatabaseAssertions();
        PageFactory.initElements(driver, this);
    }

    // Register user and verify in database
    public void registerAndVerifyInDB(String username, String email, String password)
            throws SQLException {
        // Perform registration
        usernameField.sendKeys(username);
        emailField.sendKeys(email);
        passwordField.sendKeys(password);
        registerButton.click();

        // Wait for success
        new WebDriverWait(driver, Duration.ofSeconds(10))
            .until(ExpectedConditions.visibilityOf(successMessage));

        // Verify in database
        dbAssertions.assertRecordExists("users", "email = ?", email);

        // Verify all fields
        dbAssertions.assertColumnValue("users", "username", username, "email = ?", email);
        dbAssertions.assertColumnValue("users", "is_active", true, "email = ?", email);
    }

    // Clean up test data
    public void cleanup() throws SQLException {
        testDataManager.cleanupAllTestData();
    }
}

// 6. Test Examples
public class DatabaseIntegrationTests {
    private WebDriver driver;
    private TestDataManager testDataManager;
    private DatabaseQueryHandler queryHandler;
    private DatabaseAssertions dbAssertions;

    @BeforeMethod
    public void setUp() {
        driver = new ChromeDriver();
        testDataManager = new TestDataManager();
        queryHandler = new DatabaseQueryHandler();
        dbAssertions = new DatabaseAssertions();
    }

    @Test
    public void testUserRegistrationWithDBValidation() throws SQLException {
        driver.get("https://example.com/register");

        String email = "test_" + System.currentTimeMillis() + "@example.com";

        UserRegistrationPage registrationPage = new UserRegistrationPage(driver);
        registrationPage.registerAndVerifyInDB("testuser", email, "password123");

        // Additional validation
        Map<String, Object> user = testDataManager.getTestUserByEmail(email);
        Assert.assertNotNull(user, "User should be created in database");
        Assert.assertEquals(user.get("username"), "testuser");
    }

    @Test
    public void testOrderCreationWithDBValidation() throws SQLException {
        // Setup test data
        Map<String, Object> user = testDataManager.insertTestUser(
            "testuser", "test@example.com", "password"
        );

        // Login and create order
        driver.get("https://example.com/login");
        // ... login steps ...

        driver.get("https://example.com/products");
        // ... add to cart and checkout ...

        // Verify order in database
        dbAssertions.assertRecordExists("orders",
            "user_id = ? AND status = ?",
            user.get("id"), "pending");

        // Get order details
        Map<String, Object> order = queryHandler.getSingleRow(
            "SELECT * FROM orders WHERE user_id = ? ORDER BY id DESC LIMIT 1",
            user.get("id")
        );

        Assert.assertNotNull(order);
        Assert.assertEquals(order.get("status"), "pending");
    }

    @Test
    public void testDataDrivenTestWithDBDataProvider() throws SQLException {
        // Get test users from database
        List<Map<String, Object>> users = queryHandler.getMultipleRows(
            "SELECT username, email FROM users WHERE is_test_user = ?", true
        );

        for (Map<String, Object> user : users) {
            driver.get("https://example.com/login");

            // Test login with each user
            driver.findElement(By.id("username")).sendKeys((String) user.get("username"));
            // ... complete login ...

            // Verify
            dbAssertions.assertRecordExists("login_logs",
                "username = ?", user.get("username"));
        }
    }

    @Test
    public void testProfileUpdateReflectsInDB() throws SQLException {
        // Setup test user
        Map<String, Object> user = testDataManager.insertTestUser(
            "testuser", "test@example.com", "password"
        );

        // Login and update profile
        driver.get("https://example.com/login");
        // ... login ...

        driver.get("https://example.com/profile");
        driver.findElement(By.id("phone")).sendKeys("1234567890");
        driver.findElement(By.id("save")).click();

        // Verify update in database
        Thread.sleep(2000); // Wait for async update

        dbAssertions.assertColumnValue("users", "phone",
            "1234567890", "id = ?", user.get("id"));
    }

    @Test
    public void testUIDataMatchesDatabase() throws SQLException {
        // Setup test user
        Map<String, Object> user = testDataManager.insertTestUser(
            "testuser", "test@example.com", "password"
        );

        // Navigate to profile
        driver.get("https://example.com/login");
        // ... login ...

        driver.get("https://example.com/profile");

        // Get UI data
        Map<String, String> uiData = new HashMap<>();
        uiData.put("username", driver.findElement(By.id("username")).getText());
        uiData.put("email", driver.findElement(By.id("email")).getText());

        // Get database data
        Map<String, Object> dbData = queryHandler.getSingleRow(
            "SELECT * FROM users WHERE id = ?", user.get("id")
        );

        // Assert they match
        dbAssertions.assertDataMatchesUI(dbData, uiData);
    }

    @AfterMethod
    public void tearDown() throws SQLException {
        if (testDataManager != null) {
            testDataManager.cleanupAllTestData();
        }

        if (driver != null) {
            driver.quit();
        }
    }
}

// 7. Configuration file: database.properties
/*
db.url=jdbc:mysql://localhost:3306/testdb
db.username=testuser
db.password=testpassword
db.driver=com.mysql.cj.jdbc.Driver
*/
```

**Follow-up**: How to handle database transactions in tests? How to test with NoSQL databases like MongoDB? What's the best way to manage database credentials securely? How to implement database connection pooling for parallel tests?

---

### **Q93: How do you implement screenshot and video recording in Selenium tests?** (6-8 Years, 9-12 Years)
**Companies**: Google, Amazon, Microsoft, Netflix, Flipkart, Adobe
**Difficulty**: Hard

**Answer**: Screenshot and video recording are critical for debugging test failures, creating evidence of test execution, and documenting issues. Selenium provides `TakesScreenshot` interface for capturing screenshots at any point during test execution. Advanced implementations include: capturing screenshots on failure only, embedding screenshots in test reports, capturing full-page screenshots for long pages, and highlighting elements before capture. Video recording can be achieved through external tools like Monte Screen Recorder for Java or using Docker containers with video recording capabilities. For CI/CD environments, Docker Selenium with VNC support enables video recording of entire test sessions. Screenshots should be organized by test name, timestamp, and failure reason. Integration with reporting frameworks (Extent Reports, Allure) enables automatic embedding of visual evidence. Best practices include: capturing screenshots before critical actions, taking screenshots on both pass and fail for critical tests, storing screenshots with unique names to avoid overwrites, and implementing screenshot utilities in base test classes for reusability.

**Code Example**:

```java
// 1. Screenshot Manager
import org.openqa.selenium.*;
import org.apache.commons.io.FileUtils;
import ru.yandex.qatools.ashot.AShot;
import ru.yandex.qatools.ashot.Screenshot;
import ru.yandex.qatools.ashot.shooting.ShootingStrategies;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.*;
import java.text.SimpleDateFormat;
import java.util.*;

public class ScreenshotManager {
    private WebDriver driver;
    private String screenshotDirectory;
    private SimpleDateFormat dateFormat;

    public ScreenshotManager(WebDriver driver, String screenshotDirectory) {
        this.driver = driver;
        this.screenshotDirectory = screenshotDirectory;
        this.dateFormat = new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss-SSS");
        createScreenshotDirectory();
    }

    // Create screenshot directory if not exists
    private void createScreenshotDirectory() {
        File directory = new File(screenshotDirectory);
        if (!directory.exists()) {
            directory.mkdirs();
        }
    }

    // Capture screenshot with default naming
    public String captureScreenshot(String testName) {
        String timestamp = dateFormat.format(new Date());
        String fileName = String.format("%s_%s.png", testName, timestamp);
        String filePath = screenshotDirectory + File.separator + fileName;

        try {
            File screenshot = ((TakesScreenshot) driver).getScreenshotAs(OutputType.FILE);
            FileUtils.copyFile(screenshot, new File(filePath));
            System.out.println("Screenshot saved: " + filePath);
            return filePath;
        } catch (IOException e) {
            System.err.println("Failed to save screenshot: " + e.getMessage());
            return null;
        }
    }

    // Capture screenshot on failure
    public String captureFailureScreenshot(String testName, String failureReason) {
        String sanitizedReason = failureReason.replaceAll("[^a-zA-Z0-9]", "_");
        String timestamp = dateFormat.format(new Date());
        String fileName = String.format("%s_FAILED_%s_%s.png",
            testName, sanitizedReason, timestamp);
        String filePath = screenshotDirectory + File.separator + fileName;

        try {
            File screenshot = ((TakesScreenshot) driver).getScreenshotAs(OutputType.FILE);
            FileUtils.copyFile(screenshot, new File(filePath));
            System.out.println("Failure screenshot saved: " + filePath);
            return filePath;
        } catch (IOException e) {
            System.err.println("Failed to save failure screenshot: " + e.getMessage());
            return null;
        }
    }

    // Capture full page screenshot using AShot
    public String captureFullPageScreenshot(String testName) {
        String timestamp = dateFormat.format(new Date());
        String fileName = String.format("%s_fullpage_%s.png", testName, timestamp);
        String filePath = screenshotDirectory + File.separator + fileName;

        try {
            Screenshot screenshot = new AShot()
                .shootingStrategy(ShootingStrategies.viewportPasting(1000))
                .takeScreenshot(driver);

            ImageIO.write(screenshot.getImage(), "PNG", new File(filePath));
            System.out.println("Full page screenshot saved: " + filePath);
            return filePath;
        } catch (IOException e) {
            System.err.println("Failed to save full page screenshot: " + e.getMessage());
            return null;
        }
    }

    // Capture element screenshot
    public String captureElementScreenshot(WebElement element, String elementName) {
        String timestamp = dateFormat.format(new Date());
        String fileName = String.format("%s_element_%s.png", elementName, timestamp);
        String filePath = screenshotDirectory + File.separator + fileName;

        try {
            File screenshot = element.getScreenshotAs(OutputType.FILE);
            FileUtils.copyFile(screenshot, new File(filePath));
            System.out.println("Element screenshot saved: " + filePath);
            return filePath;
        } catch (IOException e) {
            System.err.println("Failed to save element screenshot: " + e.getMessage());
            return null;
        }
    }

    // Capture screenshot with highlighted element
    public String captureWithHighlight(WebElement element, String testName) {
        // Highlight element
        highlightElement(element);

        // Capture screenshot
        String screenshotPath = captureScreenshot(testName + "_highlighted");

        // Remove highlight
        removeHighlight(element);

        return screenshotPath;
    }

    // Highlight element with border
    private void highlightElement(WebElement element) {
        JavascriptExecutor js = (JavascriptExecutor) driver;
        js.executeScript(
            "arguments[0].setAttribute('style', 'border: 3px solid red; background: yellow;');",
            element
        );
    }

    // Remove highlight from element
    private void removeHighlight(WebElement element) {
        JavascriptExecutor js = (JavascriptExecutor) driver;
        js.executeScript("arguments[0].setAttribute('style', '');", element);
    }

    // Capture screenshot as Base64 (for embedding in reports)
    public String captureScreenshotAsBase64() {
        return ((TakesScreenshot) driver).getScreenshotAs(OutputType.BASE64);
    }

    // Compare two screenshots (basic pixel comparison)
    public boolean compareScreenshots(String screenshot1Path, String screenshot2Path) {
        try {
            BufferedImage img1 = ImageIO.read(new File(screenshot1Path));
            BufferedImage img2 = ImageIO.read(new File(screenshot2Path));

            if (img1.getWidth() != img2.getWidth() || img1.getHeight() != img2.getHeight()) {
                return false;
            }

            for (int y = 0; y < img1.getHeight(); y++) {
                for (int x = 0; x < img1.getWidth(); x++) {
                    if (img1.getRGB(x, y) != img2.getRGB(x, y)) {
                        return false;
                    }
                }
            }

            return true;
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }
    }

    // Get screenshot as byte array
    public byte[] getScreenshotAsByteArray() {
        return ((TakesScreenshot) driver).getScreenshotAs(OutputType.BYTES);
    }

    // Clear old screenshots (cleanup)
    public void clearOldScreenshots(int daysOld) {
        File directory = new File(screenshotDirectory);
        File[] files = directory.listFiles();

        if (files != null) {
            long cutoffTime = System.currentTimeMillis() - (daysOld * 24 * 60 * 60 * 1000L);

            for (File file : files) {
                if (file.lastModified() < cutoffTime) {
                    file.delete();
                    System.out.println("Deleted old screenshot: " + file.getName());
                }
            }
        }
    }
}

// 2. Video Recorder using Monte Screen Recorder
import org.monte.media.Format;
import org.monte.media.Registry;
import org.monte.media.math.Rational;
import org.monte.screenrecorder.ScreenRecorder;

import java.awt.*;
import java.io.File;
import java.io.IOException;

import static org.monte.media.FormatKeys.*;
import static org.monte.media.VideoFormatKeys.*;

public class VideoRecorder {
    private ScreenRecorder screenRecorder;
    private String videoDirectory;
    private String currentVideoName;

    public VideoRecorder(String videoDirectory) {
        this.videoDirectory = videoDirectory;
        createVideoDirectory();
    }

    // Create video directory
    private void createVideoDirectory() {
        File directory = new File(videoDirectory);
        if (!directory.exists()) {
            directory.mkdirs();
        }
    }

    // Start recording
    public void startRecording(String testName) throws IOException, AWTException {
        File file = new File(videoDirectory);

        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
        int width = screenSize.width;
        int height = screenSize.height;

        Rectangle captureSize = new Rectangle(0, 0, width, height);

        GraphicsConfiguration gc = GraphicsEnvironment
            .getLocalGraphicsEnvironment()
            .getDefaultScreenDevice()
            .getDefaultConfiguration();

        this.screenRecorder = new ScreenRecorder(gc, captureSize,
            new Format(MediaTypeKey, MediaType.FILE, MimeTypeKey, MIME_AVI),
            new Format(MediaTypeKey, MediaType.VIDEO, EncodingKey, ENCODING_AVI_TECHSMITH_SCREEN_CAPTURE,
                CompressorNameKey, ENCODING_AVI_TECHSMITH_SCREEN_CAPTURE,
                DepthKey, 24, FrameRateKey, Rational.valueOf(15),
                QualityKey, 1.0f,
                KeyFrameIntervalKey, 15 * 60),
            new Format(MediaTypeKey, MediaType.VIDEO, EncodingKey, "black",
                FrameRateKey, Rational.valueOf(30)),
            null,
            file);

        this.currentVideoName = testName;
        screenRecorder.start();
        System.out.println("Video recording started for: " + testName);
    }

    // Stop recording
    public String stopRecording() throws IOException {
        if (screenRecorder != null) {
            screenRecorder.stop();
            System.out.println("Video recording stopped");

            // Get the recorded file
            List<File> createdMovieFiles = screenRecorder.getCreatedMovieFiles();
            if (!createdMovieFiles.isEmpty()) {
                File videoFile = createdMovieFiles.get(0);

                // Rename with test name
                String newFileName = currentVideoName + "_" +
                    new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss").format(new Date()) + ".avi";
                File renamedFile = new File(videoDirectory + File.separator + newFileName);

                videoFile.renameTo(renamedFile);
                return renamedFile.getAbsolutePath();
            }
        }
        return null;
    }
}

// 3. Screenshot Listener for TestNG
import org.testng.*;

public class ScreenshotListener implements ITestListener {
    private ScreenshotManager screenshotManager;

    @Override
    public void onStart(ITestContext context) {
        WebDriver driver = (WebDriver) context.getAttribute("driver");
        String screenshotDir = System.getProperty("user.dir") + "/screenshots";
        screenshotManager = new ScreenshotManager(driver, screenshotDir);
    }

    @Override
    public void onTestFailure(ITestResult result) {
        String testName = result.getName();
        String failureReason = result.getThrowable() != null ?
            result.getThrowable().getMessage() : "Unknown";

        String screenshotPath = screenshotManager.captureFailureScreenshot(
            testName, failureReason
        );

        // Attach to report
        if (screenshotPath != null) {
            System.out.println("Screenshot attached: " + screenshotPath);
            // Can be used with Reporter.log() for HTML reports
        }
    }

    @Override
    public void onTestSuccess(ITestResult result) {
        // Optionally capture screenshot on success
        if (Boolean.getBoolean("screenshot.on.success")) {
            String testName = result.getName();
            screenshotManager.captureScreenshot(testName + "_PASSED");
        }
    }
}

// 4. Extent Report with Screenshot Integration
import com.aventstack.extentreports.ExtentReports;
import com.aventstack.extentreports.ExtentTest;
import com.aventstack.extentreports.Status;
import com.aventstack.extentreports.reporter.ExtentSparkReporter;

public class ExtentReportManager {
    private static ExtentReports extent;
    private static ThreadLocal<ExtentTest> test = new ThreadLocal<>();
    private static ScreenshotManager screenshotManager;

    // Initialize report
    public static void initReport(String reportPath, WebDriver driver, String screenshotDir) {
        ExtentSparkReporter sparkReporter = new ExtentSparkReporter(reportPath);
        sparkReporter.config().setReportName("Automation Test Results");
        sparkReporter.config().setDocumentTitle("Test Report");

        extent = new ExtentReports();
        extent.attachReporter(sparkReporter);
        extent.setSystemInfo("OS", System.getProperty("os.name"));
        extent.setSystemInfo("Browser", driver.getClass().getSimpleName());

        screenshotManager = new ScreenshotManager(driver, screenshotDir);
    }

    // Create test
    public static ExtentTest createTest(String testName, String description) {
        ExtentTest extentTest = extent.createTest(testName, description);
        test.set(extentTest);
        return extentTest;
    }

    // Get current test
    public static ExtentTest getTest() {
        return test.get();
    }

    // Log with screenshot
    public static void logWithScreenshot(Status status, String message) {
        String screenshotPath = screenshotManager.captureScreenshot("step_screenshot");
        getTest().log(status, message)
            .addScreenCaptureFromPath(screenshotPath);
    }

    // Log failure with screenshot
    public static void logFailure(String message, Throwable throwable) {
        String screenshotPath = screenshotManager.captureFailureScreenshot(
            "failure", message
        );
        getTest().fail(message)
            .fail(throwable)
            .addScreenCaptureFromPath(screenshotPath);
    }

    // Flush report
    public static void flushReport() {
        extent.flush();
    }
}

// 5. Base Test with Screenshot Capability
public class BaseTest {
    protected WebDriver driver;
    protected ScreenshotManager screenshotManager;
    protected VideoRecorder videoRecorder;
    private boolean recordVideo = false;

    @BeforeMethod
    public void setUp(Method method) throws IOException, AWTException {
        driver = new ChromeDriver();
        driver.manage().window().maximize();

        // Initialize screenshot manager
        String screenshotDir = System.getProperty("user.dir") + "/screenshots";
        screenshotManager = new ScreenshotManager(driver, screenshotDir);

        // Initialize video recorder if enabled
        recordVideo = Boolean.getBoolean("record.video");
        if (recordVideo) {
            String videoDir = System.getProperty("user.dir") + "/videos";
            videoRecorder = new VideoRecorder(videoDir);
            videoRecorder.startRecording(method.getName());
        }

        // Initialize Extent Report
        String reportPath = System.getProperty("user.dir") + "/reports/extent-report.html";
        ExtentReportManager.initReport(reportPath, driver, screenshotDir);
        ExtentReportManager.createTest(method.getName(), "Test: " + method.getName());
    }

    @AfterMethod
    public void tearDown(ITestResult result) throws IOException {
        // Capture screenshot on failure
        if (result.getStatus() == ITestResult.FAILURE) {
            String screenshotPath = screenshotManager.captureFailureScreenshot(
                result.getName(),
                result.getThrowable().getMessage()
            );

            ExtentReportManager.logFailure(
                "Test failed: " + result.getThrowable().getMessage(),
                result.getThrowable()
            );
        } else if (result.getStatus() == ITestResult.SUCCESS) {
            ExtentReportManager.getTest().pass("Test passed successfully");
        }

        // Stop video recording
        if (recordVideo && videoRecorder != null) {
            String videoPath = videoRecorder.stopRecording();
            System.out.println("Video saved: " + videoPath);
        }

        // Cleanup
        if (driver != null) {
            driver.quit();
        }

        ExtentReportManager.flushReport();
    }

    // Helper method to capture screenshot during test
    protected void captureScreenshot(String stepName) {
        String screenshotPath = screenshotManager.captureScreenshot(stepName);
        ExtentReportManager.getTest()
            .info("Screenshot captured for: " + stepName)
            .addScreenCaptureFromPath(screenshotPath);
    }

    // Helper method to capture element screenshot
    protected void captureElementScreenshot(WebElement element, String elementName) {
        String screenshotPath = screenshotManager.captureElementScreenshot(element, elementName);
        ExtentReportManager.getTest()
            .info("Element screenshot captured: " + elementName)
            .addScreenCaptureFromPath(screenshotPath);
    }

    // Helper method to capture with highlight
    protected void captureWithHighlight(WebElement element, String description) {
        String screenshotPath = screenshotManager.captureWithHighlight(element, description);
        ExtentReportManager.getTest()
            .info("Highlighted screenshot: " + description)
            .addScreenCaptureFromPath(screenshotPath);
    }
}

// 6. Test Examples
public class ScreenshotTests extends BaseTest {

    @Test
    public void testWithScreenshotOnEachStep() {
        ExtentReportManager.getTest().info("Starting test");

        // Step 1: Navigate
        driver.get("https://example.com");
        captureScreenshot("navigate_to_homepage");
        ExtentReportManager.getTest().pass("Navigated to homepage");

        // Step 2: Login
        WebElement usernameField = driver.findElement(By.id("username"));
        usernameField.sendKeys("testuser");
        captureElementScreenshot(usernameField, "username_field");

        WebElement passwordField = driver.findElement(By.id("password"));
        passwordField.sendKeys("password");

        WebElement loginButton = driver.findElement(By.id("login"));
        captureWithHighlight(loginButton, "login_button_before_click");
        loginButton.click();

        captureScreenshot("after_login");
        ExtentReportManager.getTest().pass("Login successful");

        // Verify
        Assert.assertTrue(driver.getCurrentUrl().contains("dashboard"));
    }

    @Test
    public void testFullPageScreenshot() {
        driver.get("https://example.com/long-page");

        // Regular screenshot (viewport only)
        captureScreenshot("viewport_screenshot");

        // Full page screenshot
        String fullPagePath = screenshotManager.captureFullPageScreenshot("full_page");
        ExtentReportManager.getTest()
            .info("Full page screenshot captured")
            .addScreenCaptureFromPath(fullPagePath);

        Assert.assertNotNull(fullPagePath);
    }

    @Test
    public void testScreenshotComparison() throws IOException {
        driver.get("https://example.com");

        // Capture baseline
        String baseline = screenshotManager.captureScreenshot("baseline");

        // Make some change
        driver.navigate().refresh();

        // Capture after change
        String afterChange = screenshotManager.captureScreenshot("after_change");

        // Compare
        boolean areSame = screenshotManager.compareScreenshots(baseline, afterChange);

        ExtentReportManager.getTest().info("Screenshots comparison: " +
            (areSame ? "Identical" : "Different"));

        Assert.assertTrue(areSame, "Screenshots should be identical after refresh");
    }

    @Test(expectedExceptions = AssertionError.class)
    public void testFailureScreenshotCapture() {
        driver.get("https://example.com");

        // This will fail and trigger screenshot on failure
        Assert.fail("Intentional failure to test screenshot capture");
    }
}

// 7. Docker Selenium with Video Recording
/*
docker-compose.yml:

version: '3'
services:
  chrome:
    image: selenium/standalone-chrome:latest
    shm_size: 2gb
    ports:
      - "4444:4444"
      - "7900:7900"
    environment:
      - SE_VIDEO_FOLDER=/videos
      - SE_VIDEO_FILE_NAME=test_recording.mp4
    volumes:
      - ./videos:/videos
*/

// 8. Cleanup Utility
public class ScreenshotCleanupUtility {

    // Clean screenshots older than specified days
    public static void cleanupOldScreenshots(String directory, int daysOld) {
        File dir = new File(directory);
        File[] files = dir.listFiles();

        if (files != null) {
            long cutoffTime = System.currentTimeMillis() - (daysOld * 24 * 60 * 60 * 1000L);
            int deletedCount = 0;

            for (File file : files) {
                if (file.lastModified() < cutoffTime) {
                    if (file.delete()) {
                        deletedCount++;
                    }
                }
            }

            System.out.println("Deleted " + deletedCount + " old screenshots");
        }
    }

    // Clean screenshots by test status (keep only failures)
    public static void keepOnlyFailureScreenshots(String directory) {
        File dir = new File(directory);
        File[] files = dir.listFiles();

        if (files != null) {
            int deletedCount = 0;

            for (File file : files) {
                if (!file.getName().contains("FAILED")) {
                    if (file.delete()) {
                        deletedCount++;
                    }
                }
            }

            System.out.println("Deleted " + deletedCount + " non-failure screenshots");
        }
    }

    // Archive screenshots to zip
    public static void archiveScreenshots(String sourceDir, String zipFilePath)
            throws IOException {
        FileOutputStream fos = new FileOutputStream(zipFilePath);
        ZipOutputStream zos = new ZipOutputStream(fos);

        File srcFile = new File(sourceDir);
        addDirToZip(zos, srcFile, srcFile.getName());

        zos.close();
        fos.close();

        System.out.println("Screenshots archived to: " + zipFilePath);
    }

    private static void addDirToZip(ZipOutputStream zos, File srcFile, String parentName)
            throws IOException {
        File[] files = srcFile.listFiles();

        if (files != null) {
            for (File file : files) {
                if (file.isDirectory()) {
                    addDirToZip(zos, file, parentName + "/" + file.getName());
                } else {
                    FileInputStream fis = new FileInputStream(file);
                    ZipEntry zipEntry = new ZipEntry(parentName + "/" + file.getName());
                    zos.putNextEntry(zipEntry);

                    byte[] bytes = new byte[1024];
                    int length;
                    while ((length = fis.read(bytes)) >= 0) {
                        zos.write(bytes, 0, length);
                    }

                    fis.close();
                }
            }
        }
    }
}
```

**Follow-up**: How to capture screenshots in headless mode? How to integrate with cloud storage for screenshot storage? What are best practices for screenshot retention in CI/CD? How to capture GIF animations instead of static screenshots?

---

### **Q94: How do you integrate advanced reporting (Extent Reports, Allure) with Selenium tests?** (6-8 Years, 9-12 Years)
**Companies**: Google, Amazon, Microsoft, Flipkart, Adobe, Paytm
**Difficulty**: Hard

**Answer**: Advanced reporting frameworks like Extent Reports and Allure provide comprehensive test execution dashboards with rich visualizations, screenshots, logs, and analytics. Extent Reports offers HTML-based reports with charts, timelines, and test categorization, while Allure provides modern interactive reports with test history trends, attachments, and detailed test steps. Integration involves: adding dependencies, creating report managers, implementing listeners, attaching screenshots and logs, organizing tests with categories/features, and generating reports post-execution. Best practices include: capturing detailed test steps with descriptions, attaching relevant evidence (screenshots, logs, network calls), categorizing tests by feature/priority, tracking test execution time and trends, and generating reports in CI/CD pipelines. Both frameworks support parallel execution with thread-safe implementations. Extent Reports uses `ExtentReports` and `ExtentTest` APIs, while Allure uses annotations and attachment APIs. Reports should be published to accessible locations (web servers, S3) for team visibility.

**Code Example**:

```java
// 1. Extent Reports Manager (Thread-Safe)
import com.aventstack.extentreports.*;
import com.aventstack.extentreports.reporter.ExtentSparkReporter;
import com.aventstack.extentreports.reporter.configuration.Theme;

import java.io.File;
import java.util.HashMap;
import java.util.Map;

public class ExtentManager {
    private static ExtentReports extent;
    private static ThreadLocal<ExtentTest> extentTest = new ThreadLocal<>();
    private static String reportPath;

    // Initialize Extent Reports
    public static synchronized ExtentReports createInstance(String fileName) {
        ExtentSparkReporter sparkReporter = new ExtentSparkReporter(fileName);

        // Configure report
        sparkReporter.config().setTheme(Theme.DARK);
        sparkReporter.config().setDocumentTitle("Automation Test Report");
        sparkReporter.config().setReportName("Selenium Test Execution Report");
        sparkReporter.config().setTimeStampFormat("MMM dd, yyyy HH:mm:ss");
        sparkReporter.config().setEncoding("utf-8");
        sparkReporter.config().setCss(".badge-primary { background-color: #1e88e5; }");
        sparkReporter.config().setJs("$('.badge').addClass('rounded-pill');");

        extent = new ExtentReports();
        extent.attachReporter(sparkReporter);

        // System information
        extent.setSystemInfo("OS", System.getProperty("os.name"));
        extent.setSystemInfo("OS Version", System.getProperty("os.version"));
        extent.setSystemInfo("Java Version", System.getProperty("java.version"));
        extent.setSystemInfo("User", System.getProperty("user.name"));
        extent.setSystemInfo("Environment", System.getProperty("env", "QA"));
        extent.setSystemInfo("Browser", System.getProperty("browser", "Chrome"));

        reportPath = fileName;
        return extent;
    }

    // Get Extent Reports instance
    public static synchronized ExtentReports getInstance() {
        if (extent == null) {
            String reportDir = System.getProperty("user.dir") + "/test-output/extent-reports/";
            new File(reportDir).mkdirs();
            String fileName = reportDir + "ExtentReport_" +
                new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss").format(new Date()) + ".html";
            createInstance(fileName);
        }
        return extent;
    }

    // Create test
    public static synchronized ExtentTest createTest(String testName, String description) {
        ExtentTest test = getInstance().createTest(testName, description);
        extentTest.set(test);
        return test;
    }

    // Get current test
    public static ExtentTest getTest() {
        return extentTest.get();
    }

    // Flush reports
    public static synchronized void flush() {
        if (extent != null) {
            extent.flush();
            System.out.println("Extent Report generated: " + reportPath);
        }
    }
}

// 2. Extent Test Listener
import org.testng.*;

public class ExtentTestListener implements ITestListener, ISuiteListener {
    private static ExtentReports extent;

    @Override
    public void onStart(ISuite suite) {
        extent = ExtentManager.getInstance();
    }

    @Override
    public void onFinish(ISuite suite) {
        ExtentManager.flush();
    }

    @Override
    public void onTestStart(ITestResult result) {
        String testName = result.getMethod().getMethodName();
        String description = result.getMethod().getDescription();
        ExtentManager.createTest(testName, description);

        // Add categories and groups
        Test testAnnotation = result.getMethod().getConstructorOrMethod()
            .getMethod().getAnnotation(Test.class);
        if (testAnnotation != null) {
            for (String group : testAnnotation.groups()) {
                ExtentManager.getTest().assignCategory(group);
            }
        }

        // Add author
        ExtentManager.getTest().assignAuthor(System.getProperty("user.name"));

        // Add device info if available
        Object driver = result.getTestContext().getAttribute("driver");
        if (driver != null) {
            ExtentManager.getTest().assignDevice(driver.getClass().getSimpleName());
        }
    }

    @Override
    public void onTestSuccess(ITestResult result) {
        ExtentManager.getTest().pass("Test passed successfully");
        ExtentManager.getTest().pass(MarkupHelper.createLabel(
            result.getName() + " - PASSED", ExtentColor.GREEN));
    }

    @Override
    public void onTestFailure(ITestResult result) {
        ExtentManager.getTest().fail(result.getThrowable());
        ExtentManager.getTest().fail(MarkupHelper.createLabel(
            result.getName() + " - FAILED", ExtentColor.RED));

        // Attach screenshot
        WebDriver driver = (WebDriver) result.getTestContext().getAttribute("driver");
        if (driver != null) {
            String screenshotPath = captureScreenshot(driver, result.getName());
            try {
                ExtentManager.getTest().addScreenCaptureFromPath(screenshotPath);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    @Override
    public void onTestSkipped(ITestResult result) {
        ExtentManager.getTest().skip(result.getThrowable());
        ExtentManager.getTest().skip(MarkupHelper.createLabel(
            result.getName() + " - SKIPPED", ExtentColor.YELLOW));
    }

    private String captureScreenshot(WebDriver driver, String testName) {
        String screenshotDir = System.getProperty("user.dir") + "/test-output/screenshots/";
        new File(screenshotDir).mkdirs();
        String screenshotPath = screenshotDir + testName + "_" +
            System.currentTimeMillis() + ".png";

        try {
            File screenshot = ((TakesScreenshot) driver).getScreenshotAs(OutputType.FILE);
            FileUtils.copyFile(screenshot, new File(screenshotPath));
            return screenshotPath;
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }
}

// 3. Extent Report Helper
public class ExtentReportHelper {

    // Log info with screenshot
    public static void logInfo(String message, WebDriver driver) {
        ExtentManager.getTest().info(message);
        attachScreenshot(driver);
    }

    // Log pass step
    public static void logPass(String message) {
        ExtentManager.getTest().pass(message);
    }

    // Log fail step
    public static void logFail(String message, WebDriver driver) {
        ExtentManager.getTest().fail(message);
        attachScreenshot(driver);
    }

    // Log warning
    public static void logWarning(String message) {
        ExtentManager.getTest().warning(message);
    }

    // Attach screenshot
    public static void attachScreenshot(WebDriver driver) {
        try {
            String base64Screenshot = ((TakesScreenshot) driver)
                .getScreenshotAs(OutputType.BASE64);
            ExtentManager.getTest().addScreenCaptureFromBase64String(base64Screenshot);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    // Log JSON data
    public static void logJson(String json) {
        ExtentManager.getTest().info(MarkupHelper.createCodeBlock(json, CodeLanguage.JSON));
    }

    // Log code block
    public static void logCode(String code, CodeLanguage language) {
        ExtentManager.getTest().info(MarkupHelper.createCodeBlock(code, language));
    }

    // Log table
    public static void logTable(String[][] data) {
        ExtentManager.getTest().info(MarkupHelper.createTable(data));
    }

    // Create test node (sub-test)
    public static ExtentTest createNode(String nodeName) {
        return ExtentManager.getTest().createNode(nodeName);
    }
}

// 4. Allure Report Integration
import io.qameta.allure.*;
import io.qameta.allure.model.Status;

public class AllureManager {

    // Attach screenshot to Allure
    @Attachment(value = "Screenshot", type = "image/png")
    public static byte[] attachScreenshot(WebDriver driver) {
        return ((TakesScreenshot) driver).getScreenshotAs(OutputType.BYTES);
    }

    // Attach text to Allure
    @Attachment(value = "{0}", type = "text/plain")
    public static String attachText(String name, String content) {
        return content;
    }

    // Attach JSON to Allure
    @Attachment(value = "JSON Response", type = "application/json")
    public static String attachJson(String json) {
        return json;
    }

    // Attach HTML to Allure
    @Attachment(value = "HTML Content", type = "text/html")
    public static String attachHtml(String html) {
        return html;
    }

    // Log step
    public static void logStep(String message) {
        Allure.step(message);
    }

    // Log step with status
    public static void logStep(String message, Status status) {
        Allure.step(message, status);
    }

    // Add parameter to report
    public static void addParameter(String name, String value) {
        Allure.parameter(name, value);
    }

    // Add environment info
    public static void addEnvironment(String name, String value) {
        Allure.addAttachment("Environment", "text/plain",
            name + ": " + value, ".txt");
    }

    // Set test description
    public static void setDescription(String description) {
        Allure.description(description);
    }

    // Add link
    public static void addLink(String name, String url) {
        Allure.link(name, url);
    }
}

// 5. Allure Test Listener
public class AllureTestListener implements ITestListener {

    @Override
    public void onTestStart(ITestResult result) {
        AllureManager.logStep("Test started: " + result.getName());
        AllureManager.addParameter("Test Name", result.getName());
        AllureManager.addParameter("Description",
            result.getMethod().getDescription());
    }

    @Override
    public void onTestSuccess(ITestResult result) {
        AllureManager.logStep("Test passed: " + result.getName(), Status.PASSED);
    }

    @Override
    public void onTestFailure(ITestResult result) {
        AllureManager.logStep("Test failed: " + result.getName(), Status.FAILED);

        // Attach screenshot
        WebDriver driver = (WebDriver) result.getTestContext().getAttribute("driver");
        if (driver != null) {
            AllureManager.attachScreenshot(driver);
        }

        // Attach error message
        AllureManager.attachText("Error Message",
            result.getThrowable().getMessage());
        AllureManager.attachText("Stack Trace",
            getStackTrace(result.getThrowable()));
    }

    @Override
    public void onTestSkipped(ITestResult result) {
        AllureManager.logStep("Test skipped: " + result.getName(), Status.SKIPPED);
    }

    private String getStackTrace(Throwable throwable) {
        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(sw);
        throwable.printStackTrace(pw);
        return sw.toString();
    }
}

// 6. Test Examples with Extent Reports
public class ExtentReportTests extends BaseTest {

    @Test(description = "Login test with detailed reporting",
          groups = {"smoke", "regression"})
    @Severity(SeverityLevel.CRITICAL)
    @Story("User Authentication")
    @Feature("Login")
    public void testLoginWithExtentReport() {
        ExtentReportHelper.logInfo("Navigate to login page", driver);
        driver.get("https://example.com/login");

        ExtentReportHelper.logInfo("Enter username", driver);
        WebElement username = driver.findElement(By.id("username"));
        username.sendKeys("testuser");

        ExtentReportHelper.logInfo("Enter password", driver);
        WebElement password = driver.findElement(By.id("password"));
        password.sendKeys("password123");

        ExtentReportHelper.logInfo("Click login button", driver);
        driver.findElement(By.id("login")).click();

        // Verify
        boolean isLoggedIn = driver.getCurrentUrl().contains("dashboard");
        if (isLoggedIn) {
            ExtentReportHelper.logPass("Login successful");
        } else {
            ExtentReportHelper.logFail("Login failed", driver);
        }

        Assert.assertTrue(isLoggedIn, "User should be logged in");
    }

    @Test(description = "Test with table data logging")
    public void testWithTableData() {
        String[][] testData = {
            {"User", "Email", "Status"},
            {"John Doe", "john@example.com", "Active"},
            {"Jane Smith", "jane@example.com", "Inactive"}
        };

        ExtentReportHelper.logTable(testData);
        ExtentReportHelper.logPass("Table data logged successfully");
    }

    @Test(description = "Test with JSON response logging")
    public void testWithJsonLogging() {
        String jsonResponse = "{\n" +
            "  \"userId\": 1,\n" +
            "  \"username\": \"testuser\",\n" +
            "  \"email\": \"test@example.com\"\n" +
            "}";

        ExtentReportHelper.logJson(jsonResponse);
        ExtentReportHelper.logPass("JSON response logged");
    }

    @Test(description = "Test with nested steps")
    public void testWithNestedSteps() {
        ExtentTest loginNode = ExtentReportHelper.createNode("Login Flow");
        loginNode.info("Navigate to login page");
        loginNode.pass("Login page loaded");

        ExtentTest checkoutNode = ExtentReportHelper.createNode("Checkout Flow");
        checkoutNode.info("Add items to cart");
        checkoutNode.info("Proceed to checkout");
        checkoutNode.pass("Checkout completed");
    }
}

// 7. Test Examples with Allure Reports
public class AllureReportTests extends BaseTest {

    @Test(description = "Login test with Allure reporting")
    @Description("Verify user can login with valid credentials")
    @Severity(SeverityLevel.CRITICAL)
    @Story("User Authentication")
    @Feature("Login")
    public void testLoginWithAllure() {
        step("Navigate to login page", () -> {
            driver.get("https://example.com/login");
            AllureManager.attachScreenshot(driver);
        });

        step("Enter credentials", () -> {
            driver.findElement(By.id("username")).sendKeys("testuser");
            driver.findElement(By.id("password")).sendKeys("password123");
            AllureManager.attachScreenshot(driver);
        });

        step("Click login button", () -> {
            driver.findElement(By.id("login")).click();
            AllureManager.attachScreenshot(driver);
        });

        step("Verify login successful", () -> {
            Assert.assertTrue(driver.getCurrentUrl().contains("dashboard"));
        });
    }

    @Step("{description}")
    private void step(String description, Runnable action) {
        action.run();
    }

    @Test
    @Description("API response validation with Allure")
    public void testWithApiResponse() {
        String apiResponse = "{\"status\": \"success\", \"data\": []}";

        AllureManager.addParameter("API Endpoint", "/api/users");
        AllureManager.addParameter("Method", "GET");
        AllureManager.attachJson(apiResponse);

        AllureManager.logStep("API response received");
        Assert.assertTrue(apiResponse.contains("success"));
    }
}

// 8. Report Publisher Utility
public class ReportPublisher {

    // Copy report to shared location
    public static void publishReport(String reportPath, String destinationPath) {
        try {
            File source = new File(reportPath);
            File destination = new File(destinationPath);

            FileUtils.copyFile(source, destination);
            System.out.println("Report published to: " + destinationPath);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // Upload report to S3 (AWS)
    public static void uploadToS3(String reportPath, String bucketName, String key) {
        // AWS S3 upload implementation
        // Requires AWS SDK
        System.out.println("Uploading report to S3: " + bucketName + "/" + key);
    }

    // Send report via email
    public static void emailReport(String reportPath, String[] recipients) {
        System.out.println("Sending report to: " + String.join(", ", recipients));
        // Email sending implementation
    }

    // Generate Allure report
    public static void generateAllureReport(String resultsDir, String reportDir) {
        try {
            Process process = Runtime.getRuntime().exec(
                "allure generate " + resultsDir + " -o " + reportDir + " --clean");
            process.waitFor();
            System.out.println("Allure report generated: " + reportDir);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

**Follow-up**: How to integrate reports with Slack/Teams notifications? How to track test execution history across builds? What are best practices for report retention in CI/CD? How to create custom report templates?

---

### **Q95: How do you implement visual regression testing in Selenium?** (6-8 Years, 9-12 Years)
**Companies**: Google, Netflix, Adobe, Airbnb, Amazon, Microsoft
**Difficulty**: Hard

**Answer**: Visual regression testing detects unintended visual changes in UI by comparing screenshots against baseline images. It's critical for catching CSS issues, layout breaks, responsive design problems, and cross-browser rendering differences that functional tests miss. Implementation approaches include: pixel-by-pixel comparison, perceptual diff algorithms, and AI-based visual testing. Popular tools include Applitools Eyes (AI-powered), Percy (visual testing platform), BackstopJS, and open-source libraries like AShot and Sikuli. The process involves: capturing baseline screenshots, storing them in version control or cloud, capturing screenshots during test execution, comparing with baselines using diff algorithms, identifying and reviewing visual differences, and updating baselines when changes are intentional. Challenges include handling dynamic content (ads, dates), managing baseline images across environments, and dealing with anti-aliasing differences across browsers. Best practices include: ignoring dynamic regions, using visual AI for intelligent comparisons, maintaining separate baselines per resolution/browser, and integrating visual tests in CI/CD with approval workflows.

**Code Example**:

```java
// 1. Visual Testing Manager using AShot
import ru.yandex.qatools.ashot.AShot;
import ru.yandex.qatools.ashot.Screenshot;
import ru.yandex.qatools.ashot.comparison.ImageDiff;
import ru.yandex.qatools.ashot.comparison.ImageDiffer;
import ru.yandex.qatools.ashot.shooting.ShootingStrategies;
import ru.yandex.qatools.ashot.coordinates.WebDriverCoordsProvider;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.*;
import java.util.*;

public class VisualTestingManager {
    private WebDriver driver;
    private String baselineDir;
    private String actualDir;
    private String diffDir;
    private double diffThreshold;

    public VisualTestingManager(WebDriver driver, String baselineDir) {
        this.driver = driver;
        this.baselineDir = baselineDir;
        this.actualDir = baselineDir + "/actual/";
        this.diffDir = baselineDir + "/diff/";
        this.diffThreshold = 0.1; // 10% threshold

        createDirectories();
    }

    private void createDirectories() {
        new File(baselineDir).mkdirs();
        new File(actualDir).mkdirs();
        new File(diffDir).mkdirs();
    }

    // Capture baseline screenshot
    public void captureBaseline(String testName) throws IOException {
        Screenshot screenshot = new AShot()
            .shootingStrategy(ShootingStrategies.viewportPasting(1000))
            .takeScreenshot(driver);

        String baselinePath = baselineDir + "/" + testName + ".png";
        ImageIO.write(screenshot.getImage(), "PNG", new File(baselinePath));
        System.out.println("Baseline captured: " + baselinePath);
    }

    // Compare with baseline
    public VisualTestResult compareWithBaseline(String testName) throws IOException {
        // Capture current screenshot
        Screenshot currentScreenshot = new AShot()
            .shootingStrategy(ShootingStrategies.viewportPasting(1000))
            .takeScreenshot(driver);

        String actualPath = actualDir + testName + ".png";
        ImageIO.write(currentScreenshot.getImage(), "PNG", new File(actualPath));

        // Load baseline
        String baselinePath = baselineDir + "/" + testName + ".png";
        File baselineFile = new File(baselinePath);

        if (!baselineFile.exists()) {
            return new VisualTestResult(false,
                "Baseline not found. Creating new baseline.", 0, null);
        }

        BufferedImage baselineImage = ImageIO.read(baselineFile);
        BufferedImage actualImage = currentScreenshot.getImage();

        // Compare images
        ImageDiffer imageDiffer = new ImageDiffer();
        ImageDiff diff = imageDiffer.makeDiff(baselineImage, actualImage);

        // Save diff image
        if (diff.hasDiff()) {
            String diffPath = diffDir + testName + "_diff.png";
            ImageIO.write(diff.getMarkedImage(), "PNG", new File(diffPath));
        }

        // Calculate difference percentage
        double diffPercent = calculateDiffPercentage(diff);
        boolean passed = diffPercent <= diffThreshold;

        return new VisualTestResult(passed,
            "Visual comparison " + (passed ? "passed" : "failed"),
            diffPercent,
            diff.hasDiff() ? diffDir + testName + "_diff.png" : null);
    }

    // Compare element with baseline
    public VisualTestResult compareElementWithBaseline(WebElement element, String elementName)
            throws IOException {
        Screenshot elementScreenshot = new AShot()
            .coordsProvider(new WebDriverCoordsProvider())
            .takeScreenshot(driver, element);

        String actualPath = actualDir + elementName + ".png";
        ImageIO.write(elementScreenshot.getImage(), "PNG", new File(actualPath));

        String baselinePath = baselineDir + "/" + elementName + ".png";
        File baselineFile = new File(baselinePath);

        if (!baselineFile.exists()) {
            ImageIO.write(elementScreenshot.getImage(), "PNG", baselineFile);
            return new VisualTestResult(true,
                "Baseline created for element: " + elementName, 0, null);
        }

        BufferedImage baselineImage = ImageIO.read(baselineFile);
        BufferedImage actualImage = elementScreenshot.getImage();

        ImageDiffer imageDiffer = new ImageDiffer();
        ImageDiff diff = imageDiffer.makeDiff(baselineImage, actualImage);

        if (diff.hasDiff()) {
            String diffPath = diffDir + elementName + "_diff.png";
            ImageIO.write(diff.getMarkedImage(), "PNG", new File(diffPath));
        }

        double diffPercent = calculateDiffPercentage(diff);
        boolean passed = diffPercent <= diffThreshold;

        return new VisualTestResult(passed,
            "Element comparison " + (passed ? "passed" : "failed"),
            diffPercent,
            diff.hasDiff() ? diffDir + elementName + "_diff.png" : null);
    }

    // Compare with ignored regions
    public VisualTestResult compareWithIgnoredRegions(String testName,
            Set<IgnoreRegion> ignoreRegions) throws IOException {
        Screenshot currentScreenshot = new AShot()
            .shootingStrategy(ShootingStrategies.viewportPasting(1000))
            .ignoredAreas(convertToCoords(ignoreRegions))
            .takeScreenshot(driver);

        String actualPath = actualDir + testName + ".png";
        ImageIO.write(currentScreenshot.getImage(), "PNG", new File(actualPath));

        String baselinePath = baselineDir + "/" + testName + ".png";
        BufferedImage baselineImage = ImageIO.read(new File(baselinePath));
        BufferedImage actualImage = currentScreenshot.getImage();

        ImageDiffer imageDiffer = new ImageDiffer();
        ImageDiff diff = imageDiffer.makeDiff(baselineImage, actualImage);

        if (diff.hasDiff()) {
            String diffPath = diffDir + testName + "_diff.png";
            ImageIO.write(diff.getMarkedImage(), "PNG", new File(diffPath));
        }

        double diffPercent = calculateDiffPercentage(diff);
        boolean passed = diffPercent <= diffThreshold;

        return new VisualTestResult(passed,
            "Visual comparison with ignored regions " + (passed ? "passed" : "failed"),
            diffPercent,
            diff.hasDiff() ? diffDir + testName + "_diff.png" : null);
    }

    // Set difference threshold
    public void setDiffThreshold(double threshold) {
        this.diffThreshold = threshold;
    }

    // Calculate difference percentage
    private double calculateDiffPercentage(ImageDiff diff) {
        int totalPixels = diff.getMarkedImage().getWidth() *
                         diff.getMarkedImage().getHeight();
        int diffArea = diff.getDiffSize();
        return (double) diffArea / totalPixels * 100;
    }

    // Convert ignore regions to coordinates
    private Set<ru.yandex.qatools.ashot.coordinates.Coords> convertToCoords(
            Set<IgnoreRegion> ignoreRegions) {
        Set<ru.yandex.qatools.ashot.coordinates.Coords> coords = new HashSet<>();
        for (IgnoreRegion region : ignoreRegions) {
            coords.add(new ru.yandex.qatools.ashot.coordinates.Coords(
                region.getX(), region.getY(), region.getWidth(), region.getHeight()));
        }
        return coords;
    }

    // Result class
    public static class VisualTestResult {
        private boolean passed;
        private String message;
        private double diffPercentage;
        private String diffImagePath;

        public VisualTestResult(boolean passed, String message,
                              double diffPercentage, String diffImagePath) {
            this.passed = passed;
            this.message = message;
            this.diffPercentage = diffPercentage;
            this.diffImagePath = diffImagePath;
        }

        public boolean isPassed() { return passed; }
        public String getMessage() { return message; }
        public double getDiffPercentage() { return diffPercentage; }
        public String getDiffImagePath() { return diffImagePath; }
    }

    // Ignore region class
    public static class IgnoreRegion {
        private int x, y, width, height;

        public IgnoreRegion(int x, int y, int width, int height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        }

        public int getX() { return x; }
        public int getY() { return y; }
        public int getWidth() { return width; }
        public int getHeight() { return height; }
    }
}

// 2. Applitools Eyes Integration
import com.applitools.eyes.selenium.Eyes;
import com.applitools.eyes.selenium.StitchMode;
import com.applitools.eyes.selenium.Configuration;
import com.applitools.eyes.RectangleSize;

public class ApplitoolsManager {
    private Eyes eyes;
    private String apiKey;

    public ApplitoolsManager(String apiKey) {
        this.apiKey = apiKey;
        initializeEyes();
    }

    private void initializeEyes() {
        eyes = new Eyes();
        eyes.setApiKey(apiKey);

        // Configuration
        Configuration config = eyes.getConfiguration();
        config.setAppName("MyApplication");
        config.setTestName("Visual Regression Test");
        config.setViewportSize(new RectangleSize(1920, 1080));
        config.setStitchMode(StitchMode.CSS);
        eyes.setConfiguration(config);
    }

    // Open Eyes session
    public WebDriver open(WebDriver driver, String testName) {
        return eyes.open(driver, "MyApplication", testName,
            new RectangleSize(1920, 1080));
    }

    // Check window
    public void checkWindow(String checkpointName) {
        eyes.checkWindow(checkpointName);
    }

    // Check element
    public void checkElement(WebElement element, String checkpointName) {
        eyes.checkElement(element, checkpointName);
    }

    // Check region
    public void checkRegion(By selector, String checkpointName) {
        eyes.checkRegion(selector, checkpointName);
    }

    // Check with layout regions (ignore content, check layout only)
    public void checkWindowWithLayout(By... layoutRegions) {
        eyes.checkWindow();
        // Layout configuration can be added
    }

    // Close Eyes and get results
    public void close() {
        try {
            eyes.close(false);
        } catch (Exception e) {
            System.err.println("Eyes close failed: " + e.getMessage());
        }
    }

    // Abort if not closed
    public void abortIfNotClosed() {
        eyes.abortIfNotClosed();
    }
}

// 3. Percy Visual Testing Integration
public class PercyManager {
    private WebDriver driver;
    private String percyToken;

    public PercyManager(WebDriver driver, String percyToken) {
        this.driver = driver;
        this.percyToken = percyToken;
    }

    // Take Percy snapshot
    public void takeSnapshot(String snapshotName) {
        JavascriptExecutor js = (JavascriptExecutor) driver;
        js.executeScript("percy.snapshot(arguments[0]);", snapshotName);
        System.out.println("Percy snapshot taken: " + snapshotName);
    }

    // Take snapshot with options
    public void takeSnapshotWithOptions(String snapshotName, Map<String, Object> options) {
        JavascriptExecutor js = (JavascriptExecutor) driver;
        String optionsJson = new Gson().toJson(options);
        js.executeScript("percy.snapshot(arguments[0], " + optionsJson + ");", snapshotName);
    }

    // Take responsive snapshot
    public void takeResponsiveSnapshot(String snapshotName, int[] widths) {
        Map<String, Object> options = new HashMap<>();
        options.put("widths", widths);
        takeSnapshotWithOptions(snapshotName, options);
    }
}

// 4. Visual Test Base Class
public class VisualTestBase extends BaseTest {
    protected VisualTestingManager visualTesting;
    protected ApplitoolsManager applitools;
    protected boolean useApplitools = false;

    @BeforeMethod
    public void setUpVisualTesting() {
        String baselineDir = System.getProperty("user.dir") + "/visual-baselines";
        visualTesting = new VisualTestingManager(driver, baselineDir);

        // Initialize Applitools if API key is provided
        String applitoolsKey = System.getProperty("applitools.api.key");
        if (applitoolsKey != null && !applitoolsKey.isEmpty()) {
            applitools = new ApplitoolsManager(applitoolsKey);
            useApplitools = true;
        }
    }

    @AfterMethod
    public void tearDownVisualTesting() {
        if (useApplitools && applitools != null) {
            applitools.close();
        }
    }

    // Helper method for visual assertion
    protected void assertVisualMatch(String testName) throws IOException {
        VisualTestingManager.VisualTestResult result =
            visualTesting.compareWithBaseline(testName);

        if (!result.isPassed()) {
            String errorMessage = String.format(
                "Visual regression detected! Diff: %.2f%%. Diff image: %s",
                result.getDiffPercentage(),
                result.getDiffImagePath()
            );
            Assert.fail(errorMessage);
        }
    }

    // Helper for element visual assertion
    protected void assertElementVisualMatch(WebElement element, String elementName)
            throws IOException {
        VisualTestingManager.VisualTestResult result =
            visualTesting.compareElementWithBaseline(element, elementName);

        if (!result.isPassed()) {
            Assert.fail(String.format(
                "Element visual regression detected! Diff: %.2f%%",
                result.getDiffPercentage()
            ));
        }
    }
}

// 5. Test Examples
public class VisualRegressionTests extends VisualTestBase {

    @Test(description = "Homepage visual regression test")
    public void testHomepageVisuals() throws IOException {
        driver.get("https://example.com");

        // Wait for page load
        new WebDriverWait(driver, Duration.ofSeconds(10))
            .until(d -> ((JavascriptExecutor) d)
                .executeScript("return document.readyState").equals("complete"));

        // Visual assertion
        assertVisualMatch("homepage");
    }

    @Test(description = "Login form visual test")
    public void testLoginFormVisuals() throws IOException {
        driver.get("https://example.com/login");

        WebElement loginForm = driver.findElement(By.id("login-form"));
        assertElementVisualMatch(loginForm, "login_form");
    }

    @Test(description = "Test with ignored dynamic regions")
    public void testWithIgnoredRegions() throws IOException {
        driver.get("https://example.com");

        // Define regions to ignore (ads, dates, etc.)
        Set<VisualTestingManager.IgnoreRegion> ignoreRegions = new HashSet<>();
        ignoreRegions.add(new VisualTestingManager.IgnoreRegion(0, 0, 300, 100)); // Header ad
        ignoreRegions.add(new VisualTestingManager.IgnoreRegion(800, 500, 200, 50)); // Date

        VisualTestingManager.VisualTestResult result =
            visualTesting.compareWithIgnoredRegions("homepage_ignored", ignoreRegions);

        Assert.assertTrue(result.isPassed(),
            "Visual test failed with diff: " + result.getDiffPercentage());
    }

    @Test(description = "Cross-browser visual test")
    public void testCrossBrowserVisuals() throws IOException {
        driver.get("https://example.com");

        String browserName = ((RemoteWebDriver) driver).getCapabilities()
            .getBrowserName().toLowerCase();
        String testName = "homepage_" + browserName;

        assertVisualMatch(testName);
    }

    @Test(description = "Responsive design visual test")
    public void testResponsiveVisuals() throws IOException {
        int[] viewportWidths = {375, 768, 1024, 1920};

        for (int width : viewportWidths) {
            driver.manage().window().setSize(new Dimension(width, 1080));
            driver.get("https://example.com");

            Thread.sleep(1000); // Wait for layout adjustment

            String testName = "homepage_" + width + "px";
            assertVisualMatch(testName);
        }
    }

    @Test(description = "Visual test with Applitools")
    public void testWithApplitools() {
        if (!useApplitools) {
            throw new SkipException("Applitools not configured");
        }

        driver = applitools.open(driver, "Homepage Visual Test");

        driver.get("https://example.com");
        applitools.checkWindow("Homepage");

        driver.findElement(By.id("login-link")).click();
        applitools.checkWindow("Login Page");

        applitools.close();
    }

    @Test(description = "Create baseline if not exists")
    public void createBaseline() throws IOException {
        driver.get("https://example.com");

        visualTesting.captureBaseline("homepage_baseline");
        System.out.println("Baseline created successfully");
    }
}

// 6. Visual Testing Report
public class VisualTestReport {
    private List<VisualTestingManager.VisualTestResult> results;
    private String reportPath;

    public VisualTestReport(String reportPath) {
        this.results = new ArrayList<>();
        this.reportPath = reportPath;
    }

    public void addResult(String testName, VisualTestingManager.VisualTestResult result) {
        results.add(result);
    }

    public void generateReport() throws IOException {
        StringBuilder html = new StringBuilder();
        html.append("<html><head><title>Visual Testing Report</title>");
        html.append("<style>");
        html.append("body { font-family: Arial; margin: 20px; }");
        html.append(".test { border: 1px solid #ccc; margin: 10px 0; padding: 10px; }");
        html.append(".passed { background-color: #d4edda; }");
        html.append(".failed { background-color: #f8d7da; }");
        html.append("img { max-width: 100%; }");
        html.append("</style></head><body>");
        html.append("<h1>Visual Regression Test Report</h1>");

        int passed = 0, failed = 0;
        for (VisualTestingManager.VisualTestResult result : results) {
            if (result.isPassed()) passed++; else failed++;

            html.append(String.format(
                "<div class='test %s'><h3>%s</h3><p>Difference: %.2f%%</p>",
                result.isPassed() ? "passed" : "failed",
                result.getMessage(),
                result.getDiffPercentage()
            ));

            if (result.getDiffImagePath() != null) {
                html.append(String.format(
                    "<img src='%s' alt='Diff Image'>",
                    result.getDiffImagePath()
                ));
            }

            html.append("</div>");
        }

        html.append(String.format(
            "<h2>Summary: %d passed, %d failed</h2>",
            passed, failed
        ));
        html.append("</body></html>");

        FileWriter writer = new FileWriter(reportPath);
        writer.write(html.toString());
        writer.close();

        System.out.println("Visual test report generated: " + reportPath);
    }
}
```

**Follow-up**: How to handle dynamic content in visual tests? How to optimize baseline storage for CI/CD? What are best practices for reviewing and approving visual changes? How to integrate visual testing with existing test frameworks?

---

### **Q96: How do you implement accessibility testing in Selenium?** (6-8 Years, 9-12 Years)
**Companies**: Google, Microsoft, Amazon, Adobe, Airbnb, Salesforce
**Difficulty**: Hard

**Answer**: Accessibility testing ensures web applications are usable by people with disabilities, complying with WCAG (Web Content Accessibility Guidelines) and Section 508 standards. Selenium can be integrated with accessibility testing libraries like Axe-core, Pa11y, and Deque aXe for automated accessibility audits. Key areas tested include: keyboard navigation, screen reader compatibility, color contrast ratios, ARIA attributes, form labels, heading hierarchy, alt text for images, and focus management. Implementation involves: injecting accessibility testing scripts into pages, running audits, parsing violation reports, and failing tests for critical issues. Axe-core is the most popular library, providing comprehensive WCAG 2.1 Level A/AA/AAA checks. Best practices include: running accessibility scans on every page, integrating with CI/CD pipelines, categorizing violations by severity (critical, serious, moderate, minor), creating detailed reports with remediation guidance, and combining automated tests with manual testing for complete coverage. Accessibility should be tested across different user flows, forms, modals, and interactive components.

**Code Example**:

```java
// 1. Axe-core Accessibility Manager
import com.deque.html.axecore.results.*;
import com.deque.html.axecore.selenium.AxeBuilder;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.*;
import java.util.*;
import java.util.stream.Collectors;

public class AccessibilityManager {
    private WebDriver driver;
    private String reportDirectory;
    private List<AccessibilityViolation> allViolations;

    public AccessibilityManager(WebDriver driver, String reportDirectory) {
        this.driver = driver;
        this.reportDirectory = reportDirectory;
        this.allViolations = new ArrayList<>();
        createReportDirectory();
    }

    private void createReportDirectory() {
        new File(reportDirectory).mkdirs();
    }

    // Run accessibility scan
    public AccessibilityScanResult runAccessibilityScan() {
        AxeBuilder axeBuilder = new AxeBuilder();
        Results results = axeBuilder.analyze(driver);

        AccessibilityScanResult scanResult = new AccessibilityScanResult();
        scanResult.setUrl(driver.getCurrentUrl());
        scanResult.setTimestamp(new Date());
        scanResult.setViolationCount(results.getViolations().size());
        scanResult.setPassCount(results.getPasses().size());
        scanResult.setIncompleteCount(results.getIncomplete().size());

        // Process violations
        for (Rule violation : results.getViolations()) {
            AccessibilityViolation av = new AccessibilityViolation(
                violation.getId(),
                violation.getDescription(),
                violation.getImpact(),
                violation.getHelp(),
                violation.getHelpUrl(),
                violation.getNodes().size()
            );

            scanResult.addViolation(av);
            allViolations.add(av);
        }

        return scanResult;
    }

    // Run scan with specific rules
    public AccessibilityScanResult runScanWithRules(List<String> rulesToRun) {
        AxeBuilder axeBuilder = new AxeBuilder()
            .withRules(rulesToRun);

        Results results = axeBuilder.analyze(driver);
        return processResults(results);
    }

    // Run scan excluding specific rules
    public AccessibilityScanResult runScanExcludingRules(List<String> rulesToDisable) {
        AxeBuilder axeBuilder = new AxeBuilder()
            .disableRules(rulesToDisable);

        Results results = axeBuilder.analyze(driver);
        return processResults(results);
    }

    // Run scan for specific WCAG level
    public AccessibilityScanResult runScanForWCAGLevel(String level) {
        // level: "wcag2a", "wcag2aa", "wcag2aaa", "wcag21a", "wcag21aa"
        AxeBuilder axeBuilder = new AxeBuilder()
            .withTags(Arrays.asList(level));

        Results results = axeBuilder.analyze(driver);
        return processResults(results);
    }

    // Scan specific element
    public AccessibilityScanResult scanElement(WebElement element) {
        AxeBuilder axeBuilder = new AxeBuilder()
            .include(Arrays.asList(getCssSelector(element)));

        Results results = axeBuilder.analyze(driver);
        return processResults(results);
    }

    // Get violations by severity
    public List<AccessibilityViolation> getViolationsBySeverity(String severity) {
        return allViolations.stream()
            .filter(v -> v.getImpact().equalsIgnoreCase(severity))
            .collect(Collectors.toList());
    }

    // Get critical violations
    public List<AccessibilityViolation> getCriticalViolations() {
        return getViolationsBySeverity("critical");
    }

    // Get serious violations
    public List<AccessibilityViolation> getSeriousViolations() {
        return getViolationsBySeverity("serious");
    }

    // Assert no critical violations
    public void assertNoCriticalViolations() {
        List<AccessibilityViolation> criticalViolations = getCriticalViolations();
        if (!criticalViolations.isEmpty()) {
            throw new AssertionError(
                String.format("Found %d critical accessibility violations:\n%s",
                    criticalViolations.size(),
                    formatViolations(criticalViolations)
                )
            );
        }
    }

    // Assert no violations above threshold
    public void assertViolationCountBelow(int threshold) {
        if (allViolations.size() > threshold) {
            throw new AssertionError(
                String.format("Accessibility violations (%d) exceed threshold (%d)",
                    allViolations.size(), threshold)
            );
        }
    }

    // Generate JSON report
    public void generateJsonReport(String fileName) throws IOException {
        String reportPath = reportDirectory + "/" + fileName;
        ObjectMapper mapper = new ObjectMapper();
        mapper.writerWithDefaultPrettyPrinter()
            .writeValue(new File(reportPath), allViolations);
        System.out.println("Accessibility JSON report generated: " + reportPath);
    }

    // Generate HTML report
    public void generateHtmlReport(String fileName) throws IOException {
        String reportPath = reportDirectory + "/" + fileName;
        StringBuilder html = new StringBuilder();

        html.append("<!DOCTYPE html><html><head>");
        html.append("<title>Accessibility Test Report</title>");
        html.append("<style>");
        html.append("body { font-family: Arial, sans-serif; margin: 20px; }");
        html.append("h1 { color: #333; }");
        html.append(".violation { border: 1px solid #ddd; margin: 10px 0; padding: 15px; }");
        html.append(".critical { border-left: 5px solid #d32f2f; }");
        html.append(".serious { border-left: 5px solid #f57c00; }");
        html.append(".moderate { border-left: 5px solid #fbc02d; }");
        html.append(".minor { border-left: 5px solid #7cb342; }");
        html.append(".impact { font-weight: bold; text-transform: uppercase; }");
        html.append("</style></head><body>");

        html.append("<h1>Accessibility Test Report</h1>");
        html.append(String.format("<p>Total Violations: %d</p>", allViolations.size()));
        html.append(String.format("<p>Critical: %d</p>", getCriticalViolations().size()));
        html.append(String.format("<p>Serious: %d</p>", getSeriousViolations().size()));

        for (AccessibilityViolation violation : allViolations) {
            html.append(String.format(
                "<div class='violation %s'>" +
                "<h3>%s</h3>" +
                "<p class='impact'>Impact: %s</p>" +
                "<p>%s</p>" +
                "<p><a href='%s' target='_blank'>Learn more</a></p>" +
                "<p>Affected elements: %d</p>" +
                "</div>",
                violation.getImpact().toLowerCase(),
                violation.getRuleId(),
                violation.getImpact(),
                violation.getDescription(),
                violation.getHelpUrl(),
                violation.getNodeCount()
            ));
        }

        html.append("</body></html>");

        FileWriter writer = new FileWriter(reportPath);
        writer.write(html.toString());
        writer.close();

        System.out.println("Accessibility HTML report generated: " + reportPath);
    }

    // Helper methods
    private AccessibilityScanResult processResults(Results results) {
        AccessibilityScanResult scanResult = new AccessibilityScanResult();
        scanResult.setUrl(driver.getCurrentUrl());
        scanResult.setTimestamp(new Date());
        scanResult.setViolationCount(results.getViolations().size());

        for (Rule violation : results.getViolations()) {
            AccessibilityViolation av = new AccessibilityViolation(
                violation.getId(),
                violation.getDescription(),
                violation.getImpact(),
                violation.getHelp(),
                violation.getHelpUrl(),
                violation.getNodes().size()
            );
            scanResult.addViolation(av);
            allViolations.add(av);
        }

        return scanResult;
    }

    private String formatViolations(List<AccessibilityViolation> violations) {
        return violations.stream()
            .map(v -> String.format("- [%s] %s (%d elements)",
                v.getImpact(), v.getRuleId(), v.getNodeCount()))
            .collect(Collectors.joining("\n"));
    }

    private String getCssSelector(WebElement element) {
        JavascriptExecutor js = (JavascriptExecutor) driver;
        return (String) js.executeScript(
            "function getPathTo(element) {" +
            "  if (element.id!=='')" +
            "    return 'id(\"'+element.id+'\")';" +
            "  if (element===document.body)" +
            "    return element.tagName;" +
            "  var ix= 0;" +
            "  var siblings= element.parentNode.childNodes;" +
            "  for (var i= 0; i<siblings.length; i++) {" +
            "    var sibling= siblings[i];" +
            "    if (sibling===element)" +
            "      return getPathTo(element.parentNode)+'>'+element.tagName.toLowerCase()+'['+(ix+1)+']';" +
            "    if (sibling.nodeType===1 && sibling.tagName===element.tagName)" +
            "      ix++;" +
            "  }" +
            "}" +
            "return getPathTo(arguments[0]);",
            element
        );
    }

    // Data classes
    public static class AccessibilityScanResult {
        private String url;
        private Date timestamp;
        private int violationCount;
        private int passCount;
        private int incompleteCount;
        private List<AccessibilityViolation> violations = new ArrayList<>();

        // Getters and setters
        public String getUrl() { return url; }
        public void setUrl(String url) { this.url = url; }
        public Date getTimestamp() { return timestamp; }
        public void setTimestamp(Date timestamp) { this.timestamp = timestamp; }
        public int getViolationCount() { return violationCount; }
        public void setViolationCount(int count) { this.violationCount = count; }
        public int getPassCount() { return passCount; }
        public void setPassCount(int count) { this.passCount = count; }
        public int getIncompleteCount() { return incompleteCount; }
        public void setIncompleteCount(int count) { this.incompleteCount = count; }
        public List<AccessibilityViolation> getViolations() { return violations; }
        public void addViolation(AccessibilityViolation violation) {
            violations.add(violation);
        }
    }

    public static class AccessibilityViolation {
        private String ruleId;
        private String description;
        private String impact;
        private String help;
        private String helpUrl;
        private int nodeCount;

        public AccessibilityViolation(String ruleId, String description, String impact,
                                    String help, String helpUrl, int nodeCount) {
            this.ruleId = ruleId;
            this.description = description;
            this.impact = impact;
            this.help = help;
            this.helpUrl = helpUrl;
            this.nodeCount = nodeCount;
        }

        // Getters
        public String getRuleId() { return ruleId; }
        public String getDescription() { return description; }
        public String getImpact() { return impact; }
        public String getHelp() { return help; }
        public String getHelpUrl() { return helpUrl; }
        public int getNodeCount() { return nodeCount; }
    }
}

// 2. Accessibility Test Helper
public class AccessibilityTestHelper {

    // Test keyboard navigation
    public static boolean testKeyboardNavigation(WebDriver driver, WebElement startElement) {
        try {
            startElement.sendKeys(Keys.TAB);
            Thread.sleep(500);

            WebElement focusedElement = (WebElement) ((JavascriptExecutor) driver)
                .executeScript("return document.activeElement;");

            return !focusedElement.equals(startElement);
        } catch (Exception e) {
            return false;
        }
    }

    // Verify ARIA labels
    public static boolean hasAriaLabel(WebElement element) {
        String ariaLabel = element.getAttribute("aria-label");
        String ariaLabelledBy = element.getAttribute("aria-labelledby");
        return (ariaLabel != null && !ariaLabel.isEmpty()) ||
               (ariaLabelledBy != null && !ariaLabelledBy.isEmpty());
    }

    // Check color contrast
    public static double getColorContrast(String foreground, String background) {
        // Simplified contrast calculation
        // In production, use a proper color contrast library
        return 4.5; // Placeholder
    }

    // Verify form labels
    public static boolean hasValidLabel(WebElement inputElement) {
        String id = inputElement.getAttribute("id");
        String ariaLabel = inputElement.getAttribute("aria-label");

        if (ariaLabel != null && !ariaLabel.isEmpty()) {
            return true;
        }

        if (id != null && !id.isEmpty()) {
            try {
                WebElement label = inputElement.findElement(
                    By.xpath("//label[@for='" + id + "']"));
                return label != null;
            } catch (NoSuchElementException e) {
                return false;
            }
        }

        return false;
    }

    // Check heading hierarchy
    public static List<String> getHeadingHierarchy(WebDriver driver) {
        List<WebElement> headings = driver.findElements(
            By.cssSelector("h1, h2, h3, h4, h5, h6"));

        return headings.stream()
            .map(h -> h.getTagName() + ": " + h.getText())
            .collect(Collectors.toList());
    }
}

// 3. Accessibility Test Base
public class AccessibilityTestBase extends BaseTest {
    protected AccessibilityManager accessibilityManager;

    @BeforeMethod
    public void setUpAccessibility() {
        String reportDir = System.getProperty("user.dir") + "/accessibility-reports";
        accessibilityManager = new AccessibilityManager(driver, reportDir);
    }

    @AfterMethod
    public void generateAccessibilityReport() throws IOException {
        String timestamp = new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss").format(new Date());
        accessibilityManager.generateHtmlReport("accessibility_report_" + timestamp + ".html");
        accessibilityManager.generateJsonReport("accessibility_report_" + timestamp + ".json");
    }

    // Helper method for accessibility scan
    protected void scanPageForAccessibility() {
        AccessibilityManager.AccessibilityScanResult result =
            accessibilityManager.runAccessibilityScan();

        System.out.println(String.format(
            "Accessibility scan completed: %d violations found",
            result.getViolationCount()
        ));

        accessibilityManager.assertNoCriticalViolations();
    }
}

// 4. Test Examples
public class AccessibilityTests extends AccessibilityTestBase {

    @Test(description = "Homepage accessibility scan")
    public void testHomepageAccessibility() {
        driver.get("https://example.com");

        AccessibilityManager.AccessibilityScanResult result =
            accessibilityManager.runAccessibilityScan();

        System.out.println("Violations: " + result.getViolationCount());
        System.out.println("Passes: " + result.getPassCount());

        // Assert no critical violations
        accessibilityManager.assertNoCriticalViolations();

        // Assert total violations below threshold
        accessibilityManager.assertViolationCountBelow(10);
    }

    @Test(description = "WCAG 2.1 AA compliance test")
    public void testWCAG21AACompliance() {
        driver.get("https://example.com");

        AccessibilityManager.AccessibilityScanResult result =
            accessibilityManager.runScanForWCAGLevel("wcag21aa");

        Assert.assertEquals(result.getViolationCount(), 0,
            "WCAG 2.1 AA violations found");
    }

    @Test(description = "Form accessibility test")
    public void testFormAccessibility() {
        driver.get("https://example.com/form");

        WebElement formElement = driver.findElement(By.id("contact-form"));
        AccessibilityManager.AccessibilityScanResult result =
            accessibilityManager.scanElement(formElement);

        List<AccessibilityManager.AccessibilityViolation> violations =
            result.getViolations();

        for (AccessibilityManager.AccessibilityViolation violation : violations) {
            System.out.println(String.format("[%s] %s - %s",
                violation.getImpact(),
                violation.getRuleId(),
                violation.getDescription()));
        }

        Assert.assertTrue(violations.isEmpty(), "Form has accessibility violations");
    }

    @Test(description = "Keyboard navigation test")
    public void testKeyboardNavigation() {
        driver.get("https://example.com");

        WebElement firstLink = driver.findElement(By.tagName("a"));
        boolean canNavigate = AccessibilityTestHelper.testKeyboardNavigation(
            driver, firstLink);

        Assert.assertTrue(canNavigate, "Keyboard navigation should work");
    }

    @Test(description = "ARIA labels test")
    public void testAriaLabels() {
        driver.get("https://example.com/form");

        List<WebElement> buttons = driver.findElements(By.tagName("button"));

        for (WebElement button : buttons) {
            Assert.assertTrue(
                AccessibilityTestHelper.hasAriaLabel(button),
                "Button should have ARIA label: " + button.getText()
            );
        }
    }

    @Test(description = "Form labels test")
    public void testFormLabels() {
        driver.get("https://example.com/form");

        List<WebElement> inputs = driver.findElements(
            By.cssSelector("input[type='text'], input[type='email'], textarea"));

        for (WebElement input : inputs) {
            Assert.assertTrue(
                AccessibilityTestHelper.hasValidLabel(input),
                "Input should have valid label: " + input.getAttribute("name")
            );
        }
    }

    @Test(description = "Heading hierarchy test")
    public void testHeadingHierarchy() {
        driver.get("https://example.com");

        List<String> headings = AccessibilityTestHelper.getHeadingHierarchy(driver);

        System.out.println("Heading hierarchy:");
        headings.forEach(System.out::println);

        // Verify H1 exists
        Assert.assertTrue(
            headings.stream().anyMatch(h -> h.startsWith("h1")),
            "Page should have at least one H1"
        );
    }

    @Test(description = "Scan with specific rules")
    public void testSpecificAccessibilityRules() {
        driver.get("https://example.com");

        List<String> rulesToTest = Arrays.asList(
            "color-contrast",
            "image-alt",
            "label",
            "button-name"
        );

        AccessibilityManager.AccessibilityScanResult result =
            accessibilityManager.runScanWithRules(rulesToTest);

        Assert.assertTrue(result.getViolations().isEmpty(),
            "Specific rule violations found");
    }
}
```

**Follow-up**: How to test screen reader compatibility? How to integrate accessibility testing in CI/CD? What manual accessibility tests should supplement automated tests? How to create an accessibility testing strategy for an organization?

---

### **Q97. How do you implement Email and SMS testing automation in your Selenium framework? Explain IMAP/SMTP integration, OTP verification, and message validation strategies.** (6-8 Years, 9-12 Years)

**Difficulty**: Hard
**Companies**: Amazon, Google, Microsoft, Flipkart, Paytm, PhonePe, Razorpay, Uber
**Topics**: Email Testing, SMS Validation, OTP Automation, Integration Testing

**Answer**:

Email and SMS testing is crucial for validating user registration flows, password resets, notifications, and OTP-based authentication. Modern frameworks integrate email validation using JavaMail API (IMAP/POP3) and SMS testing using APIs like Twilio or custom SMS gateway integrations.

**Key Implementation Areas:**

1. **Email Testing with JavaMail API**
   - Connect to IMAP/POP3 servers to read emails
   - Parse email content (HTML/plain text)
   - Extract verification links and OTPs
   - Validate email headers, attachments, and content
   - Support for multiple email providers (Gmail, Outlook, etc.)

2. **SMS Testing Integration**
   - Twilio API integration for SMS retrieval
   - Virtual phone number management
   - OTP extraction from SMS messages
   - SMS content validation
   - Handling SMS delivery delays

3. **OTP Verification Flows**
   - Automated OTP extraction from email/SMS
   - Dynamic OTP input in test flows
   - Timeout and retry mechanisms
   - Multi-channel OTP support (email + SMS fallback)

**Complete Implementation:**

```java
// pom.xml dependencies
/*
<dependencies>
    <!-- JavaMail API for Email Testing -->
    <dependency>
        <groupId>com.sun.mail</groupId>
        <artifactId>javax.mail</artifactId>
        <version>1.6.2</version>
    </dependency>

    <!-- Twilio for SMS Testing -->
    <dependency>
        <groupId>com.twilio.sdk</groupId>
        <artifactId>twilio</artifactId>
        <version>9.2.0</version>
    </dependency>

    <!-- JSoup for HTML Email Parsing -->
    <dependency>
        <groupId>org.jsoup</groupId>
        <artifactId>jsoup</artifactId>
        <version>1.15.3</version>
    </dependency>
</dependencies>
*/

// Email Configuration Class
public class EmailConfig {
    private String host;
    private String port;
    private String protocol;
    private String username;
    private String password;
    private boolean enableSSL;
    private boolean enableTLS;

    public static EmailConfig gmailIMAP(String email, String password) {
        EmailConfig config = new EmailConfig();
        config.host = "imap.gmail.com";
        config.port = "993";
        config.protocol = "imaps";
        config.username = email;
        config.password = password;
        config.enableSSL = true;
        config.enableTLS = false;
        return config;
    }

    public static EmailConfig outlookIMAP(String email, String password) {
        EmailConfig config = new EmailConfig();
        config.host = "outlook.office365.com";
        config.port = "993";
        config.protocol = "imaps";
        config.username = email;
        config.password = password;
        config.enableSSL = true;
        config.enableTLS = false;
        return config;
    }

    public static EmailConfig customIMAP(String host, String port,
            String email, String password) {
        EmailConfig config = new EmailConfig();
        config.host = host;
        config.port = port;
        config.protocol = "imaps";
        config.username = email;
        config.password = password;
        config.enableSSL = true;
        config.enableTLS = false;
        return config;
    }

    public Properties toProperties() {
        Properties props = new Properties();
        props.put("mail.store.protocol", protocol);
        props.put("mail." + protocol + ".host", host);
        props.put("mail." + protocol + ".port", port);
        props.put("mail." + protocol + ".ssl.enable", String.valueOf(enableSSL));
        props.put("mail." + protocol + ".starttls.enable", String.valueOf(enableTLS));
        props.put("mail." + protocol + ".ssl.trust", "*");
        return props;
    }

    // Getters and setters
    public String getUsername() { return username; }
    public String getPassword() { return password; }
    public String getProtocol() { return protocol; }
}

// Email Message Model
public class EmailMessage {
    private String messageId;
    private String from;
    private String to;
    private String subject;
    private String textContent;
    private String htmlContent;
    private Date receivedDate;
    private Date sentDate;
    private List<String> attachmentNames;
    private Map<String, String> headers;

    public EmailMessage() {
        attachmentNames = new ArrayList<>();
        headers = new HashMap<>();
    }

    // Getters and setters
    public String getMessageId() { return messageId; }
    public void setMessageId(String messageId) { this.messageId = messageId; }

    public String getFrom() { return from; }
    public void setFrom(String from) { this.from = from; }

    public String getTo() { return to; }
    public void setTo(String to) { this.to = to; }

    public String getSubject() { return subject; }
    public void setSubject(String subject) { this.subject = subject; }

    public String getTextContent() { return textContent; }
    public void setTextContent(String textContent) { this.textContent = textContent; }

    public String getHtmlContent() { return htmlContent; }
    public void setHtmlContent(String htmlContent) { this.htmlContent = htmlContent; }

    public Date getReceivedDate() { return receivedDate; }
    public void setReceivedDate(Date receivedDate) { this.receivedDate = receivedDate; }

    public Date getSentDate() { return sentDate; }
    public void setSentDate(Date sentDate) { this.sentDate = sentDate; }

    public List<String> getAttachmentNames() { return attachmentNames; }
    public void addAttachmentName(String name) { this.attachmentNames.add(name); }

    public Map<String, String> getHeaders() { return headers; }
    public void addHeader(String key, String value) { this.headers.put(key, value); }

    @Override
    public String toString() {
        return String.format("EmailMessage{from='%s', subject='%s', receivedDate=%s}",
            from, subject, receivedDate);
    }
}

// Email Manager - Core Email Testing Utility
public class EmailManager {
    private static final Logger logger = LoggerFactory.getLogger(EmailManager.class);
    private EmailConfig config;
    private Store store;
    private Folder inbox;

    public EmailManager(EmailConfig config) {
        this.config = config;
    }

    /**
     * Connect to email server
     */
    public void connect() throws MessagingException {
        try {
            Session session = Session.getInstance(config.toProperties());
            store = session.getStore(config.getProtocol());
            store.connect(config.getUsername(), config.getPassword());
            inbox = store.getFolder("INBOX");
            inbox.open(Folder.READ_WRITE);
            logger.info("Successfully connected to email server");
        } catch (MessagingException e) {
            logger.error("Failed to connect to email server", e);
            throw e;
        }
    }

    /**
     * Disconnect from email server
     */
    public void disconnect() {
        try {
            if (inbox != null && inbox.isOpen()) {
                inbox.close(false);
            }
            if (store != null && store.isConnected()) {
                store.close();
            }
            logger.info("Disconnected from email server");
        } catch (MessagingException e) {
            logger.error("Error disconnecting from email server", e);
        }
    }

    /**
     * Get all unread emails
     */
    public List<EmailMessage> getUnreadEmails() throws MessagingException {
        Message[] messages = inbox.search(new FlagTerm(new Flags(Flags.Flag.SEEN), false));
        return convertToEmailMessages(messages);
    }

    /**
     * Get emails by subject (partial match)
     */
    public List<EmailMessage> getEmailsBySubject(String subjectContains)
            throws MessagingException {
        SearchTerm subjectTerm = new SubjectTerm(subjectContains);
        Message[] messages = inbox.search(subjectTerm);
        return convertToEmailMessages(messages);
    }

    /**
     * Get emails from specific sender
     */
    public List<EmailMessage> getEmailsFromSender(String senderEmail)
            throws MessagingException {
        SearchTerm fromTerm = new FromStringTerm(senderEmail);
        Message[] messages = inbox.search(fromTerm);
        return convertToEmailMessages(messages);
    }

    /**
     * Get emails received after specific date
     */
    public List<EmailMessage> getEmailsReceivedAfter(Date date)
            throws MessagingException {
        SearchTerm dateTerm = new ReceivedDateTerm(ComparisonTerm.GT, date);
        Message[] messages = inbox.search(dateTerm);
        return convertToEmailMessages(messages);
    }

    /**
     * Get latest email matching criteria with retry mechanism
     */
    public EmailMessage getLatestEmail(String subjectContains, String fromEmail,
            int maxWaitSeconds) throws MessagingException, InterruptedException {
        long startTime = System.currentTimeMillis();
        long timeoutMillis = maxWaitSeconds * 1000;

        while (System.currentTimeMillis() - startTime < timeoutMillis) {
            // Refresh folder to get new messages
            if (inbox.isOpen()) {
                inbox.close(false);
            }
            inbox.open(Folder.READ_WRITE);

            // Build search criteria
            List<SearchTerm> terms = new ArrayList<>();
            if (subjectContains != null && !subjectContains.isEmpty()) {
                terms.add(new SubjectTerm(subjectContains));
            }
            if (fromEmail != null && !fromEmail.isEmpty()) {
                terms.add(new FromStringTerm(fromEmail));
            }

            SearchTerm searchTerm = null;
            if (terms.size() == 1) {
                searchTerm = terms.get(0);
            } else if (terms.size() > 1) {
                searchTerm = new AndTerm(terms.toArray(new SearchTerm[0]));
            }

            Message[] messages;
            if (searchTerm != null) {
                messages = inbox.search(searchTerm);
            } else {
                messages = inbox.getMessages();
            }

            if (messages.length > 0) {
                // Sort by received date descending
                Arrays.sort(messages, (m1, m2) -> {
                    try {
                        return m2.getReceivedDate().compareTo(m1.getReceivedDate());
                    } catch (MessagingException e) {
                        return 0;
                    }
                });

                EmailMessage emailMessage = convertToEmailMessage(messages[0]);
                logger.info("Found email: {}", emailMessage);
                return emailMessage;
            }

            logger.info("Email not found yet, waiting... ({}s elapsed)",
                (System.currentTimeMillis() - startTime) / 1000);
            Thread.sleep(2000); // Wait 2 seconds before retry
        }

        throw new AssertionError(String.format(
            "Email not received within %d seconds. Subject: '%s', From: '%s'",
            maxWaitSeconds, subjectContains, fromEmail));
    }

    /**
     * Delete email by message ID
     */
    public void deleteEmail(String messageId) throws MessagingException {
        Message[] messages = inbox.getMessages();
        for (Message message : messages) {
            String[] msgIds = message.getHeader("Message-ID");
            if (msgIds != null && msgIds.length > 0 && msgIds[0].equals(messageId)) {
                message.setFlag(Flags.Flag.DELETED, true);
                logger.info("Deleted email with ID: {}", messageId);
                break;
            }
        }
        inbox.expunge(); // Permanently delete marked messages
    }

    /**
     * Mark email as read
     */
    public void markAsRead(String messageId) throws MessagingException {
        Message[] messages = inbox.getMessages();
        for (Message message : messages) {
            String[] msgIds = message.getHeader("Message-ID");
            if (msgIds != null && msgIds.length > 0 && msgIds[0].equals(messageId)) {
                message.setFlag(Flags.Flag.SEEN, true);
                logger.info("Marked email as read: {}", messageId);
                break;
            }
        }
    }

    /**
     * Convert JavaMail Messages to EmailMessage objects
     */
    private List<EmailMessage> convertToEmailMessages(Message[] messages)
            throws MessagingException {
        List<EmailMessage> emailMessages = new ArrayList<>();
        for (Message message : messages) {
            emailMessages.add(convertToEmailMessage(message));
        }
        return emailMessages;
    }

    /**
     * Convert single JavaMail Message to EmailMessage
     */
    private EmailMessage convertToEmailMessage(Message message) throws MessagingException {
        EmailMessage emailMessage = new EmailMessage();

        // Basic fields
        String[] messageIds = message.getHeader("Message-ID");
        if (messageIds != null && messageIds.length > 0) {
            emailMessage.setMessageId(messageIds[0]);
        }

        Address[] fromAddresses = message.getFrom();
        if (fromAddresses != null && fromAddresses.length > 0) {
            emailMessage.setFrom(fromAddresses[0].toString());
        }

        Address[] toAddresses = message.getRecipients(Message.RecipientType.TO);
        if (toAddresses != null && toAddresses.length > 0) {
            emailMessage.setTo(toAddresses[0].toString());
        }

        emailMessage.setSubject(message.getSubject());
        emailMessage.setReceivedDate(message.getReceivedDate());
        emailMessage.setSentDate(message.getSentDate());

        // Extract content
        try {
            extractContent(message, emailMessage);
        } catch (IOException e) {
            logger.error("Error extracting email content", e);
        }

        // Extract headers
        Enumeration<Header> headers = message.getAllHeaders();
        while (headers.hasMoreElements()) {
            Header header = headers.nextElement();
            emailMessage.addHeader(header.getName(), header.getValue());
        }

        return emailMessage;
    }

    /**
     * Extract text and HTML content from message
     */
    private void extractContent(Part part, EmailMessage emailMessage)
            throws MessagingException, IOException {
        if (part.isMimeType("text/plain")) {
            emailMessage.setTextContent(part.getContent().toString());
        } else if (part.isMimeType("text/html")) {
            emailMessage.setHtmlContent(part.getContent().toString());
        } else if (part.isMimeType("multipart/*")) {
            Multipart multipart = (Multipart) part.getContent();
            for (int i = 0; i < multipart.getCount(); i++) {
                BodyPart bodyPart = multipart.getBodyPart(i);

                String disposition = bodyPart.getDisposition();
                if (disposition != null && disposition.equalsIgnoreCase(Part.ATTACHMENT)) {
                    emailMessage.addAttachmentName(bodyPart.getFileName());
                } else {
                    extractContent(bodyPart, emailMessage);
                }
            }
        }
    }
}

// Email Content Parser - Extract OTPs, Links, etc.
public class EmailContentParser {
    private static final Logger logger = LoggerFactory.getLogger(EmailContentParser.class);

    /**
     * Extract OTP from email content using regex pattern
     */
    public static String extractOTP(EmailMessage email, String otpPattern) {
        String content = email.getTextContent() != null ?
            email.getTextContent() : email.getHtmlContent();

        if (content == null) {
            logger.warn("Email content is null");
            return null;
        }

        Pattern pattern = Pattern.compile(otpPattern);
        Matcher matcher = pattern.matcher(content);

        if (matcher.find()) {
            String otp = matcher.group(1);
            logger.info("Extracted OTP: {}", otp);
            return otp;
        }

        logger.warn("OTP not found in email content");
        return null;
    }

    /**
     * Extract numeric OTP (common pattern: 4-6 digits)
     */
    public static String extractNumericOTP(EmailMessage email) {
        // Try common OTP patterns
        String[] patterns = {
            "(?:OTP|code|verification code)\\s*:?\\s*(\\d{6})",  // 6-digit OTP
            "(?:OTP|code|verification code)\\s*:?\\s*(\\d{4})",  // 4-digit OTP
            "\\b(\\d{6})\\b",  // Standalone 6-digit number
            "\\b(\\d{4})\\b"   // Standalone 4-digit number
        };

        for (String pattern : patterns) {
            String otp = extractOTP(email, pattern);
            if (otp != null) {
                return otp;
            }
        }

        return null;
    }

    /**
     * Extract all links from email
     */
    public static List<String> extractLinks(EmailMessage email) {
        List<String> links = new ArrayList<>();

        String htmlContent = email.getHtmlContent();
        if (htmlContent != null) {
            Document doc = Jsoup.parse(htmlContent);
            Elements linkElements = doc.select("a[href]");
            for (Element link : linkElements) {
                links.add(link.attr("href"));
            }
        }

        // Also extract from plain text content
        String textContent = email.getTextContent();
        if (textContent != null) {
            Pattern pattern = Pattern.compile("https?://[^\\s]+");
            Matcher matcher = pattern.matcher(textContent);
            while (matcher.find()) {
                String url = matcher.group();
                if (!links.contains(url)) {
                    links.add(url);
                }
            }
        }

        logger.info("Extracted {} links from email", links.size());
        return links;
    }

    /**
     * Extract verification/activation link
     */
    public static String extractVerificationLink(EmailMessage email) {
        List<String> links = extractLinks(email);

        // Filter links containing common verification keywords
        String[] keywords = {"verify", "confirm", "activate", "validation", "token"};

        for (String link : links) {
            String lowerLink = link.toLowerCase();
            for (String keyword : keywords) {
                if (lowerLink.contains(keyword)) {
                    logger.info("Found verification link: {}", link);
                    return link;
                }
            }
        }

        // If no keyword match, return first link if available
        if (!links.isEmpty()) {
            logger.info("Returning first link as verification link: {}", links.get(0));
            return links.get(0);
        }

        logger.warn("No verification link found in email");
        return null;
    }

    /**
     * Extract specific text between markers
     */
    public static String extractTextBetween(EmailMessage email,
            String startMarker, String endMarker) {
        String content = email.getTextContent() != null ?
            email.getTextContent() : email.getHtmlContent();

        if (content == null) {
            return null;
        }

        int startIndex = content.indexOf(startMarker);
        if (startIndex == -1) {
            return null;
        }
        startIndex += startMarker.length();

        int endIndex = content.indexOf(endMarker, startIndex);
        if (endIndex == -1) {
            return null;
        }

        String extracted = content.substring(startIndex, endIndex).trim();
        logger.info("Extracted text between markers: {}", extracted);
        return extracted;
    }
}

// SMS Manager - Twilio Integration
public class SMSManager {
    private static final Logger logger = LoggerFactory.getLogger(SMSManager.class);
    private String accountSid;
    private String authToken;
    private String twilioPhoneNumber;

    public SMSManager(String accountSid, String authToken, String twilioPhoneNumber) {
        this.accountSid = accountSid;
        this.authToken = authToken;
        this.twilioPhoneNumber = twilioPhoneNumber;
        Twilio.init(accountSid, authToken);
    }

    /**
     * Get latest SMS received on Twilio number
     */
    public String getLatestSMS(int maxWaitSeconds) throws InterruptedException {
        long startTime = System.currentTimeMillis();
        long timeoutMillis = maxWaitSeconds * 1000;

        while (System.currentTimeMillis() - startTime < timeoutMillis) {
            ResourceSet<com.twilio.rest.api.v2010.account.Message> messages =
                com.twilio.rest.api.v2010.account.Message
                    .reader()
                    .setTo(new PhoneNumber(twilioPhoneNumber))
                    .limit(1)
                    .read();

            for (com.twilio.rest.api.v2010.account.Message message : messages) {
                // Check if message was received recently (within last 5 minutes)
                long messageTime = message.getDateSent().getTime();
                long currentTime = System.currentTimeMillis();
                if (currentTime - messageTime < 5 * 60 * 1000) {
                    String body = message.getBody();
                    logger.info("Received SMS: {}", body);
                    return body;
                }
            }

            logger.info("SMS not received yet, waiting...");
            Thread.sleep(2000);
        }

        throw new AssertionError(String.format(
            "SMS not received within %d seconds", maxWaitSeconds));
    }

    /**
     * Extract OTP from SMS
     */
    public String extractOTPFromSMS(String smsBody, String otpPattern) {
        Pattern pattern = Pattern.compile(otpPattern);
        Matcher matcher = pattern.matcher(smsBody);

        if (matcher.find()) {
            String otp = matcher.group(1);
            logger.info("Extracted OTP from SMS: {}", otp);
            return otp;
        }

        return null;
    }

    /**
     * Extract numeric OTP from SMS (common pattern)
     */
    public String extractNumericOTPFromSMS(String smsBody) {
        String[] patterns = {
            "(\\d{6})",  // 6-digit OTP
            "(\\d{4})"   // 4-digit OTP
        };

        for (String pattern : patterns) {
            String otp = extractOTPFromSMS(smsBody, pattern);
            if (otp != null) {
                return otp;
            }
        }

        return null;
    }
}

// OTP Manager - Unified OTP Handling
public class OTPManager {
    private static final Logger logger = LoggerFactory.getLogger(OTPManager.class);
    private EmailManager emailManager;
    private SMSManager smsManager;

    public OTPManager(EmailManager emailManager, SMSManager smsManager) {
        this.emailManager = emailManager;
        this.smsManager = smsManager;
    }

    /**
     * Get OTP from email with retry mechanism
     */
    public String getOTPFromEmail(String subjectContains, String fromEmail,
            int maxWaitSeconds) throws MessagingException, InterruptedException {
        EmailMessage email = emailManager.getLatestEmail(subjectContains,
            fromEmail, maxWaitSeconds);
        String otp = EmailContentParser.extractNumericOTP(email);

        if (otp == null) {
            throw new AssertionError("OTP not found in email");
        }

        logger.info("Successfully retrieved OTP from email: {}", otp);
        return otp;
    }

    /**
     * Get OTP from SMS with retry mechanism
     */
    public String getOTPFromSMS(int maxWaitSeconds) throws InterruptedException {
        String smsBody = smsManager.getLatestSMS(maxWaitSeconds);
        String otp = smsManager.extractNumericOTPFromSMS(smsBody);

        if (otp == null) {
            throw new AssertionError("OTP not found in SMS");
        }

        logger.info("Successfully retrieved OTP from SMS: {}", otp);
        return otp;
    }

    /**
     * Get OTP from email or SMS (fallback mechanism)
     */
    public String getOTP(String channel, String subjectContains, String fromEmail,
            int maxWaitSeconds) throws MessagingException, InterruptedException {
        if ("email".equalsIgnoreCase(channel)) {
            return getOTPFromEmail(subjectContains, fromEmail, maxWaitSeconds);
        } else if ("sms".equalsIgnoreCase(channel)) {
            return getOTPFromSMS(maxWaitSeconds);
        } else {
            // Try email first, then SMS
            try {
                return getOTPFromEmail(subjectContains, fromEmail, maxWaitSeconds / 2);
            } catch (Exception e) {
                logger.warn("Failed to get OTP from email, trying SMS", e);
                return getOTPFromSMS(maxWaitSeconds / 2);
            }
        }
    }
}

// Test Examples
@Test(description = "Verify user registration with email OTP")
public void testUserRegistrationWithEmailOTP() throws Exception {
    // Setup email manager
    EmailConfig emailConfig = EmailConfig.gmailIMAP(
        "testuser@gmail.com",
        "app-specific-password"
    );
    EmailManager emailManager = new EmailManager(emailConfig);
    emailManager.connect();

    try {
        // 1. Navigate to registration page
        driver.get("https://example.com/register");

        // 2. Fill registration form
        RegistrationPage registrationPage = new RegistrationPage(driver);
        registrationPage.enterEmail("testuser@gmail.com");
        registrationPage.enterPassword("Test@1234");
        registrationPage.clickRegisterButton();

        // 3. Wait for OTP email
        logger.info("Waiting for OTP email...");
        EmailMessage otpEmail = emailManager.getLatestEmail(
            "Verification Code",  // Subject contains
            "noreply@example.com",  // From email
            60  // Max wait 60 seconds
        );

        // 4. Extract OTP from email
        String otp = EmailContentParser.extractNumericOTP(otpEmail);
        Assert.assertNotNull(otp, "OTP should not be null");
        logger.info("Extracted OTP: {}", otp);

        // 5. Enter OTP on verification page
        OTPVerificationPage otpPage = new OTPVerificationPage(driver);
        otpPage.enterOTP(otp);
        otpPage.clickVerifyButton();

        // 6. Verify successful registration
        DashboardPage dashboard = new DashboardPage(driver);
        Assert.assertTrue(dashboard.isWelcomeMessageDisplayed(),
            "Welcome message should be displayed after successful registration");

    } finally {
        emailManager.disconnect();
    }
}

@Test(description = "Verify password reset with email verification link")
public void testPasswordResetWithEmailLink() throws Exception {
    EmailConfig emailConfig = EmailConfig.gmailIMAP(
        "testuser@gmail.com",
        "app-specific-password"
    );
    EmailManager emailManager = new EmailManager(emailConfig);
    emailManager.connect();

    try {
        // 1. Navigate to forgot password page
        driver.get("https://example.com/forgot-password");

        // 2. Request password reset
        ForgotPasswordPage forgotPasswordPage = new ForgotPasswordPage(driver);
        forgotPasswordPage.enterEmail("testuser@gmail.com");
        forgotPasswordPage.clickSubmitButton();

        // 3. Wait for password reset email
        EmailMessage resetEmail = emailManager.getLatestEmail(
            "Password Reset",
            "noreply@example.com",
            60
        );

        // 4. Extract reset link
        String resetLink = EmailContentParser.extractVerificationLink(resetEmail);
        Assert.assertNotNull(resetLink, "Reset link should not be null");
        logger.info("Reset link: {}", resetLink);

        // 5. Navigate to reset link
        driver.get(resetLink);

        // 6. Set new password
        ResetPasswordPage resetPage = new ResetPasswordPage(driver);
        resetPage.enterNewPassword("NewTest@1234");
        resetPage.enterConfirmPassword("NewTest@1234");
        resetPage.clickResetButton();

        // 7. Verify password reset success
        Assert.assertTrue(resetPage.isSuccessMessageDisplayed(),
            "Success message should be displayed");

    } finally {
        emailManager.disconnect();
    }
}

@Test(description = "Verify SMS OTP for two-factor authentication")
public void testTwoFactorAuthenticationWithSMS() throws Exception {
    // Setup SMS manager with Twilio credentials
    SMSManager smsManager = new SMSManager(
        "TWILIO_ACCOUNT_SID",
        "TWILIO_AUTH_TOKEN",
        "+1234567890"  // Twilio phone number
    );

    // 1. Login with valid credentials
    driver.get("https://example.com/login");
    LoginPage loginPage = new LoginPage(driver);
    loginPage.login("testuser", "Test@1234");

    // 2. Select SMS as 2FA method
    TwoFactorPage twoFactorPage = new TwoFactorPage(driver);
    twoFactorPage.selectSMSOption();
    twoFactorPage.clickSendCodeButton();

    // 3. Wait for SMS and extract OTP
    logger.info("Waiting for SMS OTP...");
    String smsBody = smsManager.getLatestSMS(60);
    String otp = smsManager.extractNumericOTPFromSMS(smsBody);
    Assert.assertNotNull(otp, "OTP should not be null");
    logger.info("Extracted OTP from SMS: {}", otp);

    // 4. Enter OTP
    twoFactorPage.enterOTP(otp);
    twoFactorPage.clickVerifyButton();

    // 5. Verify successful login
    DashboardPage dashboard = new DashboardPage(driver);
    Assert.assertTrue(dashboard.isUserLoggedIn(),
        "User should be logged in after 2FA verification");
}

@Test(description = "Verify email content and formatting")
public void testEmailContentValidation() throws Exception {
    EmailManager emailManager = new EmailManager(
        EmailConfig.gmailIMAP("testuser@gmail.com", "app-password")
    );
    emailManager.connect();

    try {
        // Trigger welcome email
        driver.get("https://example.com/register");
        RegistrationPage registrationPage = new RegistrationPage(driver);
        registrationPage.completeRegistration("testuser@gmail.com", "Test@1234");

        // Get welcome email
        EmailMessage welcomeEmail = emailManager.getLatestEmail(
            "Welcome",
            "welcome@example.com",
            60
        );

        // Validate email properties
        Assert.assertNotNull(welcomeEmail, "Welcome email should be received");
        Assert.assertTrue(welcomeEmail.getSubject().contains("Welcome"),
            "Subject should contain 'Welcome'");
        Assert.assertEquals(welcomeEmail.getFrom(), "welcome@example.com",
            "From address should match");

        // Validate HTML content
        String htmlContent = welcomeEmail.getHtmlContent();
        Assert.assertNotNull(htmlContent, "HTML content should not be null");

        Document doc = Jsoup.parse(htmlContent);
        Assert.assertTrue(doc.text().contains("testuser@gmail.com"),
            "Email should contain user's email address");

        // Validate links
        List<String> links = EmailContentParser.extractLinks(welcomeEmail);
        Assert.assertTrue(links.size() > 0, "Email should contain at least one link");

        // Validate specific text sections
        String greeting = EmailContentParser.extractTextBetween(
            welcomeEmail, "Hello", "Thank you"
        );
        Assert.assertNotNull(greeting, "Greeting section should exist");

    } finally {
        emailManager.disconnect();
    }
}
```

**Follow-up**: How do you handle Gmail's App-Specific Passwords and OAuth2 authentication in automated email testing? What strategies do you use for parallel test execution when multiple tests need email/SMS validation? How do you handle email delivery delays and ensure test reliability? How do you test email rendering across different email clients (Gmail, Outlook, etc.)?

---

### **Q98. How do you integrate Performance Testing with Selenium tests? Explain response time monitoring, resource usage tracking, and integration with JMeter/Gatling.** (6-8 Years, 9-12 Years)

**Difficulty**: Hard
**Companies**: Amazon, Google, Netflix, Uber, Swiggy, Flipkart, Microsoft, Adobe
**Topics**: Performance Testing, JMeter Integration, Performance Monitoring, Load Testing

**Answer**:

Performance testing integration with Selenium allows us to measure and monitor application performance during UI testing. This includes tracking page load times, resource loading, API response times, and identifying performance bottlenecks. Modern frameworks integrate performance metrics collection using browser APIs, DevTools Protocol, and tools like JMeter/Gatling.

**Key Implementation Areas:**

1. **Browser Performance API**
   - Navigation Timing API for page load metrics
   - Resource Timing API for individual resource loading
   - User Timing API for custom performance marks
   - Paint Timing API for rendering metrics

2. **Chrome DevTools Protocol (CDP) Performance**
   - Performance metrics collection
   - Network activity monitoring
   - CPU and memory profiling
   - Code coverage analysis

3. **JMeter Integration**
   - Combine UI and load testing
   - Share test data between Selenium and JMeter
   - Correlate UI behavior with load
   - Performance benchmarking

**Complete Implementation:**

```java
// pom.xml dependencies
/*
<dependencies>
    <!-- JMeter Core for Performance Testing -->
    <dependency>
        <groupId>org.apache.jmeter</groupId>
        <artifactId>ApacheJMeter_core</artifactId>
        <version>5.5</version>
    </dependency>

    <dependency>
        <groupId>org.apache.jmeter</groupId>
        <artifactId>ApacheJMeter_http</artifactId>
        <version>5.5</version>
    </dependency>

    <!-- BrowserMob Proxy for Network Monitoring -->
    <dependency>
        <groupId>net.lightbody.bmp</groupId>
        <artifactId>browsermob-core</artifactId>
        <version>2.1.5</version>
    </dependency>
</dependencies>
*/

// Performance Metrics Model
public class PerformanceMetrics {
    // Navigation Timing
    private long navigationStart;
    private long fetchStart;
    private long domainLookupStart;
    private long domainLookupEnd;
    private long connectStart;
    private long connectEnd;
    private long requestStart;
    private long responseStart;
    private long responseEnd;
    private long domLoading;
    private long domInteractive;
    private long domContentLoadedEventStart;
    private long domContentLoadedEventEnd;
    private long domComplete;
    private long loadEventStart;
    private long loadEventEnd;

    // Calculated Metrics
    private long dnsLookupTime;
    private long tcpConnectTime;
    private long serverResponseTime;
    private long pageDownloadTime;
    private long domProcessingTime;
    private long totalPageLoadTime;

    // Resource Metrics
    private int totalResources;
    private int jsResources;
    private int cssResources;
    private int imageResources;
    private long totalResourceSize;

    // Paint Timing
    private long firstPaint;
    private long firstContentfulPaint;
    private long largestContentfulPaint;

    // Custom Metrics
    private Map<String, Long> customMarks;
    private Map<String, Long> customMeasures;

    public PerformanceMetrics() {
        customMarks = new HashMap<>();
        customMeasures = new HashMap<>();
    }

    public void calculateDerivedMetrics() {
        this.dnsLookupTime = domainLookupEnd - domainLookupStart;
        this.tcpConnectTime = connectEnd - connectStart;
        this.serverResponseTime = responseStart - requestStart;
        this.pageDownloadTime = responseEnd - responseStart;
        this.domProcessingTime = domComplete - domLoading;
        this.totalPageLoadTime = loadEventEnd - navigationStart;
    }

    // Getters and setters for all fields
    public long getNavigationStart() { return navigationStart; }
    public void setNavigationStart(long navigationStart) { this.navigationStart = navigationStart; }

    public long getTotalPageLoadTime() { return totalPageLoadTime; }
    public long getDnsLookupTime() { return dnsLookupTime; }
    public long getServerResponseTime() { return serverResponseTime; }
    public long getDomProcessingTime() { return domProcessingTime; }

    public long getFirstContentfulPaint() { return firstContentfulPaint; }
    public void setFirstContentfulPaint(long firstContentfulPaint) {
        this.firstContentfulPaint = firstContentfulPaint;
    }

    public long getLargestContentfulPaint() { return largestContentfulPaint; }
    public void setLargestContentfulPaint(long largestContentfulPaint) {
        this.largestContentfulPaint = largestContentfulPaint;
    }

    public void addCustomMark(String name, long timestamp) {
        customMarks.put(name, timestamp);
    }

    public void addCustomMeasure(String name, long duration) {
        customMeasures.put(name, duration);
    }

    @Override
    public String toString() {
        return String.format(
            "PerformanceMetrics{totalPageLoad=%dms, dns=%dms, serverResponse=%dms, " +
            "domProcessing=%dms, fcp=%dms, lcp=%dms}",
            totalPageLoadTime, dnsLookupTime, serverResponseTime,
            domProcessingTime, firstContentfulPaint, largestContentfulPaint
        );
    }
}

// Performance Manager - Core Performance Testing Utility
public class PerformanceManager {
    private static final Logger logger = LoggerFactory.getLogger(PerformanceManager.class);
    private WebDriver driver;
    private JavascriptExecutor jsExecutor;

    public PerformanceManager(WebDriver driver) {
        this.driver = driver;
        this.jsExecutor = (JavascriptExecutor) driver;
    }

    /**
     * Collect navigation timing metrics using Performance API
     */
    public PerformanceMetrics collectNavigationTiming() {
        String script =
            "var performance = window.performance || window.mozPerformance || " +
            "window.msPerformance || window.webkitPerformance || {};" +
            "var timing = performance.timing || {};" +
            "return JSON.stringify(timing);";

        String timingJson = (String) jsExecutor.executeScript(script);

        try {
            ObjectMapper mapper = new ObjectMapper();
            Map<String, Object> timingMap = mapper.readValue(timingJson, Map.class);

            PerformanceMetrics metrics = new PerformanceMetrics();

            // Extract navigation timing values
            metrics.setNavigationStart(getLong(timingMap, "navigationStart"));
            metrics.setFetchStart(getLong(timingMap, "fetchStart"));
            metrics.setDomainLookupStart(getLong(timingMap, "domainLookupStart"));
            metrics.setDomainLookupEnd(getLong(timingMap, "domainLookupEnd"));
            metrics.setConnectStart(getLong(timingMap, "connectStart"));
            metrics.setConnectEnd(getLong(timingMap, "connectEnd"));
            metrics.setRequestStart(getLong(timingMap, "requestStart"));
            metrics.setResponseStart(getLong(timingMap, "responseStart"));
            metrics.setResponseEnd(getLong(timingMap, "responseEnd"));
            metrics.setDomLoading(getLong(timingMap, "domLoading"));
            metrics.setDomInteractive(getLong(timingMap, "domInteractive"));
            metrics.setDomContentLoadedEventStart(getLong(timingMap, "domContentLoadedEventStart"));
            metrics.setDomContentLoadedEventEnd(getLong(timingMap, "domContentLoadedEventEnd"));
            metrics.setDomComplete(getLong(timingMap, "domComplete"));
            metrics.setLoadEventStart(getLong(timingMap, "loadEventStart"));
            metrics.setLoadEventEnd(getLong(timingMap, "loadEventEnd"));

            // Calculate derived metrics
            metrics.calculateDerivedMetrics();

            logger.info("Navigation timing collected: {}", metrics);
            return metrics;

        } catch (Exception e) {
            logger.error("Error parsing navigation timing", e);
            return null;
        }
    }

    /**
     * Collect paint timing metrics (FCP, LCP)
     */
    public void collectPaintTiming(PerformanceMetrics metrics) {
        String script =
            "var paintEntries = performance.getEntriesByType('paint');" +
            "var result = {};" +
            "paintEntries.forEach(function(entry) {" +
            "    result[entry.name] = entry.startTime;" +
            "});" +
            "return JSON.stringify(result);";

        String paintJson = (String) jsExecutor.executeScript(script);

        try {
            ObjectMapper mapper = new ObjectMapper();
            Map<String, Object> paintMap = mapper.readValue(paintJson, Map.class);

            if (paintMap.containsKey("first-paint")) {
                metrics.setFirstPaint(((Number) paintMap.get("first-paint")).longValue());
            }
            if (paintMap.containsKey("first-contentful-paint")) {
                metrics.setFirstContentfulPaint(
                    ((Number) paintMap.get("first-contentful-paint")).longValue()
                );
            }

            logger.info("Paint timing collected - FCP: {}ms", metrics.getFirstContentfulPaint());

        } catch (Exception e) {
            logger.error("Error parsing paint timing", e);
        }
    }

    /**
     * Collect Largest Contentful Paint (LCP) using PerformanceObserver
     */
    public void collectLCP(PerformanceMetrics metrics) {
        String script =
            "return new Promise((resolve) => {" +
            "    new PerformanceObserver((entryList) => {" +
            "        const entries = entryList.getEntries();" +
            "        const lastEntry = entries[entries.length - 1];" +
            "        resolve(lastEntry.renderTime || lastEntry.loadTime);" +
            "    }).observe({type: 'largest-contentful-paint', buffered: true});" +
            "    setTimeout(() => resolve(0), 5000);" // Timeout after 5 seconds
            + "});";

        try {
            Object result = jsExecutor.executeAsyncScript(script);
            if (result instanceof Number) {
                metrics.setLargestContentfulPaint(((Number) result).longValue());
                logger.info("LCP: {}ms", metrics.getLargestContentfulPaint());
            }
        } catch (Exception e) {
            logger.warn("LCP collection not supported or failed", e);
        }
    }

    /**
     * Collect resource timing for all page resources
     */
    public List<ResourceTiming> collectResourceTiming() {
        String script =
            "var resources = performance.getEntriesByType('resource');" +
            "return JSON.stringify(resources);";

        String resourcesJson = (String) jsExecutor.executeScript(script);
        List<ResourceTiming> resourceTimings = new ArrayList<>();

        try {
            ObjectMapper mapper = new ObjectMapper();
            List<Map<String, Object>> resourcesList = mapper.readValue(
                resourcesJson, new TypeReference<List<Map<String, Object>>>() {}
            );

            for (Map<String, Object> resource : resourcesList) {
                ResourceTiming rt = new ResourceTiming();
                rt.setName((String) resource.get("name"));
                rt.setInitiatorType((String) resource.get("initiatorType"));
                rt.setDuration(((Number) resource.get("duration")).longValue());
                rt.setTransferSize(resource.containsKey("transferSize") ?
                    ((Number) resource.get("transferSize")).longValue() : 0);
                resourceTimings.add(rt);
            }

            logger.info("Collected {} resource timing entries", resourceTimings.size());
            return resourceTimings;

        } catch (Exception e) {
            logger.error("Error parsing resource timing", e);
            return resourceTimings;
        }
    }

    /**
     * Create custom performance marks
     */
    public void markPerformance(String markName) {
        String script = String.format("performance.mark('%s');", markName);
        jsExecutor.executeScript(script);
        logger.info("Performance mark created: {}", markName);
    }

    /**
     * Measure time between two marks
     */
    public long measurePerformance(String measureName, String startMark, String endMark) {
        String script = String.format(
            "performance.measure('%s', '%s', '%s');" +
            "var measure = performance.getEntriesByName('%s')[0];" +
            "return measure.duration;",
            measureName, startMark, endMark, measureName
        );

        Object result = jsExecutor.executeScript(script);
        long duration = result instanceof Number ? ((Number) result).longValue() : 0;
        logger.info("Performance measure '{}': {}ms", measureName, duration);
        return duration;
    }

    /**
     * Wait for page load complete with timeout
     */
    public void waitForPageLoad(int timeoutSeconds) {
        new WebDriverWait(driver, Duration.ofSeconds(timeoutSeconds))
            .until(driver -> jsExecutor.executeScript("return document.readyState")
                .equals("complete"));
        logger.info("Page load complete");
    }

    /**
     * Helper method to safely get long value from map
     */
    private long getLong(Map<String, Object> map, String key) {
        Object value = map.get(key);
        if (value instanceof Number) {
            return ((Number) value).longValue();
        }
        return 0;
    }
}

// Resource Timing Model
public class ResourceTiming {
    private String name;
    private String initiatorType;
    private long duration;
    private long transferSize;

    // Getters and setters
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getInitiatorType() { return initiatorType; }
    public void setInitiatorType(String initiatorType) { this.initiatorType = initiatorType; }

    public long getDuration() { return duration; }
    public void setDuration(long duration) { this.duration = duration; }

    public long getTransferSize() { return transferSize; }
    public void setTransferSize(long transferSize) { this.transferSize = transferSize; }

    @Override
    public String toString() {
        return String.format("Resource{name='%s', type='%s', duration=%dms, size=%dbytes}",
            name, initiatorType, duration, transferSize);
    }
}

// Chrome DevTools Performance Manager
public class CDPPerformanceManager {
    private static final Logger logger = LoggerFactory.getLogger(CDPPerformanceManager.class);
    private ChromeDriver driver;
    private DevTools devTools;
    private List<Metric> performanceMetrics;

    public CDPPerformanceManager(ChromeDriver driver) {
        this.driver = driver;
        this.devTools = driver.getDevTools();
        this.performanceMetrics = new ArrayList<>();
        devTools.createSession();
    }

    /**
     * Enable performance monitoring
     */
    public void enablePerformanceMonitoring() {
        devTools.send(Performance.enable(Optional.empty()));
        logger.info("Performance monitoring enabled");
    }

    /**
     * Get performance metrics from CDP
     */
    public List<Metric> getPerformanceMetrics() {
        List<Metric> metrics = devTools.send(Performance.getMetrics());
        this.performanceMetrics = metrics;

        logger.info("Collected {} performance metrics", metrics.size());
        metrics.forEach(metric ->
            logger.debug("{}: {}", metric.getName(), metric.getValue())
        );

        return metrics;
    }

    /**
     * Get specific metric value by name
     */
    public double getMetricValue(String metricName) {
        return performanceMetrics.stream()
            .filter(m -> m.getName().equals(metricName))
            .findFirst()
            .map(Metric::getValue)
            .orElse(0.0);
    }

    /**
     * Collect key performance metrics
     */
    public Map<String, Double> collectKeyMetrics() {
        List<Metric> metrics = getPerformanceMetrics();
        Map<String, Double> keyMetrics = new HashMap<>();

        // Extract key metrics
        String[] importantMetrics = {
            "Timestamp",
            "Documents",
            "Frames",
            "JSEventListeners",
            "Nodes",
            "LayoutCount",
            "RecalcStyleCount",
            "LayoutDuration",
            "RecalcStyleDuration",
            "ScriptDuration",
            "TaskDuration",
            "JSHeapUsedSize",
            "JSHeapTotalSize"
        };

        for (String metricName : importantMetrics) {
            double value = getMetricValue(metricName);
            keyMetrics.put(metricName, value);
        }

        logger.info("Key metrics collected: {}", keyMetrics);
        return keyMetrics;
    }

    /**
     * Monitor memory usage
     */
    public MemoryUsage getMemoryUsage() {
        Map<String, Double> metrics = collectKeyMetrics();

        MemoryUsage memoryUsage = new MemoryUsage();
        memoryUsage.setJsHeapUsedSize(metrics.getOrDefault("JSHeapUsedSize", 0.0).longValue());
        memoryUsage.setJsHeapTotalSize(metrics.getOrDefault("JSHeapTotalSize", 0.0).longValue());
        memoryUsage.setNodes(metrics.getOrDefault("Nodes", 0.0).intValue());
        memoryUsage.setJsEventListeners(metrics.getOrDefault("JSEventListeners", 0.0).intValue());

        logger.info("Memory usage: {}", memoryUsage);
        return memoryUsage;
    }

    public void disable() {
        devTools.send(Performance.disable());
        logger.info("Performance monitoring disabled");
    }
}

// Memory Usage Model
public class MemoryUsage {
    private long jsHeapUsedSize;
    private long jsHeapTotalSize;
    private int nodes;
    private int jsEventListeners;

    public long getJsHeapUsedSize() { return jsHeapUsedSize; }
    public void setJsHeapUsedSize(long jsHeapUsedSize) { this.jsHeapUsedSize = jsHeapUsedSize; }

    public long getJsHeapTotalSize() { return jsHeapTotalSize; }
    public void setJsHeapTotalSize(long jsHeapTotalSize) {
        this.jsHeapTotalSize = jsHeapTotalSize;
    }

    public double getHeapUsagePercent() {
        return jsHeapTotalSize > 0 ?
            (jsHeapUsedSize * 100.0 / jsHeapTotalSize) : 0;
    }

    public int getNodes() { return nodes; }
    public void setNodes(int nodes) { this.nodes = nodes; }

    public int getJsEventListeners() { return jsEventListeners; }
    public void setJsEventListeners(int jsEventListeners) {
        this.jsEventListeners = jsEventListeners;
    }

    @Override
    public String toString() {
        return String.format(
            "MemoryUsage{heapUsed=%dMB, heapTotal=%dMB, usage=%.2f%%, nodes=%d, listeners=%d}",
            jsHeapUsedSize / (1024 * 1024),
            jsHeapTotalSize / (1024 * 1024),
            getHeapUsagePercent(),
            nodes,
            jsEventListeners
        );
    }
}

// JMeter Integration Manager
public class JMeterIntegrationManager {
    private static final Logger logger = LoggerFactory.getLogger(JMeterIntegrationManager.class);

    /**
     * Run JMeter test plan programmatically
     */
    public JMeterResults runJMeterTest(String testPlanPath, Map<String, String> properties) {
        try {
            // Initialize JMeter
            JMeterUtils.loadJMeterProperties(
                System.getProperty("user.dir") + "/jmeter.properties"
            );
            JMeterUtils.initLocale();

            // Load test plan
            SaveService.loadProperties();
            FileInputStream testPlanFile = new FileInputStream(new File(testPlanPath));
            HashTree testPlanTree = SaveService.loadTree(testPlanFile);
            testPlanFile.close();

            // Set properties
            if (properties != null) {
                properties.forEach((key, value) ->
                    JMeterUtils.setProperty(key, value)
                );
            }

            // Run test
            StandardJMeterEngine jmeter = new StandardJMeterEngine();
            jmeter.configure(testPlanTree);
            jmeter.run();

            logger.info("JMeter test completed: {}", testPlanPath);

            // Collect results (simplified - in reality, use listeners)
            return new JMeterResults();

        } catch (Exception e) {
            logger.error("Error running JMeter test", e);
            return null;
        }
    }

    /**
     * Integrate Selenium test data with JMeter
     */
    public void exportSeleniumDataForJMeter(List<Map<String, String>> testData,
            String csvPath) throws IOException {
        try (CSVWriter writer = new CSVWriter(new FileWriter(csvPath))) {
            if (!testData.isEmpty()) {
                // Write headers
                String[] headers = testData.get(0).keySet().toArray(new String[0]);
                writer.writeNext(headers);

                // Write data rows
                for (Map<String, String> row : testData) {
                    String[] values = headers.length > 0 ?
                        Arrays.stream(headers)
                            .map(row::get)
                            .toArray(String[]::new) : new String[0];
                    writer.writeNext(values);
                }
            }

            logger.info("Exported {} rows to JMeter CSV: {}", testData.size(), csvPath);
        }
    }
}

// JMeter Results Model
public class JMeterResults {
    private int totalSamples;
    private int errorCount;
    private double averageResponseTime;
    private double throughput;

    // Getters and setters
    public int getTotalSamples() { return totalSamples; }
    public void setTotalSamples(int totalSamples) { this.totalSamples = totalSamples; }

    public int getErrorCount() { return errorCount; }
    public void setErrorCount(int errorCount) { this.errorCount = errorCount; }

    public double getAverageResponseTime() { return averageResponseTime; }
    public void setAverageResponseTime(double averageResponseTime) {
        this.averageResponseTime = averageResponseTime;
    }

    public double getThroughput() { return throughput; }
    public void setThroughput(double throughput) { this.throughput = throughput; }

    public double getErrorRate() {
        return totalSamples > 0 ? (errorCount * 100.0 / totalSamples) : 0;
    }
}

// Performance Assertions
public class PerformanceAssertions {
    private static final Logger logger = LoggerFactory.getLogger(PerformanceAssertions.class);

    /**
     * Assert page load time is within threshold
     */
    public static void assertPageLoadTime(PerformanceMetrics metrics, long thresholdMs) {
        long actualTime = metrics.getTotalPageLoadTime();
        logger.info("Page load time: {}ms (threshold: {}ms)", actualTime, thresholdMs);

        Assert.assertTrue(
            actualTime <= thresholdMs,
            String.format("Page load time %dms exceeds threshold %dms", actualTime, thresholdMs)
        );
    }

    /**
     * Assert First Contentful Paint is within threshold
     */
    public static void assertFirstContentfulPaint(PerformanceMetrics metrics, long thresholdMs) {
        long fcp = metrics.getFirstContentfulPaint();
        logger.info("First Contentful Paint: {}ms (threshold: {}ms)", fcp, thresholdMs);

        Assert.assertTrue(
            fcp <= thresholdMs,
            String.format("FCP %dms exceeds threshold %dms", fcp, thresholdMs)
        );
    }

    /**
     * Assert server response time is within threshold
     */
    public static void assertServerResponseTime(PerformanceMetrics metrics, long thresholdMs) {
        long responseTime = metrics.getServerResponseTime();
        logger.info("Server response time: {}ms (threshold: {}ms)", responseTime, thresholdMs);

        Assert.assertTrue(
            responseTime <= thresholdMs,
            String.format("Server response time %dms exceeds threshold %dms",
                responseTime, thresholdMs)
        );
    }

    /**
     * Assert memory usage is within limit
     */
    public static void assertMemoryUsage(MemoryUsage memoryUsage, double maxUsagePercent) {
        double actualUsage = memoryUsage.getHeapUsagePercent();
        logger.info("Memory usage: {.2f}% (max: %.2f%)", actualUsage, maxUsagePercent);

        Assert.assertTrue(
            actualUsage <= maxUsagePercent,
            String.format("Memory usage %.2f%% exceeds limit %.2f%%",
                actualUsage, maxUsagePercent)
        );
    }
}

// Test Examples
@Test(description = "Verify page load performance")
public void testPageLoadPerformance() {
    driver.get("https://example.com");

    PerformanceManager perfManager = new PerformanceManager(driver);
    perfManager.waitForPageLoad(30);

    // Collect navigation timing
    PerformanceMetrics metrics = perfManager.collectNavigationTiming();
    perfManager.collectPaintTiming(metrics);
    perfManager.collectLCP(metrics);

    // Log metrics
    logger.info("Performance metrics: {}", metrics);
    logger.info("DNS Lookup: {}ms", metrics.getDnsLookupTime());
    logger.info("Server Response: {}ms", metrics.getServerResponseTime());
    logger.info("DOM Processing: {}ms", metrics.getDomProcessingTime());
    logger.info("Total Page Load: {}ms", metrics.getTotalPageLoadTime());
    logger.info("FCP: {}ms", metrics.getFirstContentfulPaint());
    logger.info("LCP: {}ms", metrics.getLargestContentfulPaint());

    // Performance assertions
    PerformanceAssertions.assertPageLoadTime(metrics, 3000);  // 3 seconds
    PerformanceAssertions.assertFirstContentfulPaint(metrics, 1500);  // 1.5 seconds
    PerformanceAssertions.assertServerResponseTime(metrics, 500);  // 500ms
}

@Test(description = "Verify resource loading performance")
public void testResourceLoadingPerformance() {
    driver.get("https://example.com");

    PerformanceManager perfManager = new PerformanceManager(driver);
    perfManager.waitForPageLoad(30);

    // Collect resource timing
    List<ResourceTiming> resources = perfManager.collectResourceTiming();

    // Analyze slow resources
    List<ResourceTiming> slowResources = resources.stream()
        .filter(r -> r.getDuration() > 1000)  // > 1 second
        .sorted((r1, r2) -> Long.compare(r2.getDuration(), r1.getDuration()))
        .collect(Collectors.toList());

    if (!slowResources.isEmpty()) {
        logger.warn("Found {} slow resources:", slowResources.size());
        slowResources.forEach(r -> logger.warn("  {}", r));
    }

    // Assert no resources take more than 3 seconds
    long maxDuration = resources.stream()
        .mapToLong(ResourceTiming::getDuration)
        .max()
        .orElse(0);

    Assert.assertTrue(maxDuration <= 3000,
        "Maximum resource load time " + maxDuration + "ms exceeds 3000ms");
}

@Test(description = "Monitor memory usage during test")
public void testMemoryUsage() {
    ChromeDriver chromeDriver = (ChromeDriver) driver;
    CDPPerformanceManager cdpPerf = new CDPPerformanceManager(chromeDriver);
    cdpPerf.enablePerformanceMonitoring();

    // Perform actions
    driver.get("https://example.com");

    // Collect initial memory
    MemoryUsage initialMemory = cdpPerf.getMemoryUsage();
    logger.info("Initial memory: {}", initialMemory);

    // Perform memory-intensive operations
    for (int i = 0; i < 10; i++) {
        driver.findElement(By.tagName("body"));  // Simulate operations
    }

    // Collect final memory
    MemoryUsage finalMemory = cdpPerf.getMemoryUsage();
    logger.info("Final memory: {}", finalMemory);

    // Assert memory usage is within acceptable range
    PerformanceAssertions.assertMemoryUsage(finalMemory, 80.0);  // 80% max

    cdpPerf.disable();
}

@Test(description = "Custom performance marks and measures")
public void testCustomPerformanceMarks() {
    PerformanceManager perfManager = new PerformanceManager(driver);

    driver.get("https://example.com");

    // Mark start of operation
    perfManager.markPerformance("search-start");

    // Perform search
    driver.findElement(By.id("search")).sendKeys("test query");
    driver.findElement(By.id("search-button")).click();

    // Mark end of operation
    perfManager.markPerformance("search-end");

    // Measure duration
    long searchDuration = perfManager.measurePerformance(
        "search-operation",
        "search-start",
        "search-end"
    );

    logger.info("Search operation took: {}ms", searchDuration);

    // Assert search completed within 2 seconds
    Assert.assertTrue(searchDuration <= 2000,
        "Search operation took " + searchDuration + "ms, expected <= 2000ms");
}
```

**Follow-up**: How do you correlate UI performance with backend API performance? What strategies do you use for continuous performance monitoring in CI/CD? How do you identify and troubleshoot performance bottlenecks? What tools do you use for real user monitoring (RUM) vs synthetic monitoring?

---

### **Q99. What advanced troubleshooting and debugging techniques do you use for Selenium test failures? Explain common issues, debugging strategies, and best practices.** (6-8 Years, 9-12 Years)

**Difficulty**: Hard
**Companies**: All companies - Universal debugging skillset
**Topics**: Debugging, Troubleshooting, Exception Handling, Root Cause Analysis

**Answer**:

Advanced troubleshooting is critical for maintaining stable test automation. Senior automation engineers must quickly identify root causes, distinguish between test issues and application bugs, and implement robust debugging mechanisms.

**Common Selenium Issues & Solutions:**

1. **Timing Issues** - Most common cause of flakiness
2. **Element Not Found** - Locator issues or dynamic content
3. **Stale Element Reference** - DOM changes after element location
4. **Timeout Exceptions** - Insufficient waits or performance issues
5. **Cross-Browser Compatibility** - Different browser behaviors
6. **Environment-Specific Issues** - Config, data, or infrastructure differences

**Complete Troubleshooting Framework:**

```java
// pom.xml - Add debugging dependencies
/*
<dependencies>
    <!-- Screenshot on failure -->
    <dependency>
        <groupId>ru.yandex.qatools.ashot</groupId>
        <artifactId>ashot</artifactId>
        <version>1.5.4</version>
    </dependency>

    <!-- Enhanced logging -->
    <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-api</artifactId>
        <version>2.0.6</version>
    </dependency>

    <dependency>
        <groupId>ch.qos.logback</groupId>
        <artifactId>logback-classic</artifactId>
        <version>1.4.5</version>
    </dependency>
</dependencies>
*/

// Debug Manager - Centralized Debugging Utilities
public class DebugManager {
    private static final Logger logger = LoggerFactory.getLogger(DebugManager.class);
    private WebDriver driver;
    private String screenshotDir;
    private String logDir;

    public DebugManager(WebDriver driver) {
        this.driver = driver;
        this.screenshotDir = System.getProperty("user.dir") + "/test-output/debug-screenshots";
        this.logDir = System.getProperty("user.dir") + "/test-output/debug-logs";
        createDebugDirectories();
    }

    private void createDebugDirectories() {
        new File(screenshotDir).mkdirs();
        new File(logDir).mkdirs();
    }

    /**
     * Capture full debug information on test failure
     */
    public DebugInfo captureDebugInfo(String testName, Throwable error) {
        DebugInfo debugInfo = new DebugInfo();
        debugInfo.setTestName(testName);
        debugInfo.setTimestamp(new Date());
        debugInfo.setError(error);

        try {
            // Capture screenshot
            String screenshotPath = captureScreenshot(testName);
            debugInfo.setScreenshotPath(screenshotPath);

            // Capture page source
            String pageSource = driver.getPageSource();
            debugInfo.setPageSource(pageSource);

            // Capture current URL
            debugInfo.setCurrentUrl(driver.getCurrentUrl());

            // Capture browser console logs
            List<String> consoleLogs = captureBrowserLogs();
            debugInfo.setConsoleLogs(consoleLogs);

            // Capture page title
            debugInfo.setPageTitle(driver.getTitle());

            // Capture cookies
            Set<Cookie> cookies = driver.manage().getCookies();
            debugInfo.setCookies(cookies);

            // Log all debug info
            logger.error("Test Failure Debug Info:");
            logger.error("  Test: {}", testName);
            logger.error("  Error: {}", error.getMessage());
            logger.error("  URL: {}", debugInfo.getCurrentUrl());
            logger.error("  Screenshot: {}", screenshotPath);

            // Save debug report
            saveDebugReport(debugInfo);

        } catch (Exception e) {
            logger.error("Error capturing debug info", e);
        }

        return debugInfo;
    }

    /**
     * Capture screenshot with timestamp
     */
    private String captureScreenshot(String testName) {
        try {
            String timestamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
            String fileName = String.format("%s_%s.png", testName, timestamp);
            String filePath = screenshotDir + "/" + fileName;

            File screenshot = ((TakesScreenshot) driver).getScreenshotAs(OutputType.FILE);
            FileUtils.copyFile(screenshot, new File(filePath));

            logger.info("Screenshot saved: {}", filePath);
            return filePath;
        } catch (Exception e) {
            logger.error("Failed to capture screenshot", e);
            return null;
        }
    }

    /**
     * Capture browser console logs
     */
    private List<String> captureBrowserLogs() {
        List<String> logs = new ArrayList<>();
        try {
            LogEntries logEntries = driver.manage().logs().get(LogType.BROWSER);
            for (LogEntry entry : logEntries) {
                logs.add(String.format("[%s] %s - %s",
                    entry.getLevel(), new Date(entry.getTimestamp()), entry.getMessage()));
            }
        } catch (Exception e) {
            logger.warn("Browser logs not available", e);
        }
        return logs;
    }

    /**
     * Save complete debug report to file
     */
    private void saveDebugReport(DebugInfo debugInfo) {
        try {
            String timestamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(debugInfo.getTimestamp());
            String fileName = String.format("%s_%s_debug.html", debugInfo.getTestName(), timestamp);
            String filePath = logDir + "/" + fileName;

            StringBuilder html = new StringBuilder();
            html.append("<html><head><title>Debug Report - ").append(debugInfo.getTestName()).append("</title>");
            html.append("<style>body{font-family:Arial;margin:20px;}");
            html.append(".section{margin:20px 0;padding:10px;border:1px solid #ccc;}");
            html.append(".error{color:red;}.code{background:#f4f4f4;padding:10px;overflow:auto;}</style>");
            html.append("</head><body>");

            html.append("<h1>Test Failure Debug Report</h1>");
            html.append("<div class='section'>");
            html.append("<h2>Test Information</h2>");
            html.append("<p><strong>Test Name:</strong> ").append(debugInfo.getTestName()).append("</p>");
            html.append("<p><strong>Timestamp:</strong> ").append(debugInfo.getTimestamp()).append("</p>");
            html.append("<p><strong>URL:</strong> ").append(debugInfo.getCurrentUrl()).append("</p>");
            html.append("<p><strong>Page Title:</strong> ").append(debugInfo.getPageTitle()).append("</p>");
            html.append("</div>");

            html.append("<div class='section'>");
            html.append("<h2>Error Details</h2>");
            html.append("<p class='error'>").append(debugInfo.getError().toString()).append("</p>");
            html.append("<pre class='code'>").append(getStackTrace(debugInfo.getError())).append("</pre>");
            html.append("</div>");

            if (debugInfo.getScreenshotPath() != null) {
                html.append("<div class='section'>");
                html.append("<h2>Screenshot</h2>");
                html.append("<img src='").append(debugInfo.getScreenshotPath()).append("' width='800'/>");
                html.append("</div>");
            }

            if (!debugInfo.getConsoleLogs().isEmpty()) {
                html.append("<div class='section'>");
                html.append("<h2>Browser Console Logs</h2>");
                html.append("<pre class='code'>");
                debugInfo.getConsoleLogs().forEach(log -> html.append(log).append("\n"));
                html.append("</pre></div>");
            }

            html.append("</body></html>");

            Files.write(Paths.get(filePath), html.toString().getBytes());
            logger.info("Debug report saved: {}", filePath);

        } catch (Exception e) {
            logger.error("Failed to save debug report", e);
        }
    }

    private String getStackTrace(Throwable error) {
        StringWriter sw = new StringWriter();
        error.printStackTrace(new PrintWriter(sw));
        return sw.toString();
    }

    /**
     * Highlight element for debugging
     */
    public void highlightElement(WebElement element) {
        JavascriptExecutor js = (JavascriptExecutor) driver;
        String originalStyle = element.getAttribute("style");

        // Highlight in red
        js.executeScript("arguments[0].setAttribute('style', 'border: 3px solid red;');", element);

        try {
            Thread.sleep(500); // Brief pause to see highlight
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        // Restore original style
        js.executeScript("arguments[0].setAttribute('style', arguments[1]);", element, originalStyle);
    }

    /**
     * Print element details for debugging
     */
    public void printElementDetails(WebElement element) {
        logger.info("Element Details:");
        logger.info("  Tag: {}", element.getTagName());
        logger.info("  Text: {}", element.getText());
        logger.info("  Displayed: {}", element.isDisplayed());
        logger.info("  Enabled: {}", element.isEnabled());
        logger.info("  Selected: {}", element.isSelected());
        logger.info("  Location: {}", element.getLocation());
        logger.info("  Size: {}", element.getSize());

        // Print common attributes
        String[] attributes = {"id", "class", "name", "value", "type", "href"};
        for (String attr : attributes) {
            String value = element.getAttribute(attr);
            if (value != null && !value.isEmpty()) {
                logger.info("  {}: {}", attr, value);
            }
        }
    }
}

// Debug Info Model
public class DebugInfo {
    private String testName;
    private Date timestamp;
    private Throwable error;
    private String screenshotPath;
    private String pageSource;
    private String currentUrl;
    private String pageTitle;
    private List<String> consoleLogs;
    private Set<Cookie> cookies;

    // Getters and setters
    public String getTestName() { return testName; }
    public void setTestName(String testName) { this.testName = testName; }

    public Date getTimestamp() { return timestamp; }
    public void setTimestamp(Date timestamp) { this.timestamp = timestamp; }

    public Throwable getError() { return error; }
    public void setError(Throwable error) { this.error = error; }

    public String getScreenshotPath() { return screenshotPath; }
    public void setScreenshotPath(String screenshotPath) { this.screenshotPath = screenshotPath; }

    public String getPageSource() { return pageSource; }
    public void setPageSource(String pageSource) { this.pageSource = pageSource; }

    public String getCurrentUrl() { return currentUrl; }
    public void setCurrentUrl(String currentUrl) { this.currentUrl = currentUrl; }

    public String getPageTitle() { return pageTitle; }
    public void setPageTitle(String pageTitle) { this.pageTitle = pageTitle; }

    public List<String> getConsoleLogs() { return consoleLogs; }
    public void setConsoleLogs(List<String> consoleLogs) { this.consoleLogs = consoleLogs; }

    public Set<Cookie> getCookies() { return cookies; }
    public void setCookies(Set<Cookie> cookies) { this.cookies = cookies; }
}

// Exception Handler - Centralized exception handling with retries
public class ExceptionHandler {
    private static final Logger logger = LoggerFactory.getLogger(ExceptionHandler.class);
    private static final int MAX_RETRIES = 3;
    private static final long RETRY_DELAY_MS = 1000;

    /**
     * Execute action with automatic retry on specific exceptions
     */
    public static <T> T executeWithRetry(Supplier<T> action, String actionName) {
        int attempts = 0;
        Exception lastException = null;

        while (attempts < MAX_RETRIES) {
            try {
                logger.info("Executing: {} (attempt {}/{})", actionName, attempts + 1, MAX_RETRIES);
                return action.get();

            } catch (StaleElementReferenceException e) {
                logger.warn("StaleElementReferenceException on attempt {}: {}", attempts + 1, e.getMessage());
                lastException = e;
                attempts++;
                sleep(RETRY_DELAY_MS);

            } catch (NoSuchElementException e) {
                logger.warn("NoSuchElementException on attempt {}: {}", attempts + 1, e.getMessage());
                lastException = e;
                attempts++;
                sleep(RETRY_DELAY_MS * attempts); // Exponential backoff

            } catch (ElementClickInterceptedException e) {
                logger.warn("ElementClickInterceptedException on attempt {}: {}", attempts + 1, e.getMessage());
                lastException = e;
                attempts++;
                sleep(RETRY_DELAY_MS);
            }
        }

        throw new RuntimeException(
            String.format("Failed after %d attempts: %s", MAX_RETRIES, actionName),
            lastException
        );
    }

    /**
     * Handle specific Selenium exceptions with appropriate actions
     */
    public static void handleException(Exception e, WebDriver driver) {
        if (e instanceof TimeoutException) {
            logger.error("Timeout waiting for element/condition");
            logger.error("Current URL: {}", driver.getCurrentUrl());
            logger.error("Page title: {}", driver.getTitle());
            // Suggest: Increase wait time, check element locator, verify page load

        } else if (e instanceof NoSuchElementException) {
            logger.error("Element not found");
            logger.error("Available elements on page:");
            List<WebElement> allElements = driver.findElements(By.xpath("//*[@id or @name or @class]"));
            allElements.stream().limit(20).forEach(el ->
                logger.error("  {} - id:{} class:{} name:{}",
                    el.getTagName(),
                    el.getAttribute("id"),
                    el.getAttribute("class"),
                    el.getAttribute("name"))
            );

        } else if (e instanceof StaleElementReferenceException) {
            logger.error("Stale element reference - DOM has changed");
            logger.error("Re-locate the element before interacting with it");

        } else if (e instanceof ElementClickInterceptedException) {
            logger.error("Element click intercepted - another element is covering it");
            logger.error("Try: scroll to element, wait for overlay to close, or use JavaScript click");

        } else if (e instanceof ElementNotInteractableException) {
            logger.error("Element not interactable - may be hidden or disabled");
            logger.error("Try: wait for element to be visible, check display/visibility properties");

        } else {
            logger.error("Unhandled exception: {}", e.getClass().getSimpleName());
            logger.error("Message: {}", e.getMessage());
        }
    }

    private static void sleep(long milliseconds) {
        try {
            Thread.sleep(milliseconds);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}

// Smart Wait Strategies
public class SmartWait {
    private static final Logger logger = LoggerFactory.getLogger(SmartWait.class);
    private WebDriver driver;
    private WebDriverWait wait;

    public SmartWait(WebDriver driver, int timeoutSeconds) {
        this.driver = driver;
        this.wait = new WebDriverWait(driver, Duration.ofSeconds(timeoutSeconds));
        configureWait();
    }

    private void configureWait() {
        // Ignore specific exceptions during wait
        wait.ignoring(StaleElementReferenceException.class);
        wait.ignoring(NoSuchElementException.class);

        // Set polling interval
        wait.pollingEvery(Duration.ofMillis(500));
    }

    /**
     * Wait for element with multiple strategies
     */
    public WebElement waitForElement(By locator) {
        logger.info("Waiting for element: {}", locator);

        // Strategy 1: Wait for presence
        WebElement element = wait.until(ExpectedConditions.presenceOfElementLocated(locator));

        // Strategy 2: Wait for visibility
        wait.until(ExpectedConditions.visibilityOf(element));

        // Strategy 3: Wait for element to be clickable
        wait.until(ExpectedConditions.elementToBeClickable(element));

        logger.info("Element found and ready: {}", locator);
        return element;
    }

    /**
     * Safe click with automatic retry
     */
    public void safeClick(WebElement element) {
        ExceptionHandler.executeWithRetry(() -> {
            // Scroll element into view
            ((JavascriptExecutor) driver).executeScript(
                "arguments[0].scrollIntoView({block: 'center'});", element
            );

            // Wait a moment for scroll
            try { Thread.sleep(300); } catch (InterruptedException e) {}

            // Ensure clickable
            wait.until(ExpectedConditions.elementToBeClickable(element));

            // Perform click
            element.click();
            return null;
        }, "Click element");
    }

    /**
     * Safe sendKeys with retry
     */
    public void safeSendKeys(WebElement element, String text) {
        ExceptionHandler.executeWithRetry(() -> {
            element.clear();
            element.sendKeys(text);
            return null;
        }, "Send keys: " + text);
    }
}

// Test Listener for automatic debugging
public class DebugTestListener implements ITestListener {
    private static final Logger logger = LoggerFactory.getLogger(DebugTestListener.class);
    private ThreadLocal<DebugManager> debugManager = new ThreadLocal<>();

    @Override
    public void onTestStart(ITestResult result) {
        logger.info("Starting test: {}", result.getName());
        WebDriver driver = getDriverFromTest(result);
        if (driver != null) {
            debugManager.set(new DebugManager(driver));
        }
    }

    @Override
    public void onTestFailure(ITestResult result) {
        logger.error("Test failed: {}", result.getName());

        DebugManager debug = debugManager.get();
        if (debug != null) {
            DebugInfo debugInfo = debug.captureDebugInfo(
                result.getName(),
                result.getThrowable()
            );

            // Attach to test result for reporting
            result.setAttribute("debugInfo", debugInfo);
        }

        // Print failure analysis
        analyzeFailure(result);
    }

    /**
     * Analyze test failure and suggest fixes
     */
    private void analyzeFailure(ITestResult result) {
        Throwable error = result.getThrowable();

        logger.error("=== FAILURE ANALYSIS ===");
        logger.error("Test: {}", result.getName());
        logger.error("Error Type: {}", error.getClass().getSimpleName());
        logger.error("Error Message: {}", error.getMessage());

        // Provide suggestions based on error type
        if (error instanceof TimeoutException) {
            logger.error("Suggestion: Increase wait timeout or verify element locator");
        } else if (error instanceof NoSuchElementException) {
            logger.error("Suggestion: Check element locator, verify page has loaded");
        } else if (error instanceof StaleElementReferenceException) {
            logger.error("Suggestion: Re-locate element after page/DOM changes");
        } else if (error instanceof AssertionError) {
            logger.error("Suggestion: Verify test data and expected values");
        }

        logger.error("Stack trace:");
        error.printStackTrace();
    }

    private WebDriver getDriverFromTest(ITestResult result) {
        Object testInstance = result.getInstance();
        try {
            Field driverField = testInstance.getClass().getDeclaredField("driver");
            driverField.setAccessible(true);
            return (WebDriver) driverField.get(testInstance);
        } catch (Exception e) {
            logger.warn("Could not extract driver from test", e);
            return null;
        }
    }

    @Override
    public void onTestSuccess(ITestResult result) {
        logger.info("Test passed: {}", result.getName());
    }
}

// Test Examples with Debugging
public class DebugExampleTest {
    private WebDriver driver;
    private DebugManager debugManager;
    private SmartWait smartWait;

    @BeforeMethod
    public void setup() {
        driver = new ChromeDriver();
        debugManager = new DebugManager(driver);
        smartWait = new SmartWait(driver, 10);
    }

    @Test
    public void testWithDebugging() {
        try {
            driver.get("https://example.com");

            // Use smart wait instead of implicit wait
            WebElement searchBox = smartWait.waitForElement(By.id("search"));

            // Highlight for visual debugging
            debugManager.highlightElement(searchBox);

            // Print element details
            debugManager.printElementDetails(searchBox);

            // Safe interaction
            smartWait.safeSendKeys(searchBox, "test query");
            smartWait.safeClick(driver.findElement(By.id("search-button")));

        } catch (Exception e) {
            // Capture debug info on error
            DebugInfo debugInfo = debugManager.captureDebugInfo("testWithDebugging", e);
            ExceptionHandler.handleException(e, driver);
            throw e;
        }
    }

    @Test
    public void testWithRetry() {
        driver.get("https://example.com");

        // Execute with automatic retry
        WebElement result = ExceptionHandler.executeWithRetry(() -> {
            WebElement element = driver.findElement(By.id("dynamic-element"));
            return element.isDisplayed() ? element : null;
        }, "Find dynamic element");

        Assert.assertNotNull(result, "Element should be found");
    }

    @AfterMethod
    public void teardown() {
        if (driver != null) {
            driver.quit();
        }
    }
}
```

**Follow-up**: How do you distinguish between application bugs vs test issues? What debugging tools and techniques do you use for investigating intermittent test failures? How do you implement centralized error reporting and analysis? What metrics do you track to identify patterns in test failures?

---

### **Q100. What framework optimization strategies do you implement for large-scale test automation? Explain test execution optimization, parallel execution, resource management, and maintenance practices.** (6-8 Years, 9-12 Years)

**Difficulty**: Hard
**Companies**: Google, Amazon, Microsoft, Netflix, Uber - Scale-focused companies
**Topics**: Framework Optimization, Performance, Scalability, Best Practices

**Answer**:

Framework optimization is essential for maintaining fast, reliable, and scalable test automation. As test suites grow, optimization becomes critical for reducing execution time, improving stability, and minimizing maintenance overhead.

**Complete Optimization Framework:**

```java
// Test Execution Optimizer - Intelligently prioritize and execute tests
public class TestExecutionOptimizer {
    private static final Logger logger = LoggerFactory.getLogger(TestExecutionOptimizer.class);

    /**
     * Prioritize tests based on multiple factors
     */
    public List<String> prioritizeTests(List<TestInfo> tests) {
        // Factors: failure history, execution time, code coverage, dependencies

        return tests.stream()
            .sorted(Comparator
                .comparing(TestInfo::getFailureRate).reversed() // Run flaky tests first
                .thenComparing(TestInfo::getExecutionTime)      // Then by speed
                .thenComparing(TestInfo::getLastModified).reversed())
            .map(TestInfo::getTestName)
            .collect(Collectors.toList());
    }

    /**
     * Smart test selection - run only affected tests
     */
    public List<String> selectAffectedTests(Set<String> changedFiles,
            Map<String, Set<String>> testDependencies) {
        Set<String> affectedTests = new HashSet<>();

        for (String changedFile : changedFiles) {
            if (testDependencies.containsKey(changedFile)) {
                affectedTests.addAll(testDependencies.get(changedFile));
            }
        }

        logger.info("Changed files: {}, Affected tests: {}",
            changedFiles.size(), affectedTests.size());
        return new ArrayList<>(affectedTests);
    }
}

// Parallel Execution Manager - Optimize parallel test execution
public class ParallelExecutionManager {
    private static final int OPTIMAL_THREAD_COUNT = Runtime.getRuntime().availableProcessors() * 2;

    public static int calculateOptimalThreadCount(int totalTests, int avgTestDurationSeconds) {
        // Balance between parallelism and resource usage
        int cpuBased = OPTIMAL_THREAD_COUNT;
        int testBased = Math.min(totalTests, 20); // Max 20 parallel tests

        return Math.min(cpuBased, testBased);
    }

    /**
     * Dynamic thread pool adjustment based on system resources
     */
    public static ExecutorService createOptimizedThreadPool() {
        int threads = calculateOptimalThreadCount(100, 30);

        return new ThreadPoolExecutor(
            threads / 2,  // Core pool size
            threads,      // Max pool size
            60L, TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(),
            new ThreadFactory() {
                private AtomicInteger counter = new AtomicInteger(0);

                @Override
                public Thread newThread(Runnable r) {
                    Thread thread = new Thread(r);
                    thread.setName("Test-Thread-" + counter.incrementAndGet());
                    thread.setDaemon(true);
                    return thread;
                }
            }
        );
    }
}

// Resource Manager - Manage browser instances and cleanup
public class ResourceManager {
    private static final Logger logger = LoggerFactory.getLogger(ResourceManager.class);
    private static Map<Long, WebDriver> driverPool = new ConcurrentHashMap<>();

    public static WebDriver getDriver() {
        long threadId = Thread.currentThread().getId();

        return driverPool.computeIfAbsent(threadId, id -> {
            ChromeOptions options = new ChromeOptions();
            options.addArguments("--headless");  // Faster execution
            options.addArguments("--disable-gpu");
            options.addArguments("--no-sandbox");
            options.addArguments("--disable-dev-shm-usage");

            ChromeDriver driver = new ChromeDriver(options);
            driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));

            logger.info("Created WebDriver for thread {}", threadId);
            return driver;
        });
    }

    public static void quitDriver() {
        long threadId = Thread.currentThread().getId();
        WebDriver driver = driverPool.remove(threadId);

        if (driver != null) {
            try {
                driver.quit();
                logger.info("Quit WebDriver for thread {}", threadId);
            } catch (Exception e) {
                logger.error("Error quitting driver", e);
            }
        }
    }

    public static void quitAllDrivers() {
        logger.info("Quitting all WebDrivers...");
        driverPool.values().forEach(driver -> {
            try {
                driver.quit();
            } catch (Exception e) {
                logger.error("Error quitting driver", e);
            }
        });
        driverPool.clear();
    }
}

// Cache Manager - Cache frequently used data
public class CacheManager {
    private static Map<String, Object> cache = new ConcurrentHashMap<>();
    private static Map<String, Long> cacheTimestamps = new ConcurrentHashMap<>();
    private static final long CACHE_TTL_MS = 5 * 60 * 1000; // 5 minutes

    public static <T> T getOrCompute(String key, Supplier<T> supplier) {
        // Check if cached and not expired
        if (cache.containsKey(key)) {
            long cacheTime = cacheTimestamps.get(key);
            if (System.currentTimeMillis() - cacheTime < CACHE_TTL_MS) {
                return (T) cache.get(key);
            }
        }

        // Compute and cache
        T value = supplier.get();
        cache.put(key, value);
        cacheTimestamps.put(key, System.currentTimeMillis());

        return value;
    }

    public static void clear() {
        cache.clear();
        cacheTimestamps.clear();
    }
}

// Best Practices for Optimization
/**
 * 1. TEST DESIGN OPTIMIZATION:
 *    - Keep tests independent and atomic
 *    - Use test data factories instead of hard-coded data
 *    - Implement proper test cleanup (teardown)
 *    - Group tests logically (smoke, regression, etc.)
 *
 * 2. LOCATOR OPTIMIZATION:
 *    - Use ID locators (fastest)
 *    - Cache frequently used elements
 *    - Avoid complex XPath expressions
 *    - Use CSS selectors over XPath when possible
 *
 * 3. WAIT STRATEGY OPTIMIZATION:
 *    - Use explicit waits (avoid implicit + explicit combo)
 *    - Implement custom ExpectedConditions
 *    - Set appropriate timeout values
 *    - Use FluentWait for complex conditions
 *
 * 4. EXECUTION OPTIMIZATION:
 *    - Run tests in headless mode in CI/CD
 *    - Disable images/CSS loading for faster page loads
 *    - Use test prioritization
 *    - Implement test sharding for distributed execution
 *
 * 5. FRAMEWORK MAINTENANCE:
 *    - Regular code reviews
 *    - Automated dependency updates
 *    - Performance monitoring
 *    - Regular cleanup of obsolete tests
 */
```

**Follow-up**: How do you measure and track framework performance over time? What strategies do you use for test data management at scale? How do you handle flaky tests in large test suites? What metrics do you use to evaluate framework health and effectiveness?

---

âœ… **SELENIUM WEBDRIVER SECTION COMPLETE!** (50/50 questions - 100%)

---

# ðŸ”Œ API TESTING & REST ASSURED (40 Questions)

## REST API FUNDAMENTALS & REST ASSURED FRAMEWORK

### **Q101. Explain REST Assured framework architecture and how you implement a scalable API testing framework. Include RequestSpecification, ResponseSpecification, filters, and best practices.** (6-8 Years, 9-12 Years)

**Difficulty**: Hard
**Companies**: Amazon, Google, Microsoft, Flipkart, Paytm, Netflix, Uber
**Topics**: REST Assured Architecture, API Framework Design, Specifications, Filters

**Answer**:

REST Assured is a powerful Java library for testing REST APIs. A well-architected REST Assured framework includes reusable specifications, custom filters, serialization/deserialization strategies, and comprehensive reporting. Senior engineers must design scalable frameworks that handle authentication, logging, error handling, and test data management.

**Key Components:**

1. **RequestSpecification & ResponseSpecification**
   - Define common request configurations
   - Set base URI, authentication, headers
   - Reusable across all API tests
   - Response validation rules

2. **Filters for Cross-Cutting Concerns**
   - Request/Response logging
   - Authentication token management
   - Custom headers injection
   - Request/Response modification

3. **Serialization/Deserialization**
   - POJO to JSON conversion
   - JSON to POJO mapping
   - Custom serializers for complex objects
   - Jackson/Gson configuration

4. **Framework Architecture Layers**
   - Config layer (base URIs, timeouts)
   - Specification layer (request/response specs)
   - Service layer (API endpoints)
   - Test layer (test cases)
   - Utility layer (helpers, builders)

**Complete Implementation:**

```java
// pom.xml dependencies
/*
<dependencies>
    <!-- REST Assured -->
    <dependency>
        <groupId>io.rest-assured</groupId>
        <artifactId>rest-assured</artifactId>
        <version>5.3.0</version>
    </dependency>

    <!-- JSON Schema Validation -->
    <dependency>
        <groupId>io.rest-assured</groupId>
        <artifactId>json-schema-validator</artifactId>
        <version>5.3.0</version>
    </dependency>

    <!-- Jackson for JSON -->
    <dependency>
        <groupId>com.fasterxml.jackson.core</groupId>
        <artifactId>jackson-databind</artifactId>
        <version>2.14.2</version>
    </dependency>

    <!-- Lombok for POJOs -->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version>1.18.26</version>
        <scope>provided</scope>
    </dependency>
</dependencies>
*/

// API Configuration - Centralized configuration
public class APIConfig {
    private static final Logger logger = LoggerFactory.getLogger(APIConfig.class);
    private static Properties properties;

    static {
        loadProperties();
    }

    private static void loadProperties() {
        properties = new Properties();
        try {
            InputStream input = APIConfig.class.getClassLoader()
                .getResourceAsStream("api-config.properties");
            properties.load(input);
            logger.info("API configuration loaded successfully");
        } catch (IOException e) {
            logger.error("Failed to load API configuration", e);
            throw new RuntimeException("Cannot load API configuration", e);
        }
    }

    public static String getBaseURI() {
        return properties.getProperty("api.base.uri", "https://api.example.com");
    }

    public static String getBasePath() {
        return properties.getProperty("api.base.path", "/v1");
    }

    public static int getPort() {
        return Integer.parseInt(properties.getProperty("api.port", "443"));
    }

    public static int getConnectionTimeout() {
        return Integer.parseInt(properties.getProperty("api.connection.timeout", "30000"));
    }

    public static int getSocketTimeout() {
        return Integer.parseInt(properties.getProperty("api.socket.timeout", "30000"));
    }

    public static String getAuthToken() {
        return properties.getProperty("api.auth.token", "");
    }

    public static String getEnvironment() {
        return properties.getProperty("environment", "qa");
    }
}

// Specification Builder - Build RequestSpecification and ResponseSpecification
public class SpecificationBuilder {
    private static final Logger logger = LoggerFactory.getLogger(SpecificationBuilder.class);

    /**
     * Build base RequestSpecification
     */
    public static RequestSpecification getBaseRequestSpec() {
        return new RequestSpecBuilder()
            .setBaseUri(APIConfig.getBaseURI())
            .setBasePath(APIConfig.getBasePath())
            .setPort(APIConfig.getPort())
            .setContentType(ContentType.JSON)
            .setAccept(ContentType.JSON)
            .addHeader("User-Agent", "API-Automation-Framework/1.0")
            .setConfig(getRestAssuredConfig())
            .addFilter(new RequestLoggingFilter())
            .addFilter(new ResponseLoggingFilter())
            .addFilter(new AllureRestAssuredFilter())
            .build();
    }

    /**
     * Build RequestSpecification with authentication
     */
    public static RequestSpecification getAuthenticatedRequestSpec() {
        String token = APIConfig.getAuthToken();

        return new RequestSpecBuilder()
            .addRequestSpecification(getBaseRequestSpec())
            .addHeader("Authorization", "Bearer " + token)
            .build();
    }

    /**
     * Build RequestSpecification with custom headers
     */
    public static RequestSpecification getRequestSpecWithHeaders(Map<String, String> headers) {
        RequestSpecBuilder builder = new RequestSpecBuilder()
            .addRequestSpecification(getBaseRequestSpec());

        headers.forEach(builder::addHeader);

        return builder.build();
    }

    /**
     * Build common ResponseSpecification
     */
    public static ResponseSpecification getSuccessResponseSpec() {
        return new ResponseSpecBuilder()
            .expectStatusCode(200)
            .expectContentType(ContentType.JSON)
            .expectResponseTime(lessThan(5000L))
            .build();
    }

    /**
     * Build ResponseSpecification for created resources
     */
    public static ResponseSpecification getCreatedResponseSpec() {
        return new ResponseSpecBuilder()
            .expectStatusCode(201)
            .expectContentType(ContentType.JSON)
            .expectResponseTime(lessThan(5000L))
            .build();
    }

    /**
     * Configure REST Assured settings
     */
    private static RestAssuredConfig getRestAssuredConfig() {
        return RestAssuredConfig.config()
            .httpClient(HttpClientConfig.httpClientConfig()
                .setParam(CoreConnectionPNames.CONNECTION_TIMEOUT,
                    APIConfig.getConnectionTimeout())
                .setParam(CoreConnectionPNames.SO_TIMEOUT,
                    APIConfig.getSocketTimeout()))
            .objectMapperConfig(ObjectMapperConfig.objectMapperConfig()
                .jackson2ObjectMapperFactory((cls, charset) -> {
                    ObjectMapper mapper = new ObjectMapper();
                    mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
                    mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
                    return mapper;
                }))
            .encoderConfig(EncoderConfig.encoderConfig()
                .appendDefaultContentCharsetToContentTypeIfUndefined(false))
            .logConfig(LogConfig.logConfig()
                .enableLoggingOfRequestAndResponseIfValidationFails()
                .enablePrettyPrinting(true));
    }
}

// Custom Filters for Cross-Cutting Concerns

// Request Logging Filter
public class RequestLoggingFilter implements Filter {
    private static final Logger logger = LoggerFactory.getLogger(RequestLoggingFilter.class);

    @Override
    public Response filter(FilterableRequestSpecification requestSpec,
            FilterableResponseSpecification responseSpec, FilterContext ctx) {

        logger.info("=== API REQUEST ===");
        logger.info("Method: {}", requestSpec.getMethod());
        logger.info("URI: {}", requestSpec.getURI());
        logger.info("Headers: {}", requestSpec.getHeaders());

        if (requestSpec.getBody() != null) {
            logger.info("Request Body: {}", requestSpec.getBody());
        }

        return ctx.next(requestSpec, responseSpec);
    }
}

// Response Logging Filter
public class ResponseLoggingFilter implements Filter {
    private static final Logger logger = LoggerFactory.getLogger(ResponseLoggingFilter.class);

    @Override
    public Response filter(FilterableRequestSpecification requestSpec,
            FilterableResponseSpecification responseSpec, FilterContext ctx) {

        Response response = ctx.next(requestSpec, responseSpec);

        logger.info("=== API RESPONSE ===");
        logger.info("Status Code: {}", response.getStatusCode());
        logger.info("Status Line: {}", response.getStatusLine());
        logger.info("Headers: {}", response.getHeaders());
        logger.info("Response Time: {}ms", response.getTime());

        if (response.getBody() != null) {
            logger.info("Response Body: {}", response.getBody().asString());
        }

        return response;
    }
}

// Authentication Filter - Automatically inject auth token
public class AuthenticationFilter implements Filter {
    private static final Logger logger = LoggerFactory.getLogger(AuthenticationFilter.class);
    private TokenManager tokenManager;

    public AuthenticationFilter(TokenManager tokenManager) {
        this.tokenManager = tokenManager;
    }

    @Override
    public Response filter(FilterableRequestSpecification requestSpec,
            FilterableResponseSpecification responseSpec, FilterContext ctx) {

        // Get fresh token
        String token = tokenManager.getValidToken();

        // Inject authorization header
        requestSpec.header("Authorization", "Bearer " + token);

        logger.debug("Injected auth token: {}", token.substring(0, 20) + "...");

        return ctx.next(requestSpec, responseSpec);
    }
}

// Token Manager - Manage authentication tokens
public class TokenManager {
    private static final Logger logger = LoggerFactory.getLogger(TokenManager.class);
    private static TokenManager instance;
    private String currentToken;
    private LocalDateTime tokenExpiry;

    private TokenManager() {}

    public static synchronized TokenManager getInstance() {
        if (instance == null) {
            instance = new TokenManager();
        }
        return instance;
    }

    /**
     * Get valid token, refresh if expired
     */
    public synchronized String getValidToken() {
        if (currentToken == null || isTokenExpired()) {
            refreshToken();
        }
        return currentToken;
    }

    /**
     * Check if token is expired
     */
    private boolean isTokenExpired() {
        if (tokenExpiry == null) {
            return true;
        }
        return LocalDateTime.now().isAfter(tokenExpiry.minusMinutes(5)); // Refresh 5 min before expiry
    }

    /**
     * Refresh authentication token
     */
    private void refreshToken() {
        logger.info("Refreshing authentication token...");

        Response response = given()
            .contentType(ContentType.JSON)
            .body(new LoginRequest("api_user", "api_password"))
            .when()
            .post(APIConfig.getBaseURI() + "/auth/login");

        if (response.getStatusCode() == 200) {
            LoginResponse loginResponse = response.as(LoginResponse.class);
            this.currentToken = loginResponse.getToken();
            this.tokenExpiry = LocalDateTime.now().plusHours(1); // Token valid for 1 hour

            logger.info("Token refreshed successfully. Expires at: {}", tokenExpiry);
        } else {
            logger.error("Failed to refresh token. Status: {}", response.getStatusCode());
            throw new RuntimeException("Token refresh failed");
        }
    }

    public void clearToken() {
        this.currentToken = null;
        this.tokenExpiry = null;
    }
}

// Base API Service - Parent class for all API services
public abstract class BaseAPIService {
    protected static final Logger logger = LoggerFactory.getLogger(BaseAPIService.class);
    protected RequestSpecification requestSpec;
    protected ResponseSpecification responseSpec;

    public BaseAPIService() {
        this.requestSpec = SpecificationBuilder.getAuthenticatedRequestSpec();
        this.responseSpec = SpecificationBuilder.getSuccessResponseSpec();
    }

    /**
     * Execute GET request
     */
    protected Response get(String endpoint) {
        logger.info("GET: {}", endpoint);
        return given()
            .spec(requestSpec)
            .when()
            .get(endpoint)
            .then()
            .spec(responseSpec)
            .extract()
            .response();
    }

    /**
     * Execute GET request with path parameters
     */
    protected Response get(String endpoint, Map<String, Object> pathParams) {
        logger.info("GET: {} with params: {}", endpoint, pathParams);
        return given()
            .spec(requestSpec)
            .pathParams(pathParams)
            .when()
            .get(endpoint)
            .then()
            .spec(responseSpec)
            .extract()
            .response();
    }

    /**
     * Execute POST request
     */
    protected Response post(String endpoint, Object body) {
        logger.info("POST: {}", endpoint);
        return given()
            .spec(requestSpec)
            .body(body)
            .when()
            .post(endpoint)
            .then()
            .extract()
            .response();
    }

    /**
     * Execute PUT request
     */
    protected Response put(String endpoint, Object body) {
        logger.info("PUT: {}", endpoint);
        return given()
            .spec(requestSpec)
            .body(body)
            .when()
            .put(endpoint)
            .then()
            .extract()
            .response();
    }

    /**
     * Execute DELETE request
     */
    protected Response delete(String endpoint) {
        logger.info("DELETE: {}", endpoint);
        return given()
            .spec(requestSpec)
            .when()
            .delete(endpoint)
            .then()
            .extract()
            .response();
    }

    /**
     * Execute PATCH request
     */
    protected Response patch(String endpoint, Object body) {
        logger.info("PATCH: {}", endpoint);
        return given()
            .spec(requestSpec)
            .body(body)
            .when()
            .patch(endpoint)
            .then()
            .extract()
            .response();
    }
}

// Example API Service - Users API
public class UsersAPIService extends BaseAPIService {
    private static final String USERS_ENDPOINT = "/users";

    /**
     * Get all users
     */
    public List<User> getAllUsers() {
        Response response = get(USERS_ENDPOINT);

        return Arrays.asList(response.as(User[].class));
    }

    /**
     * Get user by ID
     */
    public User getUserById(int userId) {
        Response response = get(USERS_ENDPOINT + "/{id}",
            Map.of("id", userId));

        return response.as(User.class);
    }

    /**
     * Create new user
     */
    public User createUser(User user) {
        Response response = post(USERS_ENDPOINT, user);

        Assert.assertEquals(response.getStatusCode(), 201,
            "User creation should return 201");

        return response.as(User.class);
    }

    /**
     * Update user
     */
    public User updateUser(int userId, User user) {
        Response response = put(USERS_ENDPOINT + "/{id}",
            Map.of("id", userId), user);

        return response.as(User.class);
    }

    /**
     * Delete user
     */
    public void deleteUser(int userId) {
        Response response = delete(USERS_ENDPOINT + "/{id}",
            Map.of("id", userId));

        Assert.assertEquals(response.getStatusCode(), 204,
            "User deletion should return 204");
    }

    /**
     * Search users with query parameters
     */
    public List<User> searchUsers(Map<String, String> queryParams) {
        Response response = given()
            .spec(requestSpec)
            .queryParams(queryParams)
            .when()
            .get(USERS_ENDPOINT)
            .then()
            .spec(responseSpec)
            .extract()
            .response();

        return Arrays.asList(response.as(User[].class));
    }
}

// POJO Models with Lombok
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class User {
    private Integer id;

    @JsonProperty("first_name")
    private String firstName;

    @JsonProperty("last_name")
    private String lastName;

    private String email;
    private String phone;
    private Address address;

    @JsonProperty("created_at")
    private String createdAt;

    @JsonProperty("updated_at")
    private String updatedAt;
}

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Address {
    private String street;
    private String city;
    private String state;

    @JsonProperty("zip_code")
    private String zipCode;

    private String country;
}

// Test Data Builder - Generate test data
public class UserTestDataBuilder {
    private static final Faker faker = new Faker();

    public static User createRandomUser() {
        return User.builder()
            .firstName(faker.name().firstName())
            .lastName(faker.name().lastName())
            .email(faker.internet().emailAddress())
            .phone(faker.phoneNumber().phoneNumber())
            .address(createRandomAddress())
            .build();
    }

    public static Address createRandomAddress() {
        return Address.builder()
            .street(faker.address().streetAddress())
            .city(faker.address().city())
            .state(faker.address().state())
            .zipCode(faker.address().zipCode())
            .country("USA")
            .build();
    }

    public static User createUserWithEmail(String email) {
        User user = createRandomUser();
        user.setEmail(email);
        return user;
    }
}

// Test Examples
public class UsersAPITest {
    private UsersAPIService usersAPI;

    @BeforeClass
    public void setup() {
        usersAPI = new UsersAPIService();
    }

    @Test(description = "Verify creating a new user")
    public void testCreateUser() {
        // Arrange
        User newUser = UserTestDataBuilder.createRandomUser();

        // Act
        User createdUser = usersAPI.createUser(newUser);

        // Assert
        Assert.assertNotNull(createdUser.getId(), "Created user should have ID");
        Assert.assertEquals(createdUser.getEmail(), newUser.getEmail());
        Assert.assertNotNull(createdUser.getCreatedAt(), "Created timestamp should exist");
    }

    @Test(description = "Verify getting user by ID")
    public void testGetUserById() {
        // Create a user first
        User newUser = usersAPI.createUser(UserTestDataBuilder.createRandomUser());

        // Get the user by ID
        User fetchedUser = usersAPI.getUserById(newUser.getId());

        // Assert
        Assert.assertEquals(fetchedUser.getId(), newUser.getId());
        Assert.assertEquals(fetchedUser.getEmail(), newUser.getEmail());
    }

    @Test(description = "Verify updating user details")
    public void testUpdateUser() {
        // Create user
        User user = usersAPI.createUser(UserTestDataBuilder.createRandomUser());

        // Update user
        user.setFirstName("Updated");
        user.setLastName("Name");
        User updatedUser = usersAPI.updateUser(user.getId(), user);

        // Assert
        Assert.assertEquals(updatedUser.getFirstName(), "Updated");
        Assert.assertEquals(updatedUser.getLastName(), "Name");
    }

    @Test(description = "Verify deleting a user")
    public void testDeleteUser() {
        // Create user
        User user = usersAPI.createUser(UserTestDataBuilder.createRandomUser());

        // Delete user
        usersAPI.deleteUser(user.getId());

        // Verify user is deleted (should get 404)
        given()
            .spec(SpecificationBuilder.getAuthenticatedRequestSpec())
            .when()
            .get("/users/{id}", user.getId())
            .then()
            .statusCode(404);
    }

    @Test(description = "Verify searching users with filters")
    public void testSearchUsers() {
        Map<String, String> searchParams = new HashMap<>();
        searchParams.put("city", "New York");
        searchParams.put("state", "NY");

        List<User> users = usersAPI.searchUsers(searchParams);

        Assert.assertFalse(users.isEmpty(), "Should find users in New York");
        users.forEach(user ->
            Assert.assertEquals(user.getAddress().getCity(), "New York")
        );
    }
}
```

**Follow-up**: How do you handle API versioning in your framework? What strategies do you use for managing test data dependencies between API tests? How do you implement retry logic for flaky API calls? How do you handle rate limiting and throttling in API tests?

---

### **Q102. How do you implement comprehensive JSON and XML validation in REST Assured? Explain JsonPath, XmlPath, schema validation, and custom matchers.** (6-8 Years, 9-12 Years)

**Difficulty**: Hard
**Companies**: Amazon, Google, Microsoft, Flipkart, Netflix, Adobe, Salesforce
**Topics**: JSON Validation, XML Validation, JsonPath, Schema Validation, Custom Matchers

**Answer**:

Comprehensive response validation is crucial for API testing. REST Assured provides powerful tools for validating JSON and XML responses including JsonPath/XmlPath for data extraction, JSON Schema validation, Hamcrest matchers, and support for custom validation logic.

**Key Validation Techniques:**

1. **JsonPath & XmlPath**
   - Extract values from responses
   - Navigate nested structures
   - Support for GPath expressions
   - Filter and query collections

2. **JSON Schema Validation**
   - Validate response structure
   - Ensure data types and formats
   - Required vs optional fields
   - Custom schema definitions

3. **Hamcrest Matchers**
   - Built-in matchers for common validations
   - Custom matcher creation
   - Combining multiple matchers
   - Descriptive assertion messages

4. **Deep Validation Strategies**
   - Nested object validation
   - Array/Collection validation
   - Dynamic response validation
   - Conditional validation

**Complete Implementation:**

```java
// pom.xml - Add schema validation dependency
/*
<dependency>
    <groupId>io.rest-assured</groupId>
    <artifactId>json-schema-validator</artifactId>
    <version>5.3.0</version>
</dependency>
*/

// JSON Validation Helper
public class JSONValidationHelper {
    private static final Logger logger = LoggerFactory.getLogger(JSONValidationHelper.class);

    /**
     * Validate JSON response using JsonPath
     */
    public static void validateWithJsonPath(Response response) {
        JsonPath jsonPath = response.jsonPath();

        // Extract and validate simple values
        String name = jsonPath.getString("name");
        Assert.assertNotNull(name, "Name should not be null");

        int id = jsonPath.getInt("id");
        Assert.assertTrue(id > 0, "ID should be positive");

        // Extract from nested objects
        String city = jsonPath.getString("address.city");
        String zipCode = jsonPath.getString("address.zipCode");

        // Extract from arrays
        List<String> tags = jsonPath.getList("tags");
        Assert.assertFalse(tags.isEmpty(), "Tags should not be empty");

        // Extract specific array element
        String firstName = jsonPath.getString("users[0].firstName");

        // Filter and find
        List<String> activeUserNames = jsonPath.getList(
            "users.findAll { it.status == 'active' }.name"
        );
        logger.info("Active users: {}", activeUserNames);
    }

    /**
     * Validate using inline assertions (fluent style)
     */
    public static void validateInline(Response response) {
        response.then()
            .assertThat()
            .statusCode(200)
            .contentType(ContentType.JSON)
            .body("id", notNullValue())
            .body("name", equalTo("John Doe"))
            .body("email", containsString("@example.com"))
            .body("age", greaterThan(18))
            .body("age", lessThan(100))
            .body("address.city", equalTo("New York"))
            .body("address.zipCode", matchesPattern("\\d{5}"))
            .body("tags", hasSize(greaterThan(0)))
            .body("tags", hasItem("premium"))
            .body("tags", hasItems("premium", "verified"))
            .body("roles[0].name", equalTo("admin"))
            .body("metadata.createdAt", notNullValue())
            .body("metadata.updatedAt", notNullValue());
    }

    /**
     * Validate JSON Schema
     */
    public static void validateJsonSchema(Response response, String schemaPath) {
        response.then()
            .assertThat()
            .body(matchesJsonSchemaInClasspath(schemaPath));

        logger.info("JSON schema validation passed: {}", schemaPath);
    }

    /**
     * Validate array contents
     */
    public static void validateArrayContents(Response response, String arrayPath) {
        List<Map<String, Object>> items = response.jsonPath().getList(arrayPath);

        // Validate each item in array
        for (Map<String, Object> item : items) {
            Assert.assertNotNull(item.get("id"), "Each item should have ID");
            Assert.assertNotNull(item.get("name"), "Each item should have name");
        }

        // Using Hamcrest matchers
        response.then()
            .body(arrayPath, everyItem(hasKey("id")))
            .body(arrayPath, everyItem(hasKey("name")))
            .body(arrayPath + ".id", everyItem(notNullValue()))
            .body(arrayPath + ".name", everyItem(not(emptyString())));
    }

    /**
     * Validate nested objects
     */
    public static void validateNestedObject(Response response) {
        response.then()
            .body("user.profile.firstName", notNullValue())
            .body("user.profile.lastName", notNullValue())
            .body("user.profile.age", greaterThanOrEqualTo(18))
            .body("user.settings.notifications", equalTo(true))
            .body("user.settings.theme", anyOf(equalTo("light"), equalTo("dark")))
            .body("user.preferences.language", isIn(Arrays.asList("en", "es", "fr")));
    }

    /**
     * Extract and validate with custom logic
     */
    public static void customValidation(Response response) {
        JsonPath jsonPath = response.jsonPath();

        // Extract list of objects
        List<Map<String, Object>> users = jsonPath.getList("users");

        // Custom business logic validation
        long activeUsers = users.stream()
            .filter(u -> "active".equals(u.get("status")))
            .count();

        Assert.assertTrue(activeUsers > 0, "Should have at least one active user");

        // Validate sum of values
        int totalAge = users.stream()
            .mapToInt(u -> (Integer) u.get("age"))
            .sum();

        Assert.assertTrue(totalAge > 0, "Total age should be positive");

        // Check for duplicates
        List<String> emails = jsonPath.getList("users.email");
        Set<String> uniqueEmails = new HashSet<>(emails);
        Assert.assertEquals(emails.size(), uniqueEmails.size(),
            "Emails should be unique");
    }
}

// JSON Schema Validator
public class SchemaValidator {
    private static final String SCHEMA_BASE_PATH = "schemas/";

    /**
     * Validate response against JSON schema file
     */
    public static void validateSchema(Response response, String schemaFileName) {
        String schemaPath = SCHEMA_BASE_PATH + schemaFileName;

        response.then()
            .assertThat()
            .body(matchesJsonSchemaInClasspath(schemaPath));
    }

    /**
     * Validate with custom schema settings
     */
    public static void validateSchemaWithSettings(Response response, String schemaPath) {
        JsonSchemaFactory factory = JsonSchemaFactory.newBuilder()
            .setValidationConfiguration(
                ValidationConfiguration.newBuilder()
                    .setDefaultVersion(SchemaVersion.DRAFTV4)
                    .freeze()
            )
            .freeze();

        response.then()
            .assertThat()
            .body(matchesJsonSchemaInClasspath(schemaPath)
                .using(factory));
    }

    /**
     * Create and validate dynamic schema
     */
    public static void validateWithDynamicSchema(Response response) {
        String schema = """
            {
              "$schema": "http://json-schema.org/draft-04/schema#",
              "type": "object",
              "properties": {
                "id": {"type": "integer", "minimum": 1},
                "name": {"type": "string", "minLength": 1},
                "email": {"type": "string", "format": "email"},
                "age": {"type": "integer", "minimum": 0, "maximum": 150},
                "active": {"type": "boolean"},
                "tags": {
                  "type": "array",
                  "items": {"type": "string"},
                  "minItems": 1
                },
                "address": {
                  "type": "object",
                  "properties": {
                    "street": {"type": "string"},
                    "city": {"type": "string"},
                    "zipCode": {"type": "string", "pattern": "^\\\\d{5}$"}
                  },
                  "required": ["city", "zipCode"]
                }
              },
              "required": ["id", "name", "email"]
            }
            """;

        response.then()
            .assertThat()
            .body(matchesJsonSchema(schema));
    }
}

// Custom Hamcrest Matchers
public class CustomMatchers {

    /**
     * Custom matcher for validating email format
     */
    public static Matcher<String> validEmail() {
        return new TypeSafeMatcher<String>() {
            @Override
            protected boolean matchesSafely(String email) {
                return email != null && email.matches("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+$");
            }

            @Override
            public void describeTo(Description description) {
                description.appendText("a valid email address");
            }
        };
    }

    /**
     * Custom matcher for phone number validation
     */
    public static Matcher<String> validPhoneNumber() {
        return new TypeSafeMatcher<String>() {
            @Override
            protected boolean matchesSafely(String phone) {
                return phone != null && phone.matches("^\\+?[1-9]\\d{1,14}$");
            }

            @Override
            public void describeTo(Description description) {
                description.appendText("a valid phone number");
            }
        };
    }

    /**
     * Custom matcher for date format validation
     */
    public static Matcher<String> validISODate() {
        return new TypeSafeMatcher<String>() {
            @Override
            protected boolean matchesSafely(String date) {
                try {
                    LocalDateTime.parse(date, DateTimeFormatter.ISO_DATE_TIME);
                    return true;
                } catch (Exception e) {
                    return false;
                }
            }

            @Override
            public void describeTo(Description description) {
                description.appendText("a valid ISO 8601 date");
            }
        };
    }

    /**
     * Custom matcher for validating list contains unique items
     */
    public static Matcher<List<?>> hasUniqueItems() {
        return new TypeSafeMatcher<List<?>>() {
            @Override
            protected boolean matchesSafely(List<?> list) {
                return list.size() == new HashSet<>(list).size();
            }

            @Override
            public void describeTo(Description description) {
                description.appendText("a list with unique items");
            }
        };
    }

    /**
     * Custom matcher for validating object has all required fields
     */
    public static Matcher<Map<String, Object>> hasRequiredFields(String... fields) {
        return new TypeSafeMatcher<Map<String, Object>>() {
            @Override
            protected boolean matchesSafely(Map<String, Object> map) {
                for (String field : fields) {
                    if (!map.containsKey(field) || map.get(field) == null) {
                        return false;
                    }
                }
                return true;
            }

            @Override
            public void describeTo(Description description) {
                description.appendText("an object with required fields: " +
                    Arrays.toString(fields));
            }
        };
    }
}

// XML Validation Helper
public class XMLValidationHelper {
    private static final Logger logger = LoggerFactory.getLogger(XMLValidationHelper.class);

    /**
     * Validate XML response using XmlPath
     */
    public static void validateWithXmlPath(Response response) {
        XmlPath xmlPath = response.xmlPath();

        // Extract simple values
        String name = xmlPath.getString("user.name");
        int id = xmlPath.getInt("user.@id"); // Attribute

        // Extract from nested elements
        String city = xmlPath.getString("user.address.city");

        // Extract list of elements
        List<String> tags = xmlPath.getList("user.tags.tag");

        // Using XPath expressions
        String email = xmlPath.getString("//user/email");
        List<String> activeUsers = xmlPath.getList("//user[@status='active']/name");

        logger.info("Extracted XML data - Name: {}, City: {}", name, city);
    }

    /**
     * Validate XML inline
     */
    public static void validateXmlInline(Response response) {
        response.then()
            .assertThat()
            .contentType(ContentType.XML)
            .body("user.name", equalTo("John Doe"))
            .body("user.@id", equalTo("123"))
            .body("user.address.city", equalTo("New York"))
            .body("user.tags.tag", hasSize(greaterThan(0)))
            .body("user.tags.tag[0]", equalTo("premium"));
    }

    /**
     * Validate XML schema (XSD)
     */
    public static void validateXmlSchema(Response response, String xsdPath) {
        response.then()
            .assertThat()
            .body(matchesXsdInClasspath(xsdPath));
    }
}

// Response Assertion Helper - Combines multiple validation strategies
public class ResponseAssertionHelper {

    /**
     * Comprehensive response validation
     */
    public static void validateResponse(Response response,
            int expectedStatus,
            String schemaPath,
            Map<String, Object> expectedValues) {

        // Status code validation
        Assert.assertEquals(response.getStatusCode(), expectedStatus,
            "Status code mismatch");

        // Content type validation
        Assert.assertTrue(
            response.getContentType().contains("application/json"),
            "Content type should be JSON"
        );

        // Response time validation
        Assert.assertTrue(response.getTime() < 5000,
            "Response time should be less than 5 seconds");

        // Schema validation
        if (schemaPath != null) {
            SchemaValidator.validateSchema(response, schemaPath);
        }

        // Field validation
        if (expectedValues != null) {
            JsonPath jsonPath = response.jsonPath();
            expectedValues.forEach((key, expectedValue) -> {
                Object actualValue = jsonPath.get(key);
                Assert.assertEquals(actualValue, expectedValue,
                    "Value mismatch for field: " + key);
            });
        }
    }

    /**
     * Validate pagination response
     */
    public static void validatePaginatedResponse(Response response) {
        response.then()
            .body("page", notNullValue())
            .body("page.number", greaterThanOrEqualTo(0))
            .body("page.size", greaterThan(0))
            .body("page.totalElements", greaterThanOrEqualTo(0))
            .body("page.totalPages", greaterThanOrEqualTo(0))
            .body("data", notNullValue())
            .body("data", instanceOf(List.class));

        JsonPath jsonPath = response.jsonPath();
        int pageSize = jsonPath.getInt("page.size");
        List<?> data = jsonPath.getList("data");

        Assert.assertTrue(data.size() <= pageSize,
            "Data size should not exceed page size");
    }

    /**
     * Validate error response
     */
    public static void validateErrorResponse(Response response,
            int expectedStatus,
            String expectedErrorCode) {

        response.then()
            .statusCode(expectedStatus)
            .body("error", notNullValue())
            .body("error.code", equalTo(expectedErrorCode))
            .body("error.message", notNullValue())
            .body("error.timestamp", CustomMatchers.validISODate());
    }
}

// Test Examples
public class JSONValidationTest {

    @Test(description = "Validate user response with JsonPath")
    public void testJsonPathValidation() {
        Response response = given()
            .spec(SpecificationBuilder.getAuthenticatedRequestSpec())
            .when()
            .get("/users/1");

        // Method 1: Extract and assert
        JsonPath jsonPath = response.jsonPath();
        Assert.assertEquals(jsonPath.getInt("id"), 1);
        Assert.assertNotNull(jsonPath.getString("email"));

        // Method 2: Inline assertions
        response.then()
            .body("id", equalTo(1))
            .body("email", notNullValue())
            .body("firstName", not(emptyString()))
            .body("age", greaterThan(0));
    }

    @Test(description = "Validate with JSON Schema")
    public void testJsonSchemaValidation() {
        Response response = given()
            .spec(SpecificationBuilder.getAuthenticatedRequestSpec())
            .when()
            .get("/users/1");

        // Validate against schema file
        SchemaValidator.validateSchema(response, "user-schema.json");
    }

    @Test(description = "Validate array response")
    public void testArrayValidation() {
        Response response = given()
            .spec(SpecificationBuilder.getAuthenticatedRequestSpec())
            .when()
            .get("/users");

        response.then()
            .body("", hasSize(greaterThan(0)))
            .body("id", everyItem(greaterThan(0)))
            .body("email", everyItem(CustomMatchers.validEmail()))
            .body("email", CustomMatchers.hasUniqueItems());
    }

    @Test(description = "Validate nested objects")
    public void testNestedObjectValidation() {
        Response response = given()
            .spec(SpecificationBuilder.getAuthenticatedRequestSpec())
            .when()
            .get("/users/1");

        response.then()
            .body("address", notNullValue())
            .body("address.city", notNullValue())
            .body("address.zipCode", matchesPattern("\\d{5}"))
            .body("profile.age", greaterThan(0))
            .body("profile.createdAt", CustomMatchers.validISODate());
    }

    @Test(description = "Validate with custom matchers")
    public void testCustomMatchers() {
        Response response = given()
            .spec(SpecificationBuilder.getAuthenticatedRequestSpec())
            .when()
            .get("/users/1");

        response.then()
            .body("email", CustomMatchers.validEmail())
            .body("phone", CustomMatchers.validPhoneNumber())
            .body("createdAt", CustomMatchers.validISODate());

        // Validate object has required fields
        Map<String, Object> user = response.as(new TypeRef<Map<String, Object>>() {});
        assertThat(user, CustomMatchers.hasRequiredFields("id", "email", "firstName"));
    }

    @Test(description = "Validate XML response")
    public void testXmlValidation() {
        Response response = given()
            .spec(SpecificationBuilder.getBaseRequestSpec())
            .accept(ContentType.XML)
            .when()
            .get("/users/1.xml");

        response.then()
            .contentType(ContentType.XML)
            .body("user.name", equalTo("John Doe"))
            .body("user.@id", equalTo("1"))
            .body("user.email", CustomMatchers.validEmail());
    }

    @Test(description = "Comprehensive response validation")
    public void testComprehensiveValidation() {
        Response response = given()
            .spec(SpecificationBuilder.getAuthenticatedRequestSpec())
            .when()
            .get("/users/1");

        Map<String, Object> expectedValues = new HashMap<>();
        expectedValues.put("id", 1);
        expectedValues.put("status", "active");

        ResponseAssertionHelper.validateResponse(
            response,
            200,
            "user-schema.json",
            expectedValues
        );
    }
}
```

**Follow-up**: How do you handle schema evolution and versioning in API tests? What strategies do you use for validating dynamic or conditional responses? How do you implement soft assertions for multiple validations? How do you create reusable validation utilities for common response patterns?

---

### **Q103. Explain different authentication mechanisms in REST APIs and how you implement them in REST Assured. Cover OAuth 2.0, JWT, API Keys, Basic Auth, and Bearer tokens.** (6-8 Years, 9-12 Years)

**Difficulty**: Hard
**Companies**: Amazon, Google, Microsoft, Flipkart, Paytm, PhonePe, Netflix, Uber
**Topics**: Authentication, OAuth 2.0, JWT, API Security, Token Management

**Answer**:

API authentication is critical for secure API testing. Modern APIs use various authentication mechanisms including OAuth 2.0, JWT (JSON Web Tokens), API Keys, Basic Authentication, and Bearer tokens. Senior engineers must implement robust authentication handling with token management, refresh mechanisms, and proper security practices.

**Key Authentication Types:**

1. **Basic Authentication** - Username and password encoded in Base64
2. **Bearer Token** - Token passed in Authorization header
3. **API Key** - Key passed in header or query parameter
4. **OAuth 2.0** - Authorization framework with multiple grant types
5. **JWT** - Self-contained tokens with claims
6. **OAuth 2.0 + JWT** - Combined approach (most common)

**Complete Implementation:**

```java
// Authentication Manager - Handles all authentication types
public class AuthenticationManager {
    private static final Logger logger = LoggerFactory.getLogger(AuthenticationManager.class);

    /**
     * Basic Authentication
     */
    public static RequestSpecification withBasicAuth(String username, String password) {
        return new RequestSpecBuilder()
            .addRequestSpecification(SpecificationBuilder.getBaseRequestSpec())
            .setAuth(RestAssured.basic(username, password))
            .build();
    }

    /**
     * Preemptive Basic Auth (sends credentials without challenge)
     */
    public static RequestSpecification withPreemptiveBasicAuth(String username, String password) {
        return new RequestSpecBuilder()
            .addRequestSpecification(SpecificationBuilder.getBaseRequestSpec())
            .setAuth(RestAssured.preemptive().basic(username, password))
            .build();
    }

    /**
     * Bearer Token Authentication
     */
    public static RequestSpecification withBearerToken(String token) {
        return new RequestSpecBuilder()
            .addRequestSpecification(SpecificationBuilder.getBaseRequestSpec())
            .addHeader("Authorization", "Bearer " + token)
            .build();
    }

    /**
     * API Key in Header
     */
    public static RequestSpecification withAPIKeyHeader(String headerName, String apiKey) {
        return new RequestSpecBuilder()
            .addRequestSpecification(SpecificationBuilder.getBaseRequestSpec())
            .addHeader(headerName, apiKey)
            .build();
    }

    /**
     * API Key as Query Parameter
     */
    public static RequestSpecification withAPIKeyParam(String paramName, String apiKey) {
        return new RequestSpecBuilder()
            .addRequestSpecification(SpecificationBuilder.getBaseRequestSpec())
            .addQueryParam(paramName, apiKey)
            .build();
    }

    /**
     * OAuth 2.0 - Authorization Code Flow
     */
    public static String getOAuth2Token(String clientId, String clientSecret,
            String authorizationCode, String redirectUri, String tokenEndpoint) {

        Response response = given()
            .contentType(ContentType.URLENC)
            .formParam("grant_type", "authorization_code")
            .formParam("client_id", clientId)
            .formParam("client_secret", clientSecret)
            .formParam("code", authorizationCode)
            .formParam("redirect_uri", redirectUri)
            .when()
            .post(tokenEndpoint);

        return response.jsonPath().getString("access_token");
    }

    /**
     * OAuth 2.0 - Client Credentials Flow
     */
    public static OAuthTokenResponse getClientCredentialsToken(String clientId,
            String clientSecret, String tokenEndpoint) {

        Response response = given()
            .contentType(ContentType.URLENC)
            .formParam("grant_type", "client_credentials")
            .formParam("client_id", clientId)
            .formParam("client_secret", clientSecret)
            .when()
            .post(tokenEndpoint);

        return response.as(OAuthTokenResponse.class);
    }

    /**
     * OAuth 2.0 - Password Grant (Resource Owner Password Credentials)
     */
    public static OAuthTokenResponse getPasswordGrantToken(String clientId,
            String clientSecret, String username, String password, String tokenEndpoint) {

        Response response = given()
            .contentType(ContentType.URLENC)
            .formParam("grant_type", "password")
            .formParam("client_id", clientId)
            .formParam("client_secret", clientSecret)
            .formParam("username", username)
            .formParam("password", password)
            .when()
            .post(tokenEndpoint);

        return response.as(OAuthTokenResponse.class);
    }

    /**
     * OAuth 2.0 - Refresh Token
     */
    public static OAuthTokenResponse refreshToken(String clientId,
            String clientSecret, String refreshToken, String tokenEndpoint) {

        Response response = given()
            .contentType(ContentType.URLENC)
            .formParam("grant_type", "refresh_token")
            .formParam("client_id", clientId)
            .formParam("client_secret", clientSecret)
            .formParam("refresh_token", refreshToken)
            .when()
            .post(tokenEndpoint);

        return response.as(OAuthTokenResponse.class);
    }
}

// OAuth Token Response Model
@Data
@NoArgsConstructor
@AllArgsConstructor
public class OAuthTokenResponse {
    @JsonProperty("access_token")
    private String accessToken;

    @JsonProperty("token_type")
    private String tokenType;

    @JsonProperty("expires_in")
    private Integer expiresIn;

    @JsonProperty("refresh_token")
    private String refreshToken;

    private String scope;

    @JsonProperty("id_token")
    private String idToken; // For OpenID Connect
}

// JWT Token Manager
public class JWTTokenManager {
    private static final Logger logger = LoggerFactory.getLogger(JWTTokenManager.class);

    /**
     * Decode JWT token without verification (for testing)
     */
    public static Map<String, Object> decodeJWT(String token) {
        try {
            String[] parts = token.split("\\.");
            if (parts.length < 2) {
                throw new IllegalArgumentException("Invalid JWT token");
            }

            // Decode payload (second part)
            String payload = new String(Base64.getUrlDecoder().decode(parts[1]));

            ObjectMapper mapper = new ObjectMapper();
            return mapper.readValue(payload, new TypeReference<Map<String, Object>>() {});

        } catch (Exception e) {
            logger.error("Error decoding JWT", e);
            throw new RuntimeException("Failed to decode JWT", e);
        }
    }

    /**
     * Extract claim from JWT
     */
    public static Object getClaim(String token, String claimName) {
        Map<String, Object> claims = decodeJWT(token);
        return claims.get(claimName);
    }

    /**
     * Check if JWT is expired
     */
    public static boolean isTokenExpired(String token) {
        Map<String, Object> claims = decodeJWT(token);
        Object exp = claims.get("exp");

        if (exp instanceof Number) {
            long expiryTime = ((Number) exp).longValue() * 1000; // Convert to milliseconds
            return System.currentTimeMillis() > expiryTime;
        }

        return false;
    }

    /**
     * Get token expiry time
     */
    public static LocalDateTime getTokenExpiry(String token) {
        Map<String, Object> claims = decodeJWT(token);
        Object exp = claims.get("exp");

        if (exp instanceof Number) {
            long expiryTime = ((Number) exp).longValue();
            return LocalDateTime.ofInstant(
                Instant.ofEpochSecond(expiryTime),
                ZoneId.systemDefault()
            );
        }

        return null;
    }

    /**
     * Validate JWT structure (basic validation)
     */
    public static boolean isValidJWTStructure(String token) {
        if (token == null || token.isEmpty()) {
            return false;
        }

        String[] parts = token.split("\\.");
        return parts.length == 3; // Header.Payload.Signature
    }
}

// Advanced OAuth 2.0 Token Manager with Auto-Refresh
public class OAuth2TokenManager {
    private static final Logger logger = LoggerFactory.getLogger(OAuth2TokenManager.class);
    private static OAuth2TokenManager instance;

    private String clientId;
    private String clientSecret;
    private String tokenEndpoint;
    private OAuthTokenResponse currentToken;
    private LocalDateTime tokenExpiry;

    private OAuth2TokenManager() {
        this.clientId = APIConfig.getProperty("oauth.client.id");
        this.clientSecret = APIConfig.getProperty("oauth.client.secret");
        this.tokenEndpoint = APIConfig.getProperty("oauth.token.endpoint");
    }

    public static synchronized OAuth2TokenManager getInstance() {
        if (instance == null) {
            instance = new OAuth2TokenManager();
        }
        return instance;
    }

    /**
     * Get valid access token (auto-refresh if needed)
     */
    public synchronized String getAccessToken() {
        if (currentToken == null || isTokenExpired()) {
            if (currentToken != null && currentToken.getRefreshToken() != null) {
                refreshAccessToken();
            } else {
                obtainNewToken();
            }
        }
        return currentToken.getAccessToken();
    }

    /**
     * Check if token is expired or about to expire (within 5 minutes)
     */
    private boolean isTokenExpired() {
        if (tokenExpiry == null) {
            return true;
        }
        return LocalDateTime.now().plusMinutes(5).isAfter(tokenExpiry);
    }

    /**
     * Obtain new token using client credentials
     */
    private void obtainNewToken() {
        logger.info("Obtaining new OAuth 2.0 token...");

        currentToken = AuthenticationManager.getClientCredentialsToken(
            clientId,
            clientSecret,
            tokenEndpoint
        );

        updateTokenExpiry();
        logger.info("New token obtained. Expires at: {}", tokenExpiry);
    }

    /**
     * Refresh access token using refresh token
     */
    private void refreshAccessToken() {
        logger.info("Refreshing OAuth 2.0 token...");

        try {
            currentToken = AuthenticationManager.refreshToken(
                clientId,
                clientSecret,
                currentToken.getRefreshToken(),
                tokenEndpoint
            );

            updateTokenExpiry();
            logger.info("Token refreshed. Expires at: {}", tokenExpiry);

        } catch (Exception e) {
            logger.error("Failed to refresh token, obtaining new token", e);
            obtainNewToken();
        }
    }

    /**
     * Update token expiry time
     */
    private void updateTokenExpiry() {
        if (currentToken.getExpiresIn() != null) {
            tokenExpiry = LocalDateTime.now().plusSeconds(currentToken.getExpiresIn());
        }
    }

    /**
     * Clear current token
     */
    public void clearToken() {
        currentToken = null;
        tokenExpiry = null;
    }

    /**
     * Get RequestSpecification with current access token
     */
    public RequestSpecification getAuthenticatedSpec() {
        return AuthenticationManager.withBearerToken(getAccessToken());
    }
}

// Multi-User Authentication Manager (for testing with multiple users)
public class MultiUserAuthManager {
    private static final Logger logger = LoggerFactory.getLogger(MultiUserAuthManager.class);
    private static Map<String, UserSession> userSessions = new ConcurrentHashMap<>();

    /**
     * Login user and store session
     */
    public static UserSession loginUser(String username, String password) {
        logger.info("Logging in user: {}", username);

        Response response = given()
            .contentType(ContentType.JSON)
            .body(Map.of("username", username, "password", password))
            .when()
            .post(APIConfig.getBaseURI() + "/auth/login");

        if (response.getStatusCode() == 200) {
            OAuthTokenResponse tokenResponse = response.as(OAuthTokenResponse.class);

            UserSession session = new UserSession();
            session.setUsername(username);
            session.setAccessToken(tokenResponse.getAccessToken());
            session.setRefreshToken(tokenResponse.getRefreshToken());
            session.setTokenExpiry(LocalDateTime.now().plusSeconds(
                tokenResponse.getExpiresIn()
            ));

            userSessions.put(username, session);
            logger.info("User {} logged in successfully", username);

            return session;
        } else {
            throw new RuntimeException("Login failed for user: " + username);
        }
    }

    /**
     * Get user session
     */
    public static UserSession getUserSession(String username) {
        UserSession session = userSessions.get(username);

        if (session == null) {
            throw new IllegalStateException("No session found for user: " + username);
        }

        // Auto-refresh if expired
        if (session.isExpired()) {
            refreshUserSession(username);
        }

        return userSessions.get(username);
    }

    /**
     * Refresh user session
     */
    private static void refreshUserSession(String username) {
        UserSession session = userSessions.get(username);

        OAuthTokenResponse newToken = AuthenticationManager.refreshToken(
            APIConfig.getProperty("oauth.client.id"),
            APIConfig.getProperty("oauth.client.secret"),
            session.getRefreshToken(),
            APIConfig.getProperty("oauth.token.endpoint")
        );

        session.setAccessToken(newToken.getAccessToken());
        session.setRefreshToken(newToken.getRefreshToken());
        session.setTokenExpiry(LocalDateTime.now().plusSeconds(newToken.getExpiresIn()));

        logger.info("Session refreshed for user: {}", username);
    }

    /**
     * Get authenticated request spec for user
     */
    public static RequestSpecification getAuthSpecForUser(String username) {
        UserSession session = getUserSession(username);
        return AuthenticationManager.withBearerToken(session.getAccessToken());
    }

    /**
     * Logout user
     */
    public static void logoutUser(String username) {
        userSessions.remove(username);
        logger.info("User {} logged out", username);
    }

    /**
     * Clear all sessions
     */
    public static void clearAllSessions() {
        userSessions.clear();
        logger.info("All user sessions cleared");
    }
}

// User Session Model
@Data
public class UserSession {
    private String username;
    private String accessToken;
    private String refreshToken;
    private LocalDateTime tokenExpiry;

    public boolean isExpired() {
        return tokenExpiry != null && LocalDateTime.now().isAfter(tokenExpiry);
    }
}

// Test Examples
public class AuthenticationTest {

    @Test(description = "Test Basic Authentication")
    public void testBasicAuth() {
        Response response = given()
            .spec(AuthenticationManager.withBasicAuth("user", "password"))
            .when()
            .get("/secure/resource");

        response.then()
            .statusCode(200)
            .body("message", equalTo("Authenticated successfully"));
    }

    @Test(description = "Test Bearer Token Authentication")
    public void testBearerToken() {
        String token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...";

        Response response = given()
            .spec(AuthenticationManager.withBearerToken(token))
            .when()
            .get("/api/users");

        response.then()
            .statusCode(200);
    }

    @Test(description = "Test API Key Authentication")
    public void testAPIKey() {
        String apiKey = "your-api-key-here";

        Response response = given()
            .spec(AuthenticationManager.withAPIKeyHeader("X-API-Key", apiKey))
            .when()
            .get("/api/data");

        response.then()
            .statusCode(200);
    }

    @Test(description = "Test OAuth 2.0 Client Credentials Flow")
    public void testOAuth2ClientCredentials() {
        // Get token
        OAuthTokenResponse tokenResponse = AuthenticationManager.getClientCredentialsToken(
            "client-id",
            "client-secret",
            "https://auth.example.com/oauth/token"
        );

        Assert.assertNotNull(tokenResponse.getAccessToken());
        Assert.assertEquals(tokenResponse.getTokenType(), "Bearer");

        // Use token
        Response response = given()
            .spec(AuthenticationManager.withBearerToken(tokenResponse.getAccessToken()))
            .when()
            .get("/api/protected");

        response.then()
            .statusCode(200);
    }

    @Test(description = "Test JWT Token Decoding")
    public void testJWTDecoding() {
        String jwtToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c";

        // Decode token
        Map<String, Object> claims = JWTTokenManager.decodeJWT(jwtToken);

        Assert.assertNotNull(claims);
        Assert.assertEquals(claims.get("name"), "John Doe");
        Assert.assertEquals(claims.get("sub"), "1234567890");
    }

    @Test(description = "Test Auto-Refresh Token Mechanism")
    public void testAutoRefreshToken() {
        OAuth2TokenManager tokenManager = OAuth2TokenManager.getInstance();

        // Get token (will obtain new one)
        String token1 = tokenManager.getAccessToken();
        Assert.assertNotNull(token1);

        // Get token again (should return cached token)
        String token2 = tokenManager.getAccessToken();
        Assert.assertEquals(token1, token2);
    }

    @Test(description = "Test Multi-User Authentication")
    public void testMultiUserAuth() {
        // Login multiple users
        MultiUserAuthManager.loginUser("user1", "password1");
        MultiUserAuthManager.loginUser("user2", "password2");

        // Make request as user1
        Response response1 = given()
            .spec(MultiUserAuthManager.getAuthSpecForUser("user1"))
            .when()
            .get("/api/profile");

        response1.then()
            .statusCode(200)
            .body("username", equalTo("user1"));

        // Make request as user2
        Response response2 = given()
            .spec(MultiUserAuthManager.getAuthSpecForUser("user2"))
            .when()
            .get("/api/profile");

        response2.then()
            .statusCode(200)
            .body("username", equalTo("user2"));

        // Cleanup
        MultiUserAuthManager.logoutUser("user1");
        MultiUserAuthManager.logoutUser("user2");
    }

    @Test(description = "Test Unauthorized Access")
    public void testUnauthorizedAccess() {
        Response response = given()
            .spec(SpecificationBuilder.getBaseRequestSpec())
            .when()
            .get("/api/protected");

        response.then()
            .statusCode(401)
            .body("error", equalTo("Unauthorized"));
    }

    @Test(description = "Test Invalid Token")
    public void testInvalidToken() {
        Response response = given()
            .spec(AuthenticationManager.withBearerToken("invalid-token"))
            .when()
            .get("/api/protected");

        response.then()
            .statusCode(401)
            .body("error", equalTo("Invalid token"));
    }
}
```

**Follow-up**: How do you handle token rotation and concurrent token refresh in parallel tests? What security best practices do you follow for storing credentials in automation frameworks? How do you test different authorization scenarios (roles, permissions)? How do you implement authentication for microservices with service-to-service authentication?

---

### **Q104. How do you implement API chaining and data extraction in REST Assured? Explain request chaining, response data reuse, and managing test data dependencies.** (6-8 Years, 9-12 Years)

**Difficulty**: Hard
**Companies**: Amazon, Microsoft, Adobe, Flipkart, Google, PayPal
**Topics**: API Chaining, Data Extraction, Request Dependencies, Test Data Management

**Answer**:

API chaining is a critical pattern for testing complex workflows where subsequent API calls depend on data from previous responses. This is common in real-world scenarios like user registration â†’ login â†’ profile update, or creating an order â†’ adding items â†’ payment â†’ verification.

**Key Concepts**:
1. **Response Data Extraction**: Extracting values from JSON/XML responses using JsonPath/XmlPath
2. **Request Chaining**: Using extracted data in subsequent requests
3. **Test Data Context**: Maintaining state across multiple API calls
4. **Dependency Management**: Managing relationships between API calls
5. **Cleanup Strategy**: Handling test data cleanup for chained operations

**Complete Implementation**:

```java
// 1. Test Data Context - Maintains state across API calls
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class TestDataContext {
    private static final ThreadLocal<Map<String, Object>> context =
        ThreadLocal.withInitial(ConcurrentHashMap::new);

    // Store data in context
    public static void set(String key, Object value) {
        context.get().put(key, value);
    }

    // Retrieve data from context
    public static <T> T get(String key) {
        return (T) context.get().get(key);
    }

    // Check if key exists
    public static boolean contains(String key) {
        return context.get().containsKey(key);
    }

    // Remove specific key
    public static void remove(String key) {
        context.get().remove(key);
    }

    // Clear all data for current thread
    public static void clear() {
        context.get().clear();
    }

    // Get all data
    public static Map<String, Object> getAll() {
        return new HashMap<>(context.get());
    }

    // Store multiple values
    public static void setAll(Map<String, Object> data) {
        context.get().putAll(data);
    }
}

// 2. Response Data Extractor - Extract data from responses
import io.restassured.path.json.JsonPath;
import io.restassured.path.xml.XmlPath;
import io.restassured.response.Response;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.Map;

public class ResponseDataExtractor {
    private static final Logger logger = LoggerFactory.getLogger(ResponseDataExtractor.class);

    // Extract single value
    public static <T> T extractValue(Response response, String path) {
        try {
            JsonPath jsonPath = response.jsonPath();
            T value = jsonPath.get(path);
            logger.info("Extracted value from path '{}': {}", path, value);
            return value;
        } catch (Exception e) {
            logger.error("Failed to extract value from path: {}", path, e);
            throw new RuntimeException("Data extraction failed for path: " + path, e);
        }
    }

    // Extract and store in context
    public static <T> T extractAndStore(Response response, String path, String contextKey) {
        T value = extractValue(response, path);
        TestDataContext.set(contextKey, value);
        logger.info("Stored extracted value in context with key: {}", contextKey);
        return value;
    }

    // Extract multiple values
    public static Map<String, Object> extractMultiple(Response response, Map<String, String> pathMap) {
        Map<String, Object> extractedData = new HashMap<>();
        JsonPath jsonPath = response.jsonPath();

        pathMap.forEach((contextKey, jsonPath_) -> {
            Object value = jsonPath.get(jsonPath_);
            extractedData.put(contextKey, value);
            logger.info("Extracted {}: {}", contextKey, value);
        });

        return extractedData;
    }

    // Extract and store multiple values
    public static void extractAndStoreMultiple(Response response, Map<String, String> pathMap) {
        Map<String, Object> extractedData = extractMultiple(response, pathMap);
        TestDataContext.setAll(extractedData);
        logger.info("Stored {} values in context", extractedData.size());
    }

    // Extract list of values
    public static <T> List<T> extractList(Response response, String path) {
        JsonPath jsonPath = response.jsonPath();
        List<T> list = jsonPath.getList(path);
        logger.info("Extracted list from path '{}': {} items", path, list.size());
        return list;
    }

    // Extract with filtering
    public static <T> List<T> extractWithFilter(Response response, String filterExpression) {
        JsonPath jsonPath = response.jsonPath();
        List<T> filteredList = jsonPath.getList(filterExpression);
        logger.info("Extracted filtered list: {} items", filteredList.size());
        return filteredList;
    }

    // Extract from nested JSON
    public static <T> T extractNested(Response response, String... paths) {
        JsonPath jsonPath = response.jsonPath();
        String fullPath = String.join(".", paths);
        return jsonPath.get(fullPath);
    }

    // Extract header value
    public static String extractHeader(Response response, String headerName) {
        String headerValue = response.getHeader(headerName);
        logger.info("Extracted header '{}': {}", headerName, headerValue);
        return headerValue;
    }

    // Extract cookie value
    public static String extractCookie(Response response, String cookieName) {
        String cookieValue = response.getCookie(cookieName);
        logger.info("Extracted cookie '{}': {}", cookieName, cookieValue);
        return cookieValue;
    }
}

// 3. API Chain Builder - Fluent API for building request chains
import io.restassured.response.Response;
import io.restassured.specification.RequestSpecification;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.function.Function;

import static io.restassured.RestAssured.given;

public class APIChainBuilder {
    private final List<ChainStep> steps = new ArrayList<>();
    private RequestSpecification baseSpec;
    private boolean stopOnFailure = true;

    public APIChainBuilder(RequestSpecification baseSpec) {
        this.baseSpec = baseSpec;
    }

    public static APIChainBuilder start(RequestSpecification baseSpec) {
        return new APIChainBuilder(baseSpec);
    }

    // Configure chain behavior
    public APIChainBuilder stopOnFailure(boolean stop) {
        this.stopOnFailure = stop;
        return this;
    }

    // Add GET request step
    public APIChainBuilder get(String endpoint, String stepName) {
        steps.add(new ChainStep(stepName, endpoint, "GET", null, null));
        return this;
    }

    // Add POST request step
    public APIChainBuilder post(String endpoint, String stepName, Object body) {
        steps.add(new ChainStep(stepName, endpoint, "POST", body, null));
        return this;
    }

    // Add PUT request step
    public APIChainBuilder put(String endpoint, String stepName, Object body) {
        steps.add(new ChainStep(stepName, endpoint, "PUT", body, null));
        return this;
    }

    // Add DELETE request step
    public APIChainBuilder delete(String endpoint, String stepName) {
        steps.add(new ChainStep(stepName, endpoint, "DELETE", null, null));
        return this;
    }

    // Add data extraction after step
    public APIChainBuilder extractData(Map<String, String> pathMap) {
        if (!steps.isEmpty()) {
            ChainStep lastStep = steps.get(steps.size() - 1);
            lastStep.setExtractionMap(pathMap);
        }
        return this;
    }

    // Add custom validation
    public APIChainBuilder validate(Function<Response, Boolean> validator) {
        if (!steps.isEmpty()) {
            ChainStep lastStep = steps.get(steps.size() - 1);
            lastStep.setValidator(validator);
        }
        return this;
    }

    // Execute the chain
    public ChainExecutionResult execute() {
        ChainExecutionResult result = new ChainExecutionResult();

        for (int i = 0; i < steps.size(); i++) {
            ChainStep step = steps.get(i);
            logger.info("Executing chain step {}/{}: {}", i + 1, steps.size(), step.getName());

            try {
                // Build request with dynamic endpoint (resolve variables)
                String resolvedEndpoint = resolveVariables(step.getEndpoint());
                RequestSpecification request = given().spec(baseSpec);

                // Execute request based on method
                Response response = executeRequest(request, step, resolvedEndpoint);

                // Store response
                step.setResponse(response);
                result.addStepResult(step.getName(), response, true);

                // Extract data if configured
                if (step.getExtractionMap() != null) {
                    ResponseDataExtractor.extractAndStoreMultiple(response, step.getExtractionMap());
                }

                // Run custom validation if configured
                if (step.getValidator() != null) {
                    boolean isValid = step.getValidator().apply(response);
                    if (!isValid) {
                        logger.error("Validation failed for step: {}", step.getName());
                        if (stopOnFailure) {
                            result.setSuccess(false);
                            return result;
                        }
                    }
                }

            } catch (Exception e) {
                logger.error("Error executing chain step: {}", step.getName(), e);
                result.addStepResult(step.getName(), null, false);
                result.setSuccess(false);

                if (stopOnFailure) {
                    return result;
                }
            }
        }

        result.setSuccess(true);
        return result;
    }

    // Resolve variables in endpoint from context
    private String resolveVariables(String endpoint) {
        String resolved = endpoint;

        // Find all {variable} patterns
        java.util.regex.Pattern pattern = java.util.regex.Pattern.compile("\\{([^}]+)\\}");
        java.util.regex.Matcher matcher = pattern.matcher(endpoint);

        while (matcher.find()) {
            String variable = matcher.group(1);
            if (TestDataContext.contains(variable)) {
                Object value = TestDataContext.get(variable);
                resolved = resolved.replace("{" + variable + "}", value.toString());
                logger.info("Resolved variable '{}' to '{}'", variable, value);
            }
        }

        return resolved;
    }

    // Execute request based on HTTP method
    private Response executeRequest(RequestSpecification request, ChainStep step, String endpoint) {
        if (step.getBody() != null) {
            request.body(step.getBody());
        }

        return switch (step.getMethod()) {
            case "GET" -> request.get(endpoint);
            case "POST" -> request.post(endpoint);
            case "PUT" -> request.put(endpoint);
            case "DELETE" -> request.delete(endpoint);
            case "PATCH" -> request.patch(endpoint);
            default -> throw new IllegalArgumentException("Unsupported HTTP method: " + step.getMethod());
        };
    }

    // Inner class for chain step
    private static class ChainStep {
        private final String name;
        private final String endpoint;
        private final String method;
        private final Object body;
        private Map<String, String> extractionMap;
        private Function<Response, Boolean> validator;
        private Response response;

        public ChainStep(String name, String endpoint, String method, Object body,
                        Map<String, String> extractionMap) {
            this.name = name;
            this.endpoint = endpoint;
            this.method = method;
            this.body = body;
            this.extractionMap = extractionMap;
        }

        // Getters and setters
        public String getName() { return name; }
        public String getEndpoint() { return endpoint; }
        public String getMethod() { return method; }
        public Object getBody() { return body; }
        public Map<String, String> getExtractionMap() { return extractionMap; }
        public void setExtractionMap(Map<String, String> extractionMap) {
            this.extractionMap = extractionMap;
        }
        public Function<Response, Boolean> getValidator() { return validator; }
        public void setValidator(Function<Response, Boolean> validator) {
            this.validator = validator;
        }
        public Response getResponse() { return response; }
        public void setResponse(Response response) { this.response = response; }
    }

    private static final Logger logger = LoggerFactory.getLogger(APIChainBuilder.class);
}

// Chain Execution Result
public class ChainExecutionResult {
    private boolean success;
    private Map<String, StepResult> stepResults = new HashMap<>();

    public void addStepResult(String stepName, Response response, boolean success) {
        stepResults.put(stepName, new StepResult(response, success));
    }

    public boolean isSuccess() { return success; }
    public void setSuccess(boolean success) { this.success = success; }

    public Response getStepResponse(String stepName) {
        StepResult result = stepResults.get(stepName);
        return result != null ? result.getResponse() : null;
    }

    public boolean isStepSuccessful(String stepName) {
        StepResult result = stepResults.get(stepName);
        return result != null && result.isSuccess();
    }

    public Map<String, StepResult> getAllResults() {
        return new HashMap<>(stepResults);
    }

    // Inner class
    public static class StepResult {
        private final Response response;
        private final boolean success;

        public StepResult(Response response, boolean success) {
            this.response = response;
            this.success = success;
        }

        public Response getResponse() { return response; }
        public boolean isSuccess() { return success; }
    }
}

// 4. Request Chaining Manager - High-level API for common chaining scenarios
public class RequestChainingManager {
    private final RequestSpecification baseSpec;

    public RequestChainingManager(RequestSpecification baseSpec) {
        this.baseSpec = baseSpec;
    }

    // Create and use pattern
    public Response createAndGet(String createEndpoint, Object createBody,
                                 String idJsonPath, String getEndpointTemplate) {
        // Create resource
        Response createResponse = given()
            .spec(baseSpec)
            .body(createBody)
            .when()
            .post(createEndpoint);

        // Extract ID
        String id = ResponseDataExtractor.extractValue(createResponse, idJsonPath);
        TestDataContext.set("createdResourceId", id);

        // Get created resource
        String getEndpoint = getEndpointTemplate.replace("{id}", id);
        Response getResponse = given()
            .spec(baseSpec)
            .when()
            .get(getEndpoint);

        return getResponse;
    }

    // Create, update, and verify pattern
    public Response createUpdateVerify(String createEndpoint, Object createBody,
                                      String idJsonPath, String updateEndpointTemplate,
                                      Object updateBody) {
        // Create
        Response createResponse = given()
            .spec(baseSpec)
            .body(createBody)
            .post(createEndpoint);

        String id = ResponseDataExtractor.extractValue(createResponse, idJsonPath);

        // Update
        String updateEndpoint = updateEndpointTemplate.replace("{id}", id);
        Response updateResponse = given()
            .spec(baseSpec)
            .body(updateBody)
            .put(updateEndpoint);

        // Verify
        Response verifyResponse = given()
            .spec(baseSpec)
            .get(updateEndpoint);

        return verifyResponse;
    }

    // Parent-child resource creation
    public Map<String, String> createParentChildResources(
            String parentEndpoint, Object parentBody, String parentIdPath,
            String childEndpointTemplate, Object childBody, String childIdPath) {

        // Create parent
        Response parentResponse = given()
            .spec(baseSpec)
            .body(parentBody)
            .post(parentEndpoint);

        String parentId = ResponseDataExtractor.extractValue(parentResponse, parentIdPath);

        // Create child
        String childEndpoint = childEndpointTemplate.replace("{parentId}", parentId);
        Response childResponse = given()
            .spec(baseSpec)
            .body(childBody)
            .post(childEndpoint);

        String childId = ResponseDataExtractor.extractValue(childResponse, childIdPath);

        return Map.of("parentId", parentId, "childId", childId);
    }
}

// 5. Dependency Graph Manager - Manages complex dependencies
public class DependencyGraphManager {
    private final Map<String, APIRequest> requests = new LinkedHashMap<>();
    private final Map<String, Set<String>> dependencies = new HashMap<>();
    private final Map<String, Response> responses = new ConcurrentHashMap<>();

    // Add request to graph
    public void addRequest(String requestId, APIRequest request) {
        requests.put(requestId, request);
        dependencies.putIfAbsent(requestId, new HashSet<>());
    }

    // Add dependency (requestId depends on dependsOnId)
    public void addDependency(String requestId, String dependsOnId) {
        dependencies.get(requestId).add(dependsOnId);
    }

    // Execute all requests in dependency order
    public Map<String, Response> executeAll(RequestSpecification baseSpec) {
        Set<String> executed = new HashSet<>();
        Queue<String> queue = new LinkedList<>();

        // Find requests with no dependencies
        for (String requestId : requests.keySet()) {
            if (dependencies.get(requestId).isEmpty()) {
                queue.offer(requestId);
            }
        }

        // Execute requests in topological order
        while (!queue.isEmpty()) {
            String currentId = queue.poll();

            if (executed.contains(currentId)) {
                continue;
            }

            // Execute request
            APIRequest request = requests.get(currentId);
            Response response = request.execute(baseSpec, responses);
            responses.put(currentId, response);
            executed.add(currentId);

            // Extract and store data
            if (request.getDataToExtract() != null) {
                ResponseDataExtractor.extractAndStoreMultiple(response, request.getDataToExtract());
            }

            // Add dependent requests to queue
            for (String requestId : requests.keySet()) {
                if (!executed.contains(requestId)) {
                    dependencies.get(requestId).remove(currentId);
                    if (dependencies.get(requestId).isEmpty()) {
                        queue.offer(requestId);
                    }
                }
            }
        }

        return new HashMap<>(responses);
    }

    // Check for circular dependencies
    public boolean hasCircularDependency() {
        // Implementation of cycle detection algorithm
        return false; // Simplified
    }
}

// API Request wrapper
public class APIRequest {
    private String endpoint;
    private String method;
    private Object body;
    private Map<String, String> dataToExtract;

    public APIRequest(String endpoint, String method, Object body) {
        this.endpoint = endpoint;
        this.method = method;
        this.body = body;
    }

    public Response execute(RequestSpecification baseSpec, Map<String, Response> previousResponses) {
        // Resolve endpoint variables from previous responses
        String resolvedEndpoint = resolveEndpoint(previousResponses);

        RequestSpecification request = given().spec(baseSpec);

        if (body != null) {
            request.body(body);
        }

        return switch (method) {
            case "GET" -> request.get(resolvedEndpoint);
            case "POST" -> request.post(resolvedEndpoint);
            case "PUT" -> request.put(resolvedEndpoint);
            case "DELETE" -> request.delete(resolvedEndpoint);
            default -> throw new IllegalArgumentException("Unsupported method: " + method);
        };
    }

    private String resolveEndpoint(Map<String, Response> previousResponses) {
        String resolved = endpoint;

        // Resolve from TestDataContext
        java.util.regex.Pattern pattern = java.util.regex.Pattern.compile("\\{([^}]+)\\}");
        java.util.regex.Matcher matcher = pattern.matcher(endpoint);

        while (matcher.find()) {
            String variable = matcher.group(1);
            if (TestDataContext.contains(variable)) {
                Object value = TestDataContext.get(variable);
                resolved = resolved.replace("{" + variable + "}", value.toString());
            }
        }

        return resolved;
    }

    public Map<String, String> getDataToExtract() { return dataToExtract; }
    public void setDataToExtract(Map<String, String> dataToExtract) {
        this.dataToExtract = dataToExtract;
    }
}
```

**Complete Test Examples**:

```java
import org.testng.annotations.AfterMethod;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.Test;
import static org.hamcrest.Matchers.*;

public class APIChainingTests {
    private RequestSpecification requestSpec;

    @BeforeMethod
    public void setup() {
        requestSpec = SpecificationBuilder.getBaseRequestSpec();
        TestDataContext.clear();
    }

    @AfterMethod
    public void tearDown() {
        // Cleanup created resources
        if (TestDataContext.contains("userId")) {
            String userId = TestDataContext.get("userId");
            given()
                .spec(requestSpec)
                .when()
                .delete("/users/" + userId);
        }
        TestDataContext.clear();
    }

    // Test 1: Simple create and get chaining
    @Test
    public void testCreateAndGetUser() {
        // Create user
        User newUser = User.builder()
            .name("John Doe")
            .email("john.doe@example.com")
            .build();

        Response createResponse = given()
            .spec(requestSpec)
            .body(newUser)
            .when()
            .post("/users")
            .then()
            .statusCode(201)
            .body("name", equalTo("John Doe"))
            .extract()
            .response();

        // Extract user ID
        String userId = ResponseDataExtractor.extractAndStore(
            createResponse, "id", "userId"
        );

        // Get created user
        given()
            .spec(requestSpec)
            .when()
            .get("/users/" + userId)
            .then()
            .statusCode(200)
            .body("id", equalTo(userId))
            .body("name", equalTo("John Doe"))
            .body("email", equalTo("john.doe@example.com"));
    }

    // Test 2: Using APIChainBuilder
    @Test
    public void testUserRegistrationFlow() {
        User newUser = User.builder()
            .name("Jane Smith")
            .email("jane.smith@example.com")
            .password("SecurePass123")
            .build();

        ChainExecutionResult result = APIChainBuilder.start(requestSpec)
            // Step 1: Register user
            .post("/users", "registerUser", newUser)
            .extractData(Map.of(
                "userId", "id",
                "userEmail", "email"
            ))
            .validate(response -> response.statusCode() == 201)

            // Step 2: Login with created user
            .post("/auth/login", "loginUser", Map.of(
                "email", "jane.smith@example.com",
                "password", "SecurePass123"
            ))
            .extractData(Map.of(
                "accessToken", "token",
                "refreshToken", "refreshToken"
            ))
            .validate(response -> response.statusCode() == 200)

            // Step 3: Get user profile with token
            .get("/users/{userId}", "getUserProfile")
            .validate(response ->
                response.statusCode() == 200 &&
                response.jsonPath().getString("email").equals("jane.smith@example.com")
            )

            .execute();

        Assert.assertTrue(result.isSuccess(), "Chain execution failed");
        Assert.assertTrue(TestDataContext.contains("userId"), "User ID not stored");
        Assert.assertTrue(TestDataContext.contains("accessToken"), "Access token not stored");
    }

    // Test 3: Complex order creation flow
    @Test
    public void testOrderCreationFlow() {
        // Create customer
        Customer customer = Customer.builder()
            .name("Alice Johnson")
            .email("alice@example.com")
            .build();

        // Create product
        Product product = Product.builder()
            .name("Laptop")
            .price(999.99)
            .build();

        ChainExecutionResult result = APIChainBuilder.start(requestSpec)
            // Create customer
            .post("/customers", "createCustomer", customer)
            .extractData(Map.of("customerId", "id"))

            // Create product
            .post("/products", "createProduct", product)
            .extractData(Map.of("productId", "id"))

            // Create order for customer
            .post("/customers/{customerId}/orders", "createOrder", Map.of(
                "items", List.of(Map.of(
                    "productId", "{productId}",
                    "quantity", 2
                ))
            ))
            .extractData(Map.of(
                "orderId", "id",
                "orderTotal", "total"
            ))

            // Get order details
            .get("/orders/{orderId}", "getOrder")
            .validate(response -> {
                double total = response.jsonPath().getDouble("total");
                return total == 1999.98; // 2 * 999.99
            })

            // Update order status
            .put("/orders/{orderId}/status", "updateOrderStatus", Map.of(
                "status", "CONFIRMED"
            ))

            .stopOnFailure(true)
            .execute();

        Assert.assertTrue(result.isSuccess());

        // Verify final order state
        String orderId = TestDataContext.get("orderId");
        given()
            .spec(requestSpec)
            .when()
            .get("/orders/" + orderId)
            .then()
            .statusCode(200)
            .body("status", equalTo("CONFIRMED"))
            .body("total", equalTo(1999.98f))
            .body("items.size()", equalTo(1))
            .body("items[0].quantity", equalTo(2));
    }

    // Test 4: Using RequestChainingManager
    @Test
    public void testCreateUpdateVerifyPattern() {
        RequestChainingManager chainManager = new RequestChainingManager(requestSpec);

        User createUser = User.builder()
            .name("Bob Wilson")
            .email("bob@example.com")
            .build();

        User updateUser = User.builder()
            .name("Robert Wilson")
            .email("robert@example.com")
            .build();

        Response finalResponse = chainManager.createUpdateVerify(
            "/users",
            createUser,
            "id",
            "/users/{id}",
            updateUser
        );

        // Verify updated data
        finalResponse.then()
            .statusCode(200)
            .body("name", equalTo("Robert Wilson"))
            .body("email", equalTo("robert@example.com"));
    }

    // Test 5: Parent-child resource creation
    @Test
    public void testBlogPostWithComments() {
        RequestChainingManager chainManager = new RequestChainingManager(requestSpec);

        BlogPost post = BlogPost.builder()
            .title("API Testing Best Practices")
            .content("Content here...")
            .build();

        Comment comment = Comment.builder()
            .author("Jane Doe")
            .text("Great article!")
            .build();

        Map<String, String> ids = chainManager.createParentChildResources(
            "/posts",
            post,
            "id",
            "/posts/{parentId}/comments",
            comment,
            "id"
        );

        // Verify comment is associated with post
        given()
            .spec(requestSpec)
            .when()
            .get("/posts/" + ids.get("parentId") + "/comments")
            .then()
            .statusCode(200)
            .body("size()", greaterThan(0))
            .body("[0].id", equalTo(ids.get("childId")))
            .body("[0].author", equalTo("Jane Doe"));
    }

    // Test 6: Extract multiple values and use in subsequent requests
    @Test
    public void testMultipleDataExtraction() {
        // Create user
        User user = User.builder()
            .name("Charlie Brown")
            .email("charlie@example.com")
            .address(Address.builder()
                .street("123 Main St")
                .city("New York")
                .zipCode("10001")
                .build())
            .build();

        Response createResponse = given()
            .spec(requestSpec)
            .body(user)
            .when()
            .post("/users");

        // Extract multiple values
        ResponseDataExtractor.extractAndStoreMultiple(createResponse, Map.of(
            "userId", "id",
            "userName", "name",
            "userCity", "address.city",
            "userZip", "address.zipCode"
        ));

        // Use extracted data in search
        given()
            .spec(requestSpec)
            .queryParam("city", TestDataContext.<String>get("userCity"))
            .queryParam("zipCode", TestDataContext.<String>get("userZip"))
            .when()
            .get("/users/search")
            .then()
            .statusCode(200)
            .body("find { it.id == '" + TestDataContext.get("userId") + "' }.name",
                  equalTo(TestDataContext.get("userName")));
    }

    // Test 7: Using DependencyGraphManager for complex workflows
    @Test
    public void testComplexDependencyGraph() {
        DependencyGraphManager graphManager = new DependencyGraphManager();

        // Define all requests
        APIRequest createUser = new APIRequest("/users", "POST",
            User.builder().name("User1").build());
        createUser.setDataToExtract(Map.of("userId", "id"));

        APIRequest createProject = new APIRequest("/projects", "POST",
            Project.builder().name("Project1").build());
        createProject.setDataToExtract(Map.of("projectId", "id"));

        APIRequest assignUserToProject = new APIRequest(
            "/projects/{projectId}/members", "POST",
            Map.of("userId", "{userId}")
        );

        APIRequest createTask = new APIRequest(
            "/projects/{projectId}/tasks", "POST",
            Task.builder().title("Task1").build()
        );

        // Add to graph with dependencies
        graphManager.addRequest("user", createUser);
        graphManager.addRequest("project", createProject);
        graphManager.addRequest("assignment", assignUserToProject);
        graphManager.addRequest("task", createTask);

        // Define dependencies
        graphManager.addDependency("assignment", "user");
        graphManager.addDependency("assignment", "project");
        graphManager.addDependency("task", "project");

        // Execute all in correct order
        Map<String, Response> responses = graphManager.executeAll(requestSpec);

        // Verify all succeeded
        Assert.assertEquals(responses.size(), 4);
        responses.values().forEach(response ->
            Assert.assertTrue(response.statusCode() >= 200 && response.statusCode() < 300)
        );
    }
}
```

**Best Practices**:

1. **Use ThreadLocal for Context**: Ensures thread safety in parallel test execution
2. **Clear Context After Tests**: Prevent data leakage between tests
3. **Handle Cleanup**: Delete created resources in @AfterMethod
4. **Validate Each Step**: Add validation to detect failures early
5. **Log Extracted Data**: Helps debugging chain failures
6. **Use Meaningful Keys**: Context keys should be descriptive
7. **Handle Failures Gracefully**: Decide whether to stop or continue on failure
8. **Avoid Deep Chains**: Keep chains manageable (3-5 steps max)

**Follow-up**: How do you handle cleanup of chained resources when a test fails midway? What strategies do you use for testing long-running workflows that involve async operations? How do you implement retry logic for failed steps in a chain? How do you test error scenarios in chained API calls (e.g., what if step 2 fails)?

---

### **Q105. Explain API Contract Testing with Pact framework. How is it different from functional API testing? Implement consumer-driven contract testing for microservices.** (6-8 Years, 9-12 Years)

**Difficulty**: Hard
**Companies**: Amazon, Microsoft, Uber, Netflix, Adobe, Flipkart, Google
**Topics**: Contract Testing, Pact Framework, Microservices, Consumer-Driven Contracts, CDC

**Answer**:

Contract testing ensures that services in a microservices architecture can communicate correctly by verifying that the consumer's expectations match the provider's implementation. Pact framework enables consumer-driven contract (CDC) testing where consumers define the contract.

**Key Concepts**:

1. **Consumer-Driven Contract (CDC)**: Consumer defines what it expects from the provider
2. **Pact File**: JSON file containing the contract (interactions between consumer and provider)
3. **Consumer Test**: Consumer runs tests and generates a pact file
4. **Provider Verification**: Provider verifies it can satisfy the pact file
5. **Pact Broker**: Central repository for sharing pacts between teams

**Contract Testing vs Functional Testing**:

| Aspect | Contract Testing | Functional Testing |
|--------|-----------------|-------------------|
| **Focus** | Communication between services | Business functionality |
| **Scope** | API interface contract | Complete API behavior |
| **Data** | Minimal test data | Comprehensive test scenarios |
| **Speed** | Fast (isolated, mocked) | Slower (end-to-end) |
| **Purpose** | Prevent breaking changes | Validate business logic |
| **When** | Every commit | Regression cycles |
| **Dependencies** | No real dependencies needed | May need actual services |

**Complete Implementation**:

```java
// 1. Maven Dependencies (pom.xml)
/*
<dependencies>
    <!-- Pact JVM Consumer -->
    <dependency>
        <groupId>au.com.dius.pact.consumer</groupId>
        <artifactId>junit5</artifactId>
        <version>4.6.0</version>
        <scope>test</scope>
    </dependency>

    <!-- Pact JVM Provider -->
    <dependency>
        <groupId>au.com.dius.pact.provider</groupId>
        <artifactId>junit5</artifactId>
        <version>4.6.0</version>
        <scope>test</scope>
    </dependency>

    <!-- Pact Broker -->
    <dependency>
        <groupId>au.com.dius.pact.provider</groupId>
        <artifactId>junit5spring</artifactId>
        <version>4.6.0</version>
        <scope>test</scope>
    </dependency>
</dependencies>
*/

// 2. Consumer-Side: Define Model Classes
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class User {
    private Long id;
    private String name;
    private String email;
    private String phoneNumber;
    private Address address;
}

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Address {
    private String street;
    private String city;
    private String state;
    private String zipCode;
}

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Order {
    private Long id;
    private Long userId;
    private String status;
    private Double totalAmount;
    private List<OrderItem> items;
    private LocalDateTime createdAt;
}

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class OrderItem {
    private Long productId;
    private String productName;
    private Integer quantity;
    private Double price;
}

// 3. Consumer API Client
public class UserServiceClient {
    private final String baseUrl;
    private final RestTemplate restTemplate;

    public UserServiceClient(String baseUrl) {
        this.baseUrl = baseUrl;
        this.restTemplate = new RestTemplate();
    }

    public User getUserById(Long userId) {
        String url = baseUrl + "/users/" + userId;
        return restTemplate.getForObject(url, User.class);
    }

    public User createUser(User user) {
        String url = baseUrl + "/users";
        return restTemplate.postForObject(url, user, User.class);
    }

    public void deleteUser(Long userId) {
        String url = baseUrl + "/users/" + userId;
        restTemplate.delete(url);
    }

    public List<User> searchUsers(String city) {
        String url = baseUrl + "/users/search?city=" + city;
        User[] users = restTemplate.getForObject(url, User[].class);
        return Arrays.asList(users);
    }
}

public class OrderServiceClient {
    private final String baseUrl;
    private final RestTemplate restTemplate;

    public OrderServiceClient(String baseUrl) {
        this.baseUrl = baseUrl;
        this.restTemplate = new RestTemplate();
    }

    public Order getOrderById(Long orderId) {
        String url = baseUrl + "/orders/" + orderId;
        return restTemplate.getForObject(url, Order.class);
    }

    public List<Order> getOrdersByUserId(Long userId) {
        String url = baseUrl + "/orders?userId=" + userId;
        Order[] orders = restTemplate.getForObject(url, Order[].class);
        return Arrays.asList(orders);
    }

    public Order createOrder(Order order) {
        String url = baseUrl + "/orders";
        return restTemplate.postForObject(url, order, Order.class);
    }
}

// 4. Consumer Pact Tests
import au.com.dius.pact.consumer.dsl.DslPart;
import au.com.dius.pact.consumer.dsl.PactDslJsonBody;
import au.com.dius.pact.consumer.dsl.PactDslWithProvider;
import au.com.dius.pact.consumer.junit5.PactConsumerTestExt;
import au.com.dius.pact.consumer.junit5.PactTestFor;
import au.com.dius.pact.core.model.PactSpecVersion;
import au.com.dius.pact.core.model.V4Pact;
import au.com.dius.pact.core.model.annotations.Pact;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;

import static org.junit.jupiter.api.Assertions.*;

@ExtendWith(PactConsumerTestExt.class)
@PactTestFor(providerName = "UserService", pactVersion = PactSpecVersion.V3)
public class UserServiceConsumerPactTest {

    @Pact(consumer = "OrderService")
    public V4Pact getUserByIdPact(PactDslWithProvider builder) {
        DslPart userBody = new PactDslJsonBody()
            .numberType("id", 1001L)
            .stringType("name", "John Doe")
            .stringMatcher("email", ".*@.*\\..*", "john.doe@example.com")
            .stringType("phoneNumber", "+1-555-1234")
            .object("address")
                .stringType("street", "123 Main St")
                .stringType("city", "New York")
                .stringType("state", "NY")
                .stringType("zipCode", "10001")
            .closeObject();

        return builder
            .given("user 1001 exists")
            .uponReceiving("a request to get user by ID")
                .path("/users/1001")
                .method("GET")
            .willRespondWith()
                .status(200)
                .headers(Map.of("Content-Type", "application/json"))
                .body(userBody)
            .toPact();
    }

    @Test
    @PactTestFor(pactMethod = "getUserByIdPact")
    public void testGetUserById(MockServer mockServer) {
        // Arrange
        UserServiceClient client = new UserServiceClient(mockServer.getUrl());

        // Act
        User user = client.getUserById(1001L);

        // Assert
        assertNotNull(user);
        assertEquals(1001L, user.getId());
        assertEquals("John Doe", user.getName());
        assertTrue(user.getEmail().matches(".*@.*\\..*"));
        assertNotNull(user.getAddress());
        assertEquals("New York", user.getAddress().getCity());
    }

    @Pact(consumer = "OrderService")
    public V4Pact createUserPact(PactDslWithProvider builder) {
        DslPart requestBody = new PactDslJsonBody()
            .stringType("name", "Jane Smith")
            .stringMatcher("email", ".*@.*\\..*", "jane.smith@example.com")
            .stringType("phoneNumber", "+1-555-5678")
            .object("address")
                .stringType("street", "456 Oak Ave")
                .stringType("city", "Los Angeles")
                .stringType("state", "CA")
                .stringType("zipCode", "90001")
            .closeObject();

        DslPart responseBody = new PactDslJsonBody()
            .numberType("id", 2002L)
            .stringType("name", "Jane Smith")
            .stringMatcher("email", ".*@.*\\..*", "jane.smith@example.com")
            .stringType("phoneNumber", "+1-555-5678")
            .object("address")
                .stringType("street", "456 Oak Ave")
                .stringType("city", "Los Angeles")
                .stringType("state", "CA")
                .stringType("zipCode", "90001")
            .closeObject();

        return builder
            .given("user service is up")
            .uponReceiving("a request to create a user")
                .path("/users")
                .method("POST")
                .headers(Map.of("Content-Type", "application/json"))
                .body(requestBody)
            .willRespondWith()
                .status(201)
                .headers(Map.of("Content-Type", "application/json"))
                .body(responseBody)
            .toPact();
    }

    @Test
    @PactTestFor(pactMethod = "createUserPact")
    public void testCreateUser(MockServer mockServer) {
        // Arrange
        UserServiceClient client = new UserServiceClient(mockServer.getUrl());

        User newUser = User.builder()
            .name("Jane Smith")
            .email("jane.smith@example.com")
            .phoneNumber("+1-555-5678")
            .address(Address.builder()
                .street("456 Oak Ave")
                .city("Los Angeles")
                .state("CA")
                .zipCode("90001")
                .build())
            .build();

        // Act
        User createdUser = client.createUser(newUser);

        // Assert
        assertNotNull(createdUser);
        assertNotNull(createdUser.getId());
        assertEquals("Jane Smith", createdUser.getName());
        assertEquals("Los Angeles", createdUser.getAddress().getCity());
    }

    @Pact(consumer = "OrderService")
    public V4Pact searchUsersPact(PactDslWithProvider builder) {
        DslPart usersArray = PactDslJsonBody.arrayMinLike(1, 2)
            .numberType("id")
            .stringType("name")
            .stringMatcher("email", ".*@.*\\..*")
            .object("address")
                .stringType("city", "New York")
                .stringType("state")
                .stringType("zipCode")
            .closeObject()
            .closeObject();

        return builder
            .given("users exist in New York")
            .uponReceiving("a request to search users by city")
                .path("/users/search")
                .method("GET")
                .query("city=New York")
            .willRespondWith()
                .status(200)
                .headers(Map.of("Content-Type", "application/json"))
                .body(usersArray)
            .toPact();
    }

    @Test
    @PactTestFor(pactMethod = "searchUsersPact")
    public void testSearchUsers(MockServer mockServer) {
        // Arrange
        UserServiceClient client = new UserServiceClient(mockServer.getUrl());

        // Act
        List<User> users = client.searchUsers("New York");

        // Assert
        assertNotNull(users);
        assertFalse(users.isEmpty());
        assertTrue(users.size() >= 1);
        users.forEach(user -> {
            assertEquals("New York", user.getAddress().getCity());
            assertTrue(user.getEmail().matches(".*@.*\\..*"));
        });
    }

    @Pact(consumer = "OrderService")
    public V4Pact getUserNotFoundPact(PactDslWithProvider builder) {
        DslPart errorBody = new PactDslJsonBody()
            .stringType("error", "User not found")
            .numberType("code", 404)
            .stringType("message", "User with ID 9999 does not exist");

        return builder
            .given("user 9999 does not exist")
            .uponReceiving("a request to get non-existent user")
                .path("/users/9999")
                .method("GET")
            .willRespondWith()
                .status(404)
                .headers(Map.of("Content-Type", "application/json"))
                .body(errorBody)
            .toPact();
    }

    @Test
    @PactTestFor(pactMethod = "getUserNotFoundPact")
    public void testGetUserNotFound(MockServer mockServer) {
        // Arrange
        UserServiceClient client = new UserServiceClient(mockServer.getUrl());

        // Act & Assert
        assertThrows(HttpClientErrorException.NotFound.class, () -> {
            client.getUserById(9999L);
        });
    }
}

// 5. Provider Pact Verification Tests
import au.com.dius.pact.provider.junit5.HttpTestTarget;
import au.com.dius.pact.provider.junit5.PactVerificationContext;
import au.com.dius.pact.provider.junit5.PactVerificationInvocationContextProvider;
import au.com.dius.pact.provider.junitsupport.Provider;
import au.com.dius.pact.provider.junitsupport.State;
import au.com.dius.pact.provider.junitsupport.loader.PactFolder;
import au.com.dius.pact.provider.spring.junit5.PactVerificationSpringProvider;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.TestTemplate;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.server.LocalServerPort;
import org.springframework.test.context.junit.jupiter.SpringExtension;

@ExtendWith(SpringExtension.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@Provider("UserService")
@PactFolder("pacts") // Location of pact files
public class UserServiceProviderPactTest {

    @LocalServerPort
    private int port;

    @BeforeEach
    void setup(PactVerificationContext context) {
        context.setTarget(new HttpTestTarget("localhost", port));
    }

    @TestTemplate
    @ExtendWith(PactVerificationInvocationContextProvider.class)
    void verifyPact(PactVerificationContext context) {
        context.verifyInteraction();
    }

    @State("user 1001 exists")
    public void userExists() {
        // Setup state: Create or mock user with ID 1001
        // This could involve:
        // - Creating test data in database
        // - Mocking repository responses
        // - Setting up test fixtures

        User testUser = User.builder()
            .id(1001L)
            .name("John Doe")
            .email("john.doe@example.com")
            .phoneNumber("+1-555-1234")
            .address(Address.builder()
                .street("123 Main St")
                .city("New York")
                .state("NY")
                .zipCode("10001")
                .build())
            .build();

        // userRepository.save(testUser);
        // or
        // when(userRepository.findById(1001L)).thenReturn(Optional.of(testUser));
    }

    @State("user service is up")
    public void serviceIsUp() {
        // Ensure service dependencies are available
        // This is typically the default state
    }

    @State("users exist in New York")
    public void usersExistInNewYork() {
        // Create multiple users in New York
        List<User> nyUsers = List.of(
            User.builder()
                .id(101L)
                .name("Alice Brown")
                .email("alice@example.com")
                .address(Address.builder().city("New York").state("NY").build())
                .build(),
            User.builder()
                .id(102L)
                .name("Bob Wilson")
                .email("bob@example.com")
                .address(Address.builder().city("New York").state("NY").build())
                .build()
        );

        // userRepository.saveAll(nyUsers);
    }

    @State("user 9999 does not exist")
    public void userDoesNotExist() {
        // Ensure user 9999 is not in database
        // userRepository.deleteById(9999L);
    }
}

// 6. Pact Broker Configuration
public class PactBrokerConfig {
    private String brokerUrl;
    private String consumerVersion;
    private List<String> tags;

    // Configuration for publishing pacts
    public static void publishPactsToBroker() {
        /*
        In pom.xml:

        <plugin>
            <groupId>au.com.dius.pact.provider</groupId>
            <artifactId>maven</artifactId>
            <version>4.6.0</version>
            <configuration>
                <pactBrokerUrl>https://your-pact-broker.com</pactBrokerUrl>
                <pactBrokerToken>your-token</pactBrokerToken>
                <projectVersion>${git.commit.id.abbrev}</projectVersion>
                <tags>
                    <tag>main</tag>
                    <tag>prod</tag>
                </tags>
            </configuration>
        </plugin>

        Run: mvn pact:publish
        */
    }

    // Provider verification from broker
    /*
    @Provider("UserService")
    @PactBroker(
        host = "your-pact-broker.com",
        port = "443",
        scheme = "https",
        authentication = @PactBrokerAuth(token = "your-token")
    )
    public class UserServiceProviderBrokerTest {
        // Verification tests
    }
    */
}

// 7. Advanced Pact Features

// Provider States with Parameters
@State("user {userId} has {orderCount} orders")
public void userHasOrders(@Param("userId") Long userId, @Param("orderCount") int orderCount) {
    User user = createUser(userId);
    for (int i = 0; i < orderCount; i++) {
        createOrderForUser(user.getId());
    }
}

// Matching Rules and Generators
public class AdvancedPactMatchers {

    public static V4Pact orderPactWithMatchers(PactDslWithProvider builder) {
        DslPart orderBody = new PactDslJsonBody()
            // Exact match
            .numberType("id", 1001L)

            // Type matching
            .stringType("status", "PENDING")

            // Regex matching
            .stringMatcher("orderNumber", "ORD-\\d{6}", "ORD-123456")

            // Date/Time matching
            .datetime("createdAt", "yyyy-MM-dd'T'HH:mm:ss",
                     LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME))

            // Decimal matching
            .decimalType("totalAmount", 99.99)

            // Min/Max array size
            .minArrayLike("items", 1, 3)
                .numberType("productId")
                .stringType("productName")
                .integerType("quantity")
                .decimalType("price")
            .closeArray()

            // UUID matching
            .uuid("transactionId");

        return builder
            .given("order exists")
            .uponReceiving("request to get order")
                .path("/orders/1001")
                .method("GET")
            .willRespondWith()
                .status(200)
                .body(orderBody)
            .toPact();
    }
}

// 8. Pact Test Helper
public class PactTestHelper {

    // Verify pact file is generated
    public static boolean isPactFileGenerated(String consumerName, String providerName) {
        Path pactFile = Paths.get("target/pacts",
            consumerName + "-" + providerName + ".json");
        return Files.exists(pactFile);
    }

    // Read pact file
    public static String readPactFile(String consumerName, String providerName) throws IOException {
        Path pactFile = Paths.get("target/pacts",
            consumerName + "-" + providerName + ".json");
        return Files.readString(pactFile);
    }

    // Validate pact structure
    public static void validatePactStructure(String pactJson) {
        JSONObject pact = new JSONObject(pactJson);

        assertTrue(pact.has("consumer"), "Pact must have consumer");
        assertTrue(pact.has("provider"), "Pact must have provider");
        assertTrue(pact.has("interactions"), "Pact must have interactions");

        JSONArray interactions = pact.getJSONArray("interactions");
        assertTrue(interactions.length() > 0, "Pact must have at least one interaction");
    }
}

// 9. CI/CD Integration
public class PactCICDIntegration {

    /*
    # Consumer CI Pipeline (Jenkinsfile)

    pipeline {
        agent any
        stages {
            stage('Run Pact Consumer Tests') {
                steps {
                    sh 'mvn clean test -Dtest=*ConsumerPactTest'
                }
            }
            stage('Publish Pacts to Broker') {
                steps {
                    sh 'mvn pact:publish'
                }
            }
        }
    }

    # Provider CI Pipeline (Jenkinsfile)

    pipeline {
        agent any
        stages {
            stage('Verify Pacts from Broker') {
                steps {
                    sh 'mvn test -Dtest=*ProviderPactTest'
                }
            }
            stage('Can I Deploy?') {
                steps {
                    sh '''
                        pact-broker can-i-deploy \
                          --pacticipant UserService \
                          --version $GIT_COMMIT \
                          --to production
                    '''
                }
            }
        }
    }
    */
}
```

**Complete Test Example - Microservices Scenario**:

```java
// Order Service (Consumer) tests User Service (Provider)

@ExtendWith(PactConsumerTestExt.class)
@PactTestFor(providerName = "UserService")
public class OrderServiceConsumerPactTest {

    @Pact(consumer = "OrderService")
    public V4Pact validateUserBeforeOrderPact(PactDslWithProvider builder) {
        return builder
            .given("user 1001 exists and is active")
            .uponReceiving("request to validate user for order creation")
                .path("/users/1001/validate")
                .method("GET")
            .willRespondWith()
                .status(200)
                .headers(Map.of("Content-Type", "application/json"))
                .body(new PactDslJsonBody()
                    .booleanType("isValid", true)
                    .stringType("status", "ACTIVE")
                    .numberType("creditLimit", 10000.0)
                )
            .toPact();
    }

    @Test
    @PactTestFor(pactMethod = "validateUserBeforeOrderPact")
    public void testValidateUserBeforeOrder(MockServer mockServer) {
        UserServiceClient client = new UserServiceClient(mockServer.getUrl());

        UserValidation validation = client.validateUser(1001L);

        assertTrue(validation.isValid());
        assertEquals("ACTIVE", validation.getStatus());
        assertTrue(validation.getCreditLimit() >= 1000.0);
    }
}
```

**Best Practices**:

1. **Keep Contracts Minimal**: Only include fields your consumer actually uses
2. **Use Type Matching**: Prefer type matching over exact value matching
3. **Version Your Contracts**: Tag contracts with version numbers
4. **Provider States**: Use clear, descriptive provider states
5. **Pact Broker**: Use broker for team collaboration
6. **CI/CD Integration**: Automate pact generation and verification
7. **Can-I-Deploy**: Check compatibility before deployment
8. **Regular Verification**: Run provider verification frequently
9. **Breaking Changes**: Use pact matrix to identify breaking changes
10. **Documentation**: Use pact files as living API documentation

**When to Use Contract Testing**:

âœ… **Use When**:
- Microservices architecture
- Multiple teams owning different services
- Need to catch breaking changes early
- Want fast feedback without integration environment
- Testing API integrations

âŒ **Don't Use When**:
- Monolithic architecture
- Single team owns all services
- Testing business logic
- End-to-end functional testing
- UI testing

**Follow-up**: How do you handle breaking changes in contract testing? What strategies do you use for versioning contracts? How do you integrate Pact with your CI/CD pipeline? How do you test bidirectional contracts where both services are consumers and providers of each other?

---

### **Q106. How do you implement robust error handling and retry mechanisms in API testing? Explain different retry strategies, exponential backoff, circuit breaker pattern, and error recovery.** (6-8 Years, 9-12 Years)

**Difficulty**: Hard
**Companies**: Amazon, Netflix, Uber, Google, Microsoft, Adobe, PayPal
**Topics**: Error Handling, Retry Logic, Exponential Backoff, Circuit Breaker, Resilience

**Answer**:

Robust error handling and retry mechanisms are critical for reliable API test automation, especially when dealing with flaky tests, transient network issues, rate limiting, and service unavailability. Implementing smart retry logic improves test stability without masking real failures.

**Key Concepts**:

1. **Retry Strategies**: Fixed delay, exponential backoff, random jitter
2. **Circuit Breaker**: Prevents cascading failures by stopping requests to failing services
3. **Error Recovery**: Graceful degradation and fallback mechanisms
4. **Idempotency**: Ensuring retries don't cause side effects
5. **Rate Limiting**: Respecting API rate limits

**Complete Implementation**:

```java
// 1. Retry Configuration
@Data
@Builder
@AllArgsConstructor
public class RetryConfig {
    @Builder.Default
    private int maxRetries = 3;

    @Builder.Default
    private long initialDelayMs = 1000;

    @Builder.Default
    private long maxDelayMs = 30000;

    @Builder.Default
    private double backoffMultiplier = 2.0;

    @Builder.Default
    private boolean useJitter = true;

    @Builder.Default
    private List<Integer> retryableStatusCodes = Arrays.asList(408, 429, 500, 502, 503, 504);

    @Builder.Default
    private List<Class<? extends Exception>> retryableExceptions =
        Arrays.asList(SocketTimeoutException.class, ConnectException.class);

    @Builder.Default
    private RetryStrategy strategy = RetryStrategy.EXPONENTIAL_BACKOFF;

    public enum RetryStrategy {
        FIXED_DELAY,
        EXPONENTIAL_BACKOFF,
        LINEAR_BACKOFF,
        FIBONACCI_BACKOFF
    }
}

// 2. Retry Exception - Custom exception for retry logic
public class RetryExhaustedException extends RuntimeException {
    private final int attemptsMade;
    private final Throwable lastException;

    public RetryExhaustedException(int attemptsMade, Throwable lastException) {
        super(String.format("Retry exhausted after %d attempts", attemptsMade), lastException);
        this.attemptsMade = attemptsMade;
        this.lastException = lastException;
    }

    public int getAttemptsMade() {
        return attemptsMade;
    }

    public Throwable getLastException() {
        return lastException;
    }
}

// 3. Retry Handler - Core retry logic
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Random;
import java.util.concurrent.Callable;
import java.util.function.Predicate;

public class RetryHandler {
    private static final Logger logger = LoggerFactory.getLogger(RetryHandler.class);
    private static final Random random = new Random();

    private final RetryConfig config;

    public RetryHandler(RetryConfig config) {
        this.config = config;
    }

    // Execute with retry
    public <T> T executeWithRetry(Callable<T> callable) throws RetryExhaustedException {
        return executeWithRetry(callable, null);
    }

    // Execute with retry and custom condition
    public <T> T executeWithRetry(Callable<T> callable, Predicate<T> retryCondition)
            throws RetryExhaustedException {

        int attempts = 0;
        Throwable lastException = null;

        while (attempts <= config.getMaxRetries()) {
            try {
                T result = callable.call();

                // Check if result meets retry condition
                if (retryCondition != null && retryCondition.test(result)) {
                    attempts++;
                    logger.warn("Retry condition met on attempt {}. Retrying...", attempts);

                    if (attempts <= config.getMaxRetries()) {
                        waitBeforeRetry(attempts);
                        continue;
                    }
                }

                // Success
                if (attempts > 0) {
                    logger.info("Operation succeeded after {} retries", attempts);
                }
                return result;

            } catch (Exception e) {
                attempts++;
                lastException = e;

                // Check if exception is retryable
                if (!isRetryableException(e)) {
                    logger.error("Non-retryable exception occurred: {}", e.getMessage());
                    throw new RetryExhaustedException(attempts, e);
                }

                logger.warn("Attempt {} failed with exception: {}. Retrying...",
                    attempts, e.getMessage());

                if (attempts <= config.getMaxRetries()) {
                    waitBeforeRetry(attempts);
                } else {
                    logger.error("All {} retry attempts exhausted", attempts);
                    throw new RetryExhaustedException(attempts, lastException);
                }
            }
        }

        throw new RetryExhaustedException(attempts, lastException);
    }

    // Wait before retry based on strategy
    private void waitBeforeRetry(int attemptNumber) {
        long delayMs = calculateDelay(attemptNumber);

        logger.info("Waiting {} ms before retry attempt {}", delayMs, attemptNumber + 1);

        try {
            Thread.sleep(delayMs);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException("Retry wait interrupted", e);
        }
    }

    // Calculate delay based on retry strategy
    private long calculateDelay(int attemptNumber) {
        long delay;

        switch (config.getStrategy()) {
            case FIXED_DELAY:
                delay = config.getInitialDelayMs();
                break;

            case EXPONENTIAL_BACKOFF:
                delay = (long) (config.getInitialDelayMs() *
                    Math.pow(config.getBackoffMultiplier(), attemptNumber - 1));
                break;

            case LINEAR_BACKOFF:
                delay = config.getInitialDelayMs() * attemptNumber;
                break;

            case FIBONACCI_BACKOFF:
                delay = config.getInitialDelayMs() * fibonacci(attemptNumber);
                break;

            default:
                delay = config.getInitialDelayMs();
        }

        // Cap at max delay
        delay = Math.min(delay, config.getMaxDelayMs());

        // Add jitter to prevent thundering herd
        if (config.isUseJitter()) {
            delay = addJitter(delay);
        }

        return delay;
    }

    // Add random jitter (Â±25%)
    private long addJitter(long delay) {
        double jitter = 0.25; // 25% jitter
        long jitterAmount = (long) (delay * jitter);
        return delay + random.nextLong(jitterAmount * 2) - jitterAmount;
    }

    // Fibonacci number calculation
    private int fibonacci(int n) {
        if (n <= 1) return 1;
        int a = 1, b = 1;
        for (int i = 2; i < n; i++) {
            int temp = a + b;
            a = b;
            b = temp;
        }
        return b;
    }

    // Check if exception is retryable
    private boolean isRetryableException(Exception e) {
        // Check if exception class is in retryable list
        for (Class<? extends Exception> retryableClass : config.getRetryableExceptions()) {
            if (retryableClass.isInstance(e)) {
                return true;
            }
        }

        // Check for HTTP status code exceptions
        if (e instanceof HttpStatusCodeException) {
            HttpStatusCodeException httpException = (HttpStatusCodeException) e;
            return config.getRetryableStatusCodes().contains(httpException.getRawStatusCode());
        }

        return false;
    }
}

// 4. REST Assured Retry Filter
import io.restassured.filter.Filter;
import io.restassured.filter.FilterContext;
import io.restassured.response.Response;
import io.restassured.specification.FilterableRequestSpecification;
import io.restassured.specification.FilterableResponseSpecification;

public class RetryFilter implements Filter {
    private final RetryConfig config;

    public RetryFilter(RetryConfig config) {
        this.config = config;
    }

    @Override
    public Response filter(FilterableRequestSpecification requestSpec,
                          FilterableResponseSpecification responseSpec,
                          FilterContext ctx) {

        RetryHandler retryHandler = new RetryHandler(config);

        try {
            return retryHandler.executeWithRetry(
                () -> ctx.next(requestSpec, responseSpec),
                response -> shouldRetry(response)
            );
        } catch (RetryExhaustedException e) {
            // Return last response if available
            if (e.getLastException() != null &&
                e.getLastException().getCause() instanceof Response) {
                return (Response) e.getLastException().getCause();
            }
            throw new RuntimeException("API call failed after retries", e);
        }
    }

    private boolean shouldRetry(Response response) {
        int statusCode = response.getStatusCode();
        return config.getRetryableStatusCodes().contains(statusCode);
    }
}

// 5. Circuit Breaker Implementation
import java.time.LocalDateTime;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;

public class CircuitBreaker {
    private static final Logger logger = LoggerFactory.getLogger(CircuitBreaker.class);

    private final String name;
    private final int failureThreshold;
    private final long resetTimeoutMs;
    private final long halfOpenTimeoutMs;

    private final AtomicInteger failureCount = new AtomicInteger(0);
    private final AtomicInteger successCount = new AtomicInteger(0);
    private final AtomicReference<State> state = new AtomicReference<>(State.CLOSED);
    private volatile LocalDateTime lastFailureTime;
    private volatile LocalDateTime stateChangedTime;

    public enum State {
        CLOSED,      // Normal operation
        OPEN,        // Circuit is open, fail fast
        HALF_OPEN    // Testing if service recovered
    }

    public CircuitBreaker(String name, int failureThreshold, long resetTimeoutMs,
                          long halfOpenTimeoutMs) {
        this.name = name;
        this.failureThreshold = failureThreshold;
        this.resetTimeoutMs = resetTimeoutMs;
        this.halfOpenTimeoutMs = halfOpenTimeoutMs;
        this.stateChangedTime = LocalDateTime.now();
    }

    // Execute call with circuit breaker
    public <T> T execute(Callable<T> callable) throws Exception {
        if (isOpen()) {
            // Check if we should transition to half-open
            if (shouldAttemptReset()) {
                transitionToHalfOpen();
            } else {
                throw new CircuitBreakerOpenException(
                    String.format("Circuit breaker '%s' is OPEN", name)
                );
            }
        }

        try {
            T result = callable.call();
            onSuccess();
            return result;

        } catch (Exception e) {
            onFailure();
            throw e;
        }
    }

    // Handle successful call
    private void onSuccess() {
        successCount.incrementAndGet();

        if (state.get() == State.HALF_OPEN) {
            // If successful in half-open state, reset circuit
            reset();
            logger.info("Circuit breaker '{}' recovered and closed", name);
        }

        failureCount.set(0);
    }

    // Handle failed call
    private void onFailure() {
        lastFailureTime = LocalDateTime.now();
        int failures = failureCount.incrementAndGet();

        logger.warn("Circuit breaker '{}' failure count: {}/{}", name, failures, failureThreshold);

        if (failures >= failureThreshold && state.get() == State.CLOSED) {
            trip();
        }

        if (state.get() == State.HALF_OPEN) {
            trip();
        }
    }

    // Trip the circuit (open it)
    private void trip() {
        state.set(State.OPEN);
        stateChangedTime = LocalDateTime.now();
        logger.error("Circuit breaker '{}' is now OPEN after {} failures", name, failureCount.get());
    }

    // Reset the circuit
    private void reset() {
        state.set(State.CLOSED);
        failureCount.set(0);
        stateChangedTime = LocalDateTime.now();
    }

    // Transition to half-open state
    private void transitionToHalfOpen() {
        state.set(State.HALF_OPEN);
        stateChangedTime = LocalDateTime.now();
        logger.info("Circuit breaker '{}' transitioned to HALF_OPEN", name);
    }

    // Check if circuit is open
    private boolean isOpen() {
        return state.get() == State.OPEN;
    }

    // Check if we should attempt to reset
    private boolean shouldAttemptReset() {
        if (lastFailureTime == null) return false;

        long timeSinceLastFailure = java.time.Duration.between(lastFailureTime,
            LocalDateTime.now()).toMillis();

        return timeSinceLastFailure >= resetTimeoutMs;
    }

    // Get current state
    public State getState() {
        return state.get();
    }

    // Get metrics
    public CircuitBreakerMetrics getMetrics() {
        return new CircuitBreakerMetrics(
            name,
            state.get(),
            failureCount.get(),
            successCount.get(),
            stateChangedTime
        );
    }
}

@Data
@AllArgsConstructor
public class CircuitBreakerMetrics {
    private String name;
    private CircuitBreaker.State state;
    private int failureCount;
    private int successCount;
    private LocalDateTime stateChangedTime;
}

public class CircuitBreakerOpenException extends RuntimeException {
    public CircuitBreakerOpenException(String message) {
        super(message);
    }
}

// 6. Rate Limiter
import com.google.common.util.concurrent.RateLimiter;

public class APIRateLimiter {
    private static final Logger logger = LoggerFactory.getLogger(APIRateLimiter.class);

    private final RateLimiter rateLimiter;
    private final double permitsPerSecond;

    public APIRateLimiter(double permitsPerSecond) {
        this.permitsPerSecond = permitsPerSecond;
        this.rateLimiter = RateLimiter.create(permitsPerSecond);
    }

    // Execute with rate limiting
    public <T> T execute(Callable<T> callable) throws Exception {
        // Acquire permit (blocks if necessary)
        double waitTime = rateLimiter.acquire();

        if (waitTime > 0) {
            logger.info("Rate limited: waited {} seconds", waitTime);
        }

        return callable.call();
    }

    // Try execute without blocking
    public <T> Optional<T> tryExecute(Callable<T> callable, long timeoutMs) {
        if (rateLimiter.tryAcquire(timeoutMs, TimeUnit.MILLISECONDS)) {
            try {
                return Optional.of(callable.call());
            } catch (Exception e) {
                logger.error("Execution failed: {}", e.getMessage());
                return Optional.empty();
            }
        }

        logger.warn("Rate limit exceeded, request rejected");
        return Optional.empty();
    }
}

// 7. Error Response Handler
@Data
@Builder
public class ErrorResponse {
    private int statusCode;
    private String errorMessage;
    private String errorCode;
    private LocalDateTime timestamp;
    private Map<String, Object> details;
}

public class ErrorResponseHandler {
    private static final Logger logger = LoggerFactory.getLogger(ErrorResponseHandler.class);

    // Parse error response
    public static ErrorResponse parseErrorResponse(Response response) {
        try {
            return ErrorResponse.builder()
                .statusCode(response.getStatusCode())
                .errorMessage(response.jsonPath().getString("error.message"))
                .errorCode(response.jsonPath().getString("error.code"))
                .timestamp(LocalDateTime.now())
                .details(response.jsonPath().getMap("error.details"))
                .build();

        } catch (Exception e) {
            logger.warn("Failed to parse error response: {}", e.getMessage());

            return ErrorResponse.builder()
                .statusCode(response.getStatusCode())
                .errorMessage(response.getBody().asString())
                .timestamp(LocalDateTime.now())
                .build();
        }
    }

    // Categorize error
    public static ErrorCategory categorizeError(int statusCode) {
        return switch (statusCode / 100) {
            case 4 -> ErrorCategory.CLIENT_ERROR;
            case 5 -> ErrorCategory.SERVER_ERROR;
            default -> ErrorCategory.UNKNOWN;
        };
    }

    public enum ErrorCategory {
        CLIENT_ERROR,    // 4xx - Don't retry
        SERVER_ERROR,    // 5xx - Retry
        NETWORK_ERROR,   // Connection issues - Retry
        TIMEOUT_ERROR,   // Timeout - Retry
        UNKNOWN          // Unknown - Handle cautiously
    }

    // Determine if error is retryable
    public static boolean isRetryable(Response response) {
        int statusCode = response.getStatusCode();

        // Retryable status codes
        if (List.of(408, 429, 500, 502, 503, 504).contains(statusCode)) {
            return true;
        }

        // Check for rate limiting headers
        if (statusCode == 429) {
            String retryAfter = response.getHeader("Retry-After");
            if (retryAfter != null) {
                logger.info("Rate limited. Retry after: {}", retryAfter);
                return true;
            }
        }

        return false;
    }

    // Get retry delay from response
    public static long getRetryDelayMs(Response response) {
        // Check Retry-After header
        String retryAfter = response.getHeader("Retry-After");
        if (retryAfter != null) {
            try {
                // Try parsing as seconds
                return Long.parseLong(retryAfter) * 1000;
            } catch (NumberFormatException e) {
                // Try parsing as HTTP date
                try {
                    LocalDateTime retryTime = LocalDateTime.parse(retryAfter,
                        DateTimeFormatter.RFC_1123_DATE_TIME);
                    return Duration.between(LocalDateTime.now(), retryTime).toMillis();
                } catch (Exception ex) {
                    logger.warn("Failed to parse Retry-After header: {}", retryAfter);
                }
            }
        }

        // Default delay
        return 1000;
    }
}

// 8. Resilient API Client
public class ResilientAPIClient {
    private final RequestSpecification baseSpec;
    private final RetryHandler retryHandler;
    private final CircuitBreaker circuitBreaker;
    private final APIRateLimiter rateLimiter;

    public ResilientAPIClient(RequestSpecification baseSpec,
                             RetryConfig retryConfig,
                             CircuitBreaker circuitBreaker,
                             APIRateLimiter rateLimiter) {
        this.baseSpec = baseSpec;
        this.retryHandler = new RetryHandler(retryConfig);
        this.circuitBreaker = circuitBreaker;
        this.rateLimiter = rateLimiter;
    }

    // Execute GET with full resilience
    public Response get(String endpoint) {
        return executeWithResilience(() ->
            given()
                .spec(baseSpec)
                .when()
                .get(endpoint)
        );
    }

    // Execute POST with full resilience
    public Response post(String endpoint, Object body) {
        return executeWithResilience(() ->
            given()
                .spec(baseSpec)
                .body(body)
                .when()
                .post(endpoint)
        );
    }

    // Execute with retry, circuit breaker, and rate limiting
    private Response executeWithResilience(Callable<Response> callable) {
        try {
            // Apply rate limiting
            return rateLimiter.execute(() ->
                // Apply circuit breaker
                circuitBreaker.execute(() ->
                    // Apply retry logic
                    retryHandler.executeWithRetry(callable, ErrorResponseHandler::isRetryable)
                )
            );

        } catch (CircuitBreakerOpenException e) {
            logger.error("Circuit breaker is open: {}", e.getMessage());
            throw new RuntimeException("Service unavailable due to circuit breaker", e);

        } catch (RetryExhaustedException e) {
            logger.error("All retries exhausted: {}", e.getMessage());
            throw new RuntimeException("API call failed after all retries", e);

        } catch (Exception e) {
            logger.error("Unexpected error: {}", e.getMessage(), e);
            throw new RuntimeException("API call failed", e);
        }
    }
}
```

**Complete Test Examples**:

```java
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.Test;

public class ErrorHandlingRetryTests {
    private RequestSpecification requestSpec;

    @BeforeMethod
    public void setup() {
        requestSpec = SpecificationBuilder.getBaseRequestSpec();
    }

    // Test 1: Retry with exponential backoff
    @Test
    public void testRetryWithExponentialBackoff() {
        RetryConfig config = RetryConfig.builder()
            .maxRetries(3)
            .initialDelayMs(1000)
            .backoffMultiplier(2.0)
            .strategy(RetryConfig.RetryStrategy.EXPONENTIAL_BACKOFF)
            .useJitter(true)
            .build();

        RetryHandler retryHandler = new RetryHandler(config);

        Response response = retryHandler.executeWithRetry(() ->
            given()
                .spec(requestSpec)
                .when()
                .get("/flaky-endpoint"),
            ErrorResponseHandler::isRetryable
        );

        Assert.assertEquals(response.getStatusCode(), 200);
    }

    // Test 2: Circuit breaker pattern
    @Test
    public void testCircuitBreaker() {
        CircuitBreaker circuitBreaker = new CircuitBreaker(
            "user-service",
            3,           // failure threshold
            10000,       // reset timeout 10s
            5000         // half-open timeout 5s
        );

        // Make multiple calls
        for (int i = 0; i < 5; i++) {
            try {
                circuitBreaker.execute(() ->
                    given()
                        .spec(requestSpec)
                        .when()
                        .get("/users/" + i)
                );
            } catch (CircuitBreakerOpenException e) {
                logger.info("Circuit breaker prevented call #{}", i + 1);
            } catch (Exception e) {
                logger.error("Call #{} failed: {}", i + 1, e.getMessage());
            }
        }

        // Check circuit breaker state
        CircuitBreakerMetrics metrics = circuitBreaker.getMetrics();
        logger.info("Circuit breaker state: {}", metrics.getState());
        logger.info("Failure count: {}", metrics.getFailureCount());
    }

    // Test 3: Rate limiting
    @Test
    public void testRateLimiting() {
        APIRateLimiter rateLimiter = new APIRateLimiter(2.0); // 2 requests per second

        long startTime = System.currentTimeMillis();

        // Make 5 requests
        for (int i = 0; i < 5; i++) {
            try {
                rateLimiter.execute(() ->
                    given()
                        .spec(requestSpec)
                        .when()
                        .get("/users/" + i)
                );
            } catch (Exception e) {
                logger.error("Request #{} failed: {}", i + 1, e.getMessage());
            }
        }

        long duration = System.currentTimeMillis() - startTime;

        // Should take at least 2 seconds (5 requests at 2 req/s)
        Assert.assertTrue(duration >= 2000, "Rate limiting not applied");
    }

    // Test 4: Full resilient client
    @Test
    public void testResilientClient() {
        RetryConfig retryConfig = RetryConfig.builder()
            .maxRetries(3)
            .initialDelayMs(500)
            .strategy(RetryConfig.RetryStrategy.EXPONENTIAL_BACKOFF)
            .build();

        CircuitBreaker circuitBreaker = new CircuitBreaker("api-service", 5, 30000, 10000);
        APIRateLimiter rateLimiter = new APIRateLimiter(10.0);

        ResilientAPIClient client = new ResilientAPIClient(
            requestSpec, retryConfig, circuitBreaker, rateLimiter
        );

        Response response = client.get("/users/1");

        Assert.assertEquals(response.getStatusCode(), 200);
    }

    // Test 5: Handle 429 Too Many Requests
    @Test
    public void testHandle429RateLimitError() {
        RetryConfig config = RetryConfig.builder()
            .maxRetries(5)
            .retryableStatusCodes(List.of(429, 503))
            .build();

        RetryHandler retryHandler = new RetryHandler(config);

        Response response = retryHandler.executeWithRetry(() -> {
            Response resp = given()
                .spec(requestSpec)
                .when()
                .get("/rate-limited-endpoint");

            // If rate limited, extract retry-after and wait
            if (resp.getStatusCode() == 429) {
                long retryDelay = ErrorResponseHandler.getRetryDelayMs(resp);
                logger.info("Rate limited. Retrying after {} ms", retryDelay);
                Thread.sleep(retryDelay);
            }

            return resp;
        });

        Assert.assertTrue(response.getStatusCode() < 400);
    }
}
```

**Best Practices**:

1. **Idempotency**: Ensure retry-safe operations (use idempotency keys)
2. **Exponential Backoff**: Use increasing delays to reduce load
3. **Add Jitter**: Prevent thundering herd problem
4. **Limit Retries**: Don't retry indefinitely
5. **Circuit Breaker**: Fail fast when service is down
6. **Distinguish Errors**: Don't retry client errors (4xx)
7. **Log Retries**: Track retry attempts for debugging
8. **Respect Rate Limits**: Honor Retry-After headers
9. **Timeout Configuration**: Set appropriate timeouts
10. **Monitor Metrics**: Track retry rates and circuit breaker state

**When to Retry vs Not Retry**:

âœ… **Retry**:
- 408 Request Timeout
- 429 Too Many Requests
- 500 Internal Server Error
- 502 Bad Gateway
- 503 Service Unavailable
- 504 Gateway Timeout
- Network timeouts
- Connection refused

âŒ **Don't Retry**:
- 400 Bad Request
- 401 Unauthorized
- 403 Forbidden
- 404 Not Found
- 405 Method Not Allowed
- Non-idempotent operations (unless using idempotency keys)

**Follow-up**: How do you handle idempotency in retry logic? What metrics do you track for retry mechanisms? How do you test circuit breaker behavior? How do you handle distributed rate limiting across multiple test runners?

---

### **Q107. How do you test file upload and download operations in REST APIs using REST Assured? Explain multipart form data, binary file handling, and file validation.** (6-8 Years, 9-12 Years)

**Difficulty**: Medium
**Companies**: Amazon, Google, Microsoft, Dropbox, Adobe, Box, Netflix
**Topics**: File Upload, File Download, Multipart Form Data, Binary Files, Streaming

**Answer**:

File upload and download testing is crucial for APIs that handle documents, images, videos, or any binary data. REST Assured provides comprehensive support for multipart requests, file uploads, downloads, and validation.

**Key Concepts**:

1. **Multipart Form Data**: Upload files with additional form fields
2. **Binary File Upload**: Send files as binary data
3. **File Download**: Retrieve and validate downloaded files
4. **Streaming**: Handle large file uploads/downloads efficiently
5. **Content-Type**: Proper MIME type handling

**Complete Implementation**:

```java
// 1. File Upload Helper
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.MessageDigest;
import java.util.Base64;

public class FileUploadHelper {
    private static final Logger logger = LoggerFactory.getLogger(FileUploadHelper.class);

    // Upload single file with multipart
    public static Response uploadFile(RequestSpecification requestSpec,
                                     String endpoint,
                                     File file,
                                     String controlName) {
        return given()
            .spec(requestSpec)
            .multiPart(controlName, file)
            .when()
            .post(endpoint);
    }

    // Upload file with additional form data
    public static Response uploadFileWithFormData(RequestSpecification requestSpec,
                                                  String endpoint,
                                                  File file,
                                                  String fileControlName,
                                                  Map<String, String> formData) {
        RequestSpecification request = given().spec(requestSpec);

        // Add file
        request.multiPart(fileControlName, file);

        // Add form fields
        formData.forEach(request::formParam);

        return request.when().post(endpoint);
    }

    // Upload file with specific content type
    public static Response uploadFileWithContentType(RequestSpecification requestSpec,
                                                    String endpoint,
                                                    File file,
                                                    String controlName,
                                                    String mimeType) {
        return given()
            .spec(requestSpec)
            .multiPart(controlName, file, mimeType)
            .when()
            .post(endpoint);
    }

    // Upload multiple files
    public static Response uploadMultipleFiles(RequestSpecification requestSpec,
                                              String endpoint,
                                              Map<String, File> files) {
        RequestSpecification request = given().spec(requestSpec);

        files.forEach((controlName, file) -> {
            request.multiPart(controlName, file);
        });

        return request.when().post(endpoint);
    }

    // Upload file as byte array
    public static Response uploadFileAsBytes(RequestSpecification requestSpec,
                                            String endpoint,
                                            String controlName,
                                            String fileName,
                                            byte[] fileContent,
                                            String mimeType) {
        return given()
            .spec(requestSpec)
            .multiPart(controlName, fileName, fileContent, mimeType)
            .when()
            .post(endpoint);
    }

    // Upload file with InputStream
    public static Response uploadFileAsStream(RequestSpecification requestSpec,
                                             String endpoint,
                                             String controlName,
                                             String fileName,
                                             InputStream inputStream,
                                             String mimeType) {
        return given()
            .spec(requestSpec)
            .multiPart(controlName, fileName, inputStream, mimeType)
            .when()
            .post(endpoint);
    }

    // Upload binary file directly in request body
    public static Response uploadBinaryFile(RequestSpecification requestSpec,
                                           String endpoint,
                                           File file,
                                           String contentType) throws IOException {
        byte[] fileBytes = Files.readAllBytes(file.toPath());

        return given()
            .spec(requestSpec)
            .contentType(contentType)
            .body(fileBytes)
            .when()
            .post(endpoint);
    }

    // Upload Base64 encoded file
    public static Response uploadBase64File(RequestSpecification requestSpec,
                                           String endpoint,
                                           File file) throws IOException {
        byte[] fileBytes = Files.readAllBytes(file.toPath());
        String base64Content = Base64.getEncoder().encodeToString(fileBytes);

        Map<String, String> requestBody = Map.of(
            "fileName", file.getName(),
            "content", base64Content,
            "encoding", "base64"
        );

        return given()
            .spec(requestSpec)
            .contentType(ContentType.JSON)
            .body(requestBody)
            .when()
            .post(endpoint);
    }

    // Generate test file
    public static File generateTestFile(String fileName, String content) throws IOException {
        File file = new File(System.getProperty("java.io.tmpdir"), fileName);
        FileUtils.writeStringToFile(file, content, "UTF-8");
        return file;
    }

    // Generate binary test file
    public static File generateBinaryFile(String fileName, int sizeInKB) throws IOException {
        File file = new File(System.getProperty("java.io.tmpdir"), fileName);
        byte[] data = new byte[sizeInKB * 1024];
        new Random().nextBytes(data);
        FileUtils.writeByteArrayToFile(file, data);
        return file;
    }

    // Calculate file checksum
    public static String calculateChecksum(File file) throws Exception {
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        byte[] fileBytes = Files.readAllBytes(file.toPath());
        byte[] hashBytes = digest.digest(fileBytes);

        StringBuilder hexString = new StringBuilder();
        for (byte b : hashBytes) {
            String hex = Integer.toHexString(0xff & b);
            if (hex.length() == 1) hexString.append('0');
            hexString.append(hex);
        }
        return hexString.toString();
    }
}

// 2. File Download Helper
public class FileDownloadHelper {
    private static final Logger logger = LoggerFactory.getLogger(FileDownloadHelper.class);

    // Download file and save to disk
    public static File downloadFile(RequestSpecification requestSpec,
                                   String endpoint,
                                   String targetDirectory,
                                   String fileName) {
        Response response = given()
            .spec(requestSpec)
            .when()
            .get(endpoint);

        byte[] fileBytes = response.asByteArray();

        File downloadedFile = new File(targetDirectory, fileName);
        try {
            FileUtils.writeByteArrayToFile(downloadedFile, fileBytes);
            logger.info("File downloaded: {} ({} bytes)", fileName, fileBytes.length);
        } catch (IOException e) {
            throw new RuntimeException("Failed to save downloaded file", e);
        }

        return downloadedFile;
    }

    // Download file and return as byte array
    public static byte[] downloadFileAsBytes(RequestSpecification requestSpec,
                                            String endpoint) {
        Response response = given()
            .spec(requestSpec)
            .when()
            .get(endpoint);

        response.then().statusCode(200);
        return response.asByteArray();
    }

    // Download file with validation
    public static File downloadAndValidateFile(RequestSpecification requestSpec,
                                              String endpoint,
                                              String targetDirectory,
                                              String fileName,
                                              String expectedContentType,
                                              long expectedMinSize) {
        Response response = given()
            .spec(requestSpec)
            .when()
            .get(endpoint);

        // Validate response
        response.then()
            .statusCode(200)
            .contentType(expectedContentType);

        byte[] fileBytes = response.asByteArray();

        // Validate size
        if (fileBytes.length < expectedMinSize) {
            throw new AssertionError(
                String.format("Downloaded file size (%d bytes) is less than expected (%d bytes)",
                    fileBytes.length, expectedMinSize)
            );
        }

        // Save file
        File downloadedFile = new File(targetDirectory, fileName);
        try {
            FileUtils.writeByteArrayToFile(downloadedFile, fileBytes);
            logger.info("File downloaded and validated: {} ({} bytes)",
                fileName, fileBytes.length);
        } catch (IOException e) {
            throw new RuntimeException("Failed to save downloaded file", e);
        }

        return downloadedFile;
    }

    // Extract filename from Content-Disposition header
    public static String extractFileName(Response response) {
        String contentDisposition = response.getHeader("Content-Disposition");

        if (contentDisposition != null && contentDisposition.contains("filename=")) {
            String fileName = contentDisposition.substring(
                contentDisposition.indexOf("filename=") + 9
            );

            // Remove quotes if present
            fileName = fileName.replaceAll("\"", "");

            // Handle filename*=UTF-8'' format
            if (fileName.contains("UTF-8''")) {
                fileName = fileName.substring(fileName.indexOf("UTF-8''") + 7);
                try {
                    fileName = java.net.URLDecoder.decode(fileName, "UTF-8");
                } catch (UnsupportedEncodingException e) {
                    logger.warn("Failed to decode filename: {}", fileName);
                }
            }

            return fileName;
        }

        return "downloaded_file";
    }

    // Download with progress tracking (for large files)
    public static File downloadLargeFile(RequestSpecification requestSpec,
                                        String endpoint,
                                        String targetDirectory,
                                        String fileName,
                                        ProgressCallback progressCallback) throws IOException {

        Response response = given()
            .spec(requestSpec)
            .when()
            .get(endpoint);

        InputStream inputStream = response.asInputStream();
        File targetFile = new File(targetDirectory, fileName);

        long totalBytes = response.getContentLength();
        long downloadedBytes = 0;

        try (FileOutputStream outputStream = new FileOutputStream(targetFile)) {
            byte[] buffer = new byte[8192];
            int bytesRead;

            while ((bytesRead = inputStream.read(buffer)) != -1) {
                outputStream.write(buffer, 0, bytesRead);
                downloadedBytes += bytesRead;

                if (progressCallback != null) {
                    int progress = (int) ((downloadedBytes * 100) / totalBytes);
                    progressCallback.onProgress(progress, downloadedBytes, totalBytes);
                }
            }
        }

        logger.info("Large file downloaded: {} ({} bytes)", fileName, downloadedBytes);
        return targetFile;
    }

    @FunctionalInterface
    public interface ProgressCallback {
        void onProgress(int percentage, long downloadedBytes, long totalBytes);
    }
}

// 3. File Validator
public class FileValidator {
    private static final Logger logger = LoggerFactory.getLogger(FileValidator.class);

    // Validate file exists and not empty
    public static void validateFileExists(File file) {
        Assert.assertTrue(file.exists(), "File does not exist: " + file.getAbsolutePath());
        Assert.assertTrue(file.length() > 0, "File is empty: " + file.getAbsolutePath());
    }

    // Validate file size
    public static void validateFileSize(File file, long minSize, long maxSize) {
        long fileSize = file.length();
        Assert.assertTrue(fileSize >= minSize,
            String.format("File size (%d) is less than minimum (%d)", fileSize, minSize));
        Assert.assertTrue(fileSize <= maxSize,
            String.format("File size (%d) exceeds maximum (%d)", fileSize, maxSize));
    }

    // Validate file content type by extension
    public static void validateFileExtension(File file, String expectedExtension) {
        String fileName = file.getName();
        String actualExtension = fileName.substring(fileName.lastIndexOf(".") + 1);
        Assert.assertEquals(actualExtension.toLowerCase(), expectedExtension.toLowerCase(),
            "File extension mismatch");
    }

    // Validate file content
    public static void validateTextFileContent(File file, String expectedContent)
            throws IOException {
        String actualContent = FileUtils.readFileToString(file, "UTF-8");
        Assert.assertEquals(actualContent, expectedContent, "File content mismatch");
    }

    // Validate file contains text
    public static void validateFileContainsText(File file, String searchText)
            throws IOException {
        String content = FileUtils.readFileToString(file, "UTF-8");
        Assert.assertTrue(content.contains(searchText),
            "File does not contain expected text: " + searchText);
    }

    // Validate file checksum
    public static void validateFileChecksum(File file, String expectedChecksum)
            throws Exception {
        String actualChecksum = FileUploadHelper.calculateChecksum(file);
        Assert.assertEquals(actualChecksum, expectedChecksum,
            "File checksum mismatch - file may be corrupted");
    }

    // Validate image file
    public static void validateImageFile(File file, int expectedMinWidth, int expectedMinHeight)
            throws IOException {
        BufferedImage image = ImageIO.read(file);
        Assert.assertNotNull(image, "Invalid image file");

        int width = image.getWidth();
        int height = image.getHeight();

        Assert.assertTrue(width >= expectedMinWidth,
            String.format("Image width (%d) is less than expected (%d)", width, expectedMinWidth));
        Assert.assertTrue(height >= expectedMinHeight,
            String.format("Image height (%d) is less than expected (%d)", height, expectedMinHeight));

        logger.info("Image validated: {}x{}", width, height);
    }

    // Validate PDF file
    public static void validatePDFFile(File file, int expectedMinPages) throws IOException {
        try (PDDocument document = PDDocument.load(file)) {
            int pageCount = document.getNumberOfPages();
            Assert.assertTrue(pageCount >= expectedMinPages,
                String.format("PDF has %d pages, expected at least %d", pageCount, expectedMinPages));

            logger.info("PDF validated: {} pages", pageCount);
        }
    }

    // Validate CSV file structure
    public static void validateCSVFile(File file, String[] expectedHeaders) throws IOException {
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            String headerLine = reader.readLine();
            Assert.assertNotNull(headerLine, "CSV file is empty");

            String[] actualHeaders = headerLine.split(",");
            Assert.assertEquals(actualHeaders, expectedHeaders, "CSV headers mismatch");

            logger.info("CSV validated: {} columns", actualHeaders.length);
        }
    }

    // Validate file is not corrupted
    public static void validateFileIntegrity(File originalFile, File downloadedFile)
            throws Exception {
        String originalChecksum = FileUploadHelper.calculateChecksum(originalFile);
        String downloadedChecksum = FileUploadHelper.calculateChecksum(downloadedFile);

        Assert.assertEquals(downloadedChecksum, originalChecksum,
            "File integrity check failed - checksums don't match");

        logger.info("File integrity validated - checksums match: {}", originalChecksum);
    }
}

// 4. Multipart Request Builder
@Builder
public class MultipartRequestBuilder {
    private RequestSpecification baseSpec;

    @Singular
    private Map<String, File> files;

    @Singular
    private Map<String, String> formFields;

    @Singular
    private Map<String, Object> jsonParts;

    public Response execute(String endpoint, String method) {
        RequestSpecification request = given().spec(baseSpec);

        // Add files
        if (files != null) {
            files.forEach((controlName, file) -> {
                String mimeType = detectMimeType(file);
                request.multiPart(controlName, file, mimeType);
            });
        }

        // Add form fields
        if (formFields != null) {
            formFields.forEach(request::formParam);
        }

        // Add JSON parts
        if (jsonParts != null) {
            jsonParts.forEach((name, value) -> {
                request.multiPart(name, value, "application/json");
            });
        }

        return switch (method.toUpperCase()) {
            case "POST" -> request.when().post(endpoint);
            case "PUT" -> request.when().put(endpoint);
            case "PATCH" -> request.when().patch(endpoint);
            default -> throw new IllegalArgumentException("Unsupported method: " + method);
        };
    }

    private String detectMimeType(File file) {
        String fileName = file.getName().toLowerCase();

        if (fileName.endsWith(".jpg") || fileName.endsWith(".jpeg")) return "image/jpeg";
        if (fileName.endsWith(".png")) return "image/png";
        if (fileName.endsWith(".gif")) return "image/gif";
        if (fileName.endsWith(".pdf")) return "application/pdf";
        if (fileName.endsWith(".txt")) return "text/plain";
        if (fileName.endsWith(".csv")) return "text/csv";
        if (fileName.endsWith(".json")) return "application/json";
        if (fileName.endsWith(".xml")) return "application/xml";
        if (fileName.endsWith(".zip")) return "application/zip";

        return "application/octet-stream";
    }
}

// 5. File Upload Response Model
@Data
@Builder
public class FileUploadResponse {
    private String fileId;
    private String fileName;
    private String fileUrl;
    private long fileSize;
    private String contentType;
    private String checksum;
    private LocalDateTime uploadedAt;
    private Map<String, Object> metadata;
}
```

**Complete Test Examples**:

```java
import org.testng.annotations.AfterClass;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.Test;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.File;

public class FileUploadDownloadTests {
    private RequestSpecification requestSpec;
    private String uploadEndpoint = "/files/upload";
    private String downloadEndpoint = "/files/{fileId}/download";
    private String tempDir;

    @BeforeClass
    public void setup() {
        requestSpec = SpecificationBuilder.getBaseRequestSpec();
        tempDir = System.getProperty("java.io.tmpdir") + "/api-test-files/";
        new File(tempDir).mkdirs();
    }

    @AfterClass
    public void cleanup() throws IOException {
        FileUtils.deleteDirectory(new File(tempDir));
    }

    // Test 1: Simple file upload
    @Test
    public void testSimpleFileUpload() throws IOException {
        // Create test file
        File testFile = FileUploadHelper.generateTestFile("test.txt", "Hello World!");

        // Upload file
        Response response = FileUploadHelper.uploadFile(
            requestSpec,
            uploadEndpoint,
            testFile,
            "file"
        );

        // Validate response
        response.then()
            .statusCode(201)
            .body("fileName", equalTo("test.txt"))
            .body("fileSize", equalTo((int) testFile.length()))
            .body("contentType", equalTo("text/plain"));

        // Extract file ID for later use
        String fileId = response.jsonPath().getString("fileId");
        Assert.assertNotNull(fileId);
    }

    // Test 2: Upload file with form data
    @Test
    public void testUploadFileWithFormData() throws IOException {
        File testFile = FileUploadHelper.generateTestFile("document.txt", "Test content");

        Map<String, String> formData = Map.of(
            "description", "Test document",
            "category", "reports",
            "tags", "test,sample"
        );

        Response response = FileUploadHelper.uploadFileWithFormData(
            requestSpec,
            uploadEndpoint,
            testFile,
            "file",
            formData
        );

        response.then()
            .statusCode(201)
            .body("metadata.description", equalTo("Test document"))
            .body("metadata.category", equalTo("reports"))
            .body("metadata.tags", equalTo("test,sample"));
    }

    // Test 3: Upload multiple files
    @Test
    public void testUploadMultipleFiles() throws IOException {
        File file1 = FileUploadHelper.generateTestFile("file1.txt", "Content 1");
        File file2 = FileUploadHelper.generateTestFile("file2.txt", "Content 2");
        File file3 = FileUploadHelper.generateTestFile("file3.txt", "Content 3");

        Map<String, File> files = Map.of(
            "file1", file1,
            "file2", file2,
            "file3", file3
        );

        Response response = FileUploadHelper.uploadMultipleFiles(
            requestSpec,
            "/files/upload/batch",
            files
        );

        response.then()
            .statusCode(201)
            .body("uploadedFiles.size()", equalTo(3))
            .body("uploadedFiles[0].fileName", equalTo("file1.txt"))
            .body("uploadedFiles[1].fileName", equalTo("file2.txt"))
            .body("uploadedFiles[2].fileName", equalTo("file3.txt"));
    }

    // Test 4: Upload image file with validation
    @Test
    public void testUploadImageFile() throws IOException {
        // Create test image
        BufferedImage image = new BufferedImage(800, 600, BufferedImage.TYPE_INT_RGB);
        File imageFile = new File(tempDir, "test-image.jpg");
        ImageIO.write(image, "jpg", imageFile);

        Response response = FileUploadHelper.uploadFileWithContentType(
            requestSpec,
            uploadEndpoint,
            imageFile,
            "image",
            "image/jpeg"
        );

        response.then()
            .statusCode(201)
            .body("fileName", equalTo("test-image.jpg"))
            .body("contentType", equalTo("image/jpeg"))
            .body("metadata.width", equalTo(800))
            .body("metadata.height", equalTo(600));
    }

    // Test 5: Upload large file
    @Test
    public void testUploadLargeFile() throws IOException {
        // Generate 10MB file
        File largeFile = FileUploadHelper.generateBinaryFile("large-file.bin", 10240);

        Response response = FileUploadHelper.uploadFile(
            requestSpec,
            uploadEndpoint,
            largeFile,
            "file"
        );

        response.then()
            .statusCode(201)
            .body("fileSize", greaterThan(10 * 1024 * 1024));
    }

    // Test 6: Download file
    @Test
    public void testDownloadFile() throws IOException {
        // First upload a file
        File originalFile = FileUploadHelper.generateTestFile("download-test.txt",
            "This is test content for download");

        Response uploadResponse = FileUploadHelper.uploadFile(
            requestSpec,
            uploadEndpoint,
            originalFile,
            "file"
        );

        String fileId = uploadResponse.jsonPath().getString("fileId");

        // Download the file
        File downloadedFile = FileDownloadHelper.downloadFile(
            requestSpec,
            downloadEndpoint.replace("{fileId}", fileId),
            tempDir,
            "downloaded-file.txt"
        );

        // Validate downloaded file
        FileValidator.validateFileExists(downloadedFile);
        FileValidator.validateTextFileContent(downloadedFile,
            "This is test content for download");
    }

    // Test 7: Download and validate file integrity
    @Test
    public void testFileIntegrity() throws Exception {
        // Upload file
        File originalFile = FileUploadHelper.generateBinaryFile("integrity-test.bin", 1024);
        String originalChecksum = FileUploadHelper.calculateChecksum(originalFile);

        Response uploadResponse = FileUploadHelper.uploadFile(
            requestSpec,
            uploadEndpoint,
            originalFile,
            "file"
        );

        String fileId = uploadResponse.jsonPath().getString("fileId");
        String serverChecksum = uploadResponse.jsonPath().getString("checksum");

        // Verify server calculated same checksum
        Assert.assertEquals(serverChecksum, originalChecksum,
            "Server checksum doesn't match original");

        // Download file
        File downloadedFile = FileDownloadHelper.downloadFile(
            requestSpec,
            downloadEndpoint.replace("{fileId}", fileId),
            tempDir,
            "downloaded-integrity.bin"
        );

        // Validate integrity
        FileValidator.validateFileIntegrity(originalFile, downloadedFile);
    }

    // Test 8: Upload with multipart builder
    @Test
    public void testMultipartRequestBuilder() throws IOException {
        File document = FileUploadHelper.generateTestFile("report.txt", "Report content");
        File attachment = FileUploadHelper.generateTestFile("data.csv", "col1,col2\nval1,val2");

        Response response = MultipartRequestBuilder.builder()
            .baseSpec(requestSpec)
            .file("document", document)
            .file("attachment", attachment)
            .formField("title", "Monthly Report")
            .formField("author", "John Doe")
            .jsonPart("metadata", Map.of(
                "department", "Engineering",
                "version", "1.0"
            ))
            .build()
            .execute(uploadEndpoint, "POST");

        response.then()
            .statusCode(201)
            .body("files.size()", equalTo(2))
            .body("metadata.title", equalTo("Monthly Report"))
            .body("metadata.author", equalTo("John Doe"));
    }

    // Test 9: Base64 file upload
    @Test
    public void testBase64FileUpload() throws IOException {
        File file = FileUploadHelper.generateTestFile("base64-test.txt", "Base64 content");

        Response response = FileUploadHelper.uploadBase64File(
            requestSpec,
            "/files/upload/base64",
            file
        );

        response.then()
            .statusCode(201)
            .body("fileName", equalTo("base64-test.txt"))
            .body("encoding", equalTo("base64"));
    }

    // Test 10: Invalid file upload scenarios
    @Test
    public void testInvalidFileUpload() {
        // Test 1: File too large
        Response response1 = given()
            .spec(requestSpec)
            .multiPart("file", new File(tempDir + "huge-file.bin"))
            .when()
            .post(uploadEndpoint);

        response1.then()
            .statusCode(413) // Payload Too Large
            .body("error", containsString("File size exceeds maximum limit"));

        // Test 2: Invalid file type
        File invalidFile = new File(tempDir + "malware.exe");
        Response response2 = FileUploadHelper.uploadFile(
            requestSpec,
            uploadEndpoint,
            invalidFile,
            "file"
        );

        response2.then()
            .statusCode(415) // Unsupported Media Type
            .body("error", containsString("File type not allowed"));
    }

    // Test 11: Download large file with progress
    @Test
    public void testDownloadLargeFileWithProgress() throws Exception {
        // Upload large file first
        File largeFile = FileUploadHelper.generateBinaryFile("large-download.bin", 5120);

        Response uploadResponse = FileUploadHelper.uploadFile(
            requestSpec,
            uploadEndpoint,
            largeFile,
            "file"
        );

        String fileId = uploadResponse.jsonPath().getString("fileId");

        // Download with progress tracking
        File downloadedFile = FileDownloadHelper.downloadLargeFile(
            requestSpec,
            downloadEndpoint.replace("{fileId}", fileId),
            tempDir,
            "large-downloaded.bin",
            (percentage, downloaded, total) -> {
                logger.info("Download progress: {}% ({}/{} bytes)",
                    percentage, downloaded, total);
            }
        );

        // Validate
        FileValidator.validateFileIntegrity(largeFile, downloadedFile);
    }
}
```

**Best Practices**:

1. **Validate File Size**: Check both client and server-side limits
2. **Content-Type Verification**: Ensure correct MIME types
3. **File Integrity**: Use checksums to verify uploads/downloads
4. **Cleanup**: Delete temporary files after tests
5. **Large Files**: Use streaming for large file operations
6. **Security**: Validate file types and scan for malware
7. **Error Handling**: Handle network failures and timeouts
8. **Progress Tracking**: Monitor large file transfers
9. **Encoding**: Handle different file encodings properly
10. **Metadata**: Include file metadata (name, size, type)

**Follow-up**: How do you handle large file uploads efficiently to avoid memory issues? How do you test file upload security (malware scanning, file type validation)? How do you implement resumable file uploads? How do you test concurrent file uploads?

---

### **Q108. How do you perform API performance testing and measure response times in REST Assured? Explain load testing, stress testing, and performance metrics.** (6-8 Years, 9-12 Years)

**Difficulty**: Hard
**Companies**: Amazon, Google, Netflix, Uber, Microsoft, PayPal, LinkedIn
**Topics**: Performance Testing, Load Testing, Response Time, Throughput, Latency, Stress Testing

**Answer**:

API performance testing ensures that your APIs meet performance requirements under various load conditions. While REST Assured is primarily for functional testing, it can be integrated with performance testing tools and used to measure response times, validate SLAs, and identify performance bottlenecks.

**Key Concepts**:

1. **Response Time**: Time taken for API to respond to a request
2. **Throughput**: Number of requests processed per unit time
3. **Latency**: Time between request sent and first byte received
4. **Load Testing**: Testing under expected load
5. **Stress Testing**: Testing beyond expected load to find breaking point
6. **Spike Testing**: Sudden increase in load
7. **Endurance Testing**: Sustained load over extended period

**Complete Implementation**:

```java
// 1. Performance Metrics Collector
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Duration;
import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

@Data
public class PerformanceMetrics {
    private String testName;
    private int totalRequests;
    private int successfulRequests;
    private int failedRequests;
    private long minResponseTime;
    private long maxResponseTime;
    private double avgResponseTime;
    private double medianResponseTime;
    private double percentile95;
    private double percentile99;
    private double throughput; // requests per second
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private long totalDuration; // milliseconds
    private Map<String, Integer> statusCodeDistribution;
    private Map<String, Long> errorDistribution;

    private List<Long> responseTimes; // All response times

    public void calculateMetrics() {
        if (responseTimes == null || responseTimes.isEmpty()) {
            return;
        }

        Collections.sort(responseTimes);

        this.minResponseTime = responseTimes.get(0);
        this.maxResponseTime = responseTimes.get(responseTimes.size() - 1);
        this.avgResponseTime = responseTimes.stream()
            .mapToLong(Long::longValue)
            .average()
            .orElse(0.0);

        this.medianResponseTime = calculatePercentile(responseTimes, 50);
        this.percentile95 = calculatePercentile(responseTimes, 95);
        this.percentile99 = calculatePercentile(responseTimes, 99);

        if (totalDuration > 0) {
            this.throughput = (double) totalRequests / (totalDuration / 1000.0);
        }
    }

    private double calculatePercentile(List<Long> sortedTimes, int percentile) {
        int index = (int) Math.ceil(percentile / 100.0 * sortedTimes.size()) - 1;
        return sortedTimes.get(Math.max(0, Math.min(index, sortedTimes.size() - 1)));
    }

    public void printSummary() {
        System.out.println("\n========== Performance Test Summary ==========");
        System.out.println("Test Name: " + testName);
        System.out.println("Total Requests: " + totalRequests);
        System.out.println("Successful: " + successfulRequests);
        System.out.println("Failed: " + failedRequests);
        System.out.println("Success Rate: " + String.format("%.2f%%",
            (successfulRequests * 100.0 / totalRequests)));
        System.out.println("\n--- Response Time (ms) ---");
        System.out.println("Min: " + minResponseTime);
        System.out.println("Max: " + maxResponseTime);
        System.out.println("Avg: " + String.format("%.2f", avgResponseTime));
        System.out.println("Median: " + String.format("%.2f", medianResponseTime));
        System.out.println("95th percentile: " + String.format("%.2f", percentile95));
        System.out.println("99th percentile: " + String.format("%.2f", percentile99));
        System.out.println("\n--- Performance ---");
        System.out.println("Duration: " + totalDuration + " ms");
        System.out.println("Throughput: " + String.format("%.2f", throughput) + " req/s");
        System.out.println("=============================================\n");
    }
}

// 2. Performance Test Executor
public class PerformanceTestExecutor {
    private static final Logger logger = LoggerFactory.getLogger(PerformanceTestExecutor.class);

    private final RequestSpecification baseSpec;
    private final List<Long> responseTimes = Collections.synchronizedList(new ArrayList<>());
    private final Map<Integer, Integer> statusCodes = new ConcurrentHashMap<>();
    private final Map<String, Integer> errors = new ConcurrentHashMap<>();
    private int successCount = 0;
    private int failCount = 0;

    public PerformanceTestExecutor(RequestSpecification baseSpec) {
        this.baseSpec = baseSpec;
    }

    // Execute single request and measure time
    public Response executeAndMeasure(String endpoint, String method, Object body) {
        long startTime = System.currentTimeMillis();

        try {
            Response response = executeRequest(endpoint, method, body);
            long responseTime = System.currentTimeMillis() - startTime;

            responseTimes.add(responseTime);
            statusCodes.merge(response.getStatusCode(), 1, Integer::sum);

            if (response.getStatusCode() < 400) {
                successCount++;
            } else {
                failCount++;
            }

            return response;

        } catch (Exception e) {
            long responseTime = System.currentTimeMillis() - startTime;
            responseTimes.add(responseTime);
            errors.merge(e.getClass().getSimpleName(), 1, Integer::sum);
            failCount++;
            throw e;
        }
    }

    private Response executeRequest(String endpoint, String method, Object body) {
        return switch (method.toUpperCase()) {
            case "GET" -> given().spec(baseSpec).when().get(endpoint);
            case "POST" -> given().spec(baseSpec).body(body).when().post(endpoint);
            case "PUT" -> given().spec(baseSpec).body(body).when().put(endpoint);
            case "DELETE" -> given().spec(baseSpec).when().delete(endpoint);
            default -> throw new IllegalArgumentException("Unsupported method: " + method);
        };
    }

    // Get collected metrics
    public PerformanceMetrics getMetrics(String testName, LocalDateTime startTime,
                                        LocalDateTime endTime) {
        PerformanceMetrics metrics = new PerformanceMetrics();
        metrics.setTestName(testName);
        metrics.setTotalRequests(responseTimes.size());
        metrics.setSuccessfulRequests(successCount);
        metrics.setFailedRequests(failCount);
        metrics.setResponseTimes(new ArrayList<>(responseTimes));
        metrics.setStartTime(startTime);
        metrics.setEndTime(endTime);
        metrics.setTotalDuration(Duration.between(startTime, endTime).toMillis());
        metrics.setStatusCodeDistribution(new HashMap<>(statusCodes).entrySet().stream()
            .collect(Collectors.toMap(
                e -> String.valueOf(e.getKey()),
                Map.Entry::getValue
            )));
        metrics.setErrorDistribution(errors.entrySet().stream()
            .collect(Collectors.toMap(
                Map.Entry::getKey,
                e -> e.getValue().longValue()
            )));

        metrics.calculateMetrics();
        return metrics;
    }

    // Reset metrics
    public void reset() {
        responseTimes.clear();
        statusCodes.clear();
        errors.clear();
        successCount = 0;
        failCount = 0;
    }
}

// 3. Load Test Runner
import java.util.concurrent.*;

public class LoadTestRunner {
    private static final Logger logger = LoggerFactory.getLogger(LoadTestRunner.class);

    @Builder
    @Data
    public static class LoadTestConfig {
        private int totalRequests;
        private int concurrentUsers;
        private long rampUpTimeMs;
        private String endpoint;
        private String httpMethod;
        private Object requestBody;
        private long thinkTimeMs; // Delay between requests per user
    }

    // Execute load test
    public static PerformanceMetrics executeLoadTest(RequestSpecification baseSpec,
                                                    LoadTestConfig config) throws Exception {

        PerformanceTestExecutor executor = new PerformanceTestExecutor(baseSpec);
        ExecutorService executorService = Executors.newFixedThreadPool(config.getConcurrentUsers());

        LocalDateTime startTime = LocalDateTime.now();

        int requestsPerUser = config.getTotalRequests() / config.getConcurrentUsers();
        long rampUpDelay = config.getRampUpTimeMs() / config.getConcurrentUsers();

        List<Future<?>> futures = new ArrayList<>();

        // Submit tasks with ramp-up
        for (int i = 0; i < config.getConcurrentUsers(); i++) {
            final int userId = i;

            // Ramp-up delay
            if (config.getRampUpTimeMs() > 0) {
                Thread.sleep(rampUpDelay);
            }

            Future<?> future = executorService.submit(() -> {
                for (int req = 0; req < requestsPerUser; req++) {
                    try {
                        executor.executeAndMeasure(
                            config.getEndpoint(),
                            config.getHttpMethod(),
                            config.getRequestBody()
                        );

                        // Think time
                        if (config.getThinkTimeMs() > 0) {
                            Thread.sleep(config.getThinkTimeMs());
                        }

                    } catch (Exception e) {
                        logger.error("Request failed for user {}: {}", userId, e.getMessage());
                    }
                }
            });

            futures.add(future);
        }

        // Wait for all tasks to complete
        for (Future<?> future : futures) {
            future.get();
        }

        executorService.shutdown();
        executorService.awaitTermination(5, TimeUnit.MINUTES);

        LocalDateTime endTime = LocalDateTime.now();

        PerformanceMetrics metrics = executor.getMetrics(
            "Load Test - " + config.getEndpoint(),
            startTime,
            endTime
        );

        metrics.printSummary();
        return metrics;
    }

    // Execute stress test (gradually increase load)
    public static List<PerformanceMetrics> executeStressTest(RequestSpecification baseSpec,
                                                             String endpoint,
                                                             String httpMethod,
                                                             Object requestBody,
                                                             int[] userLevels,
                                                             int requestsPerLevel) throws Exception {

        List<PerformanceMetrics> allMetrics = new ArrayList<>();

        for (int users : userLevels) {
            logger.info("Stress Test - Starting level with {} concurrent users", users);

            LoadTestConfig config = LoadTestConfig.builder()
                .totalRequests(requestsPerLevel)
                .concurrentUsers(users)
                .rampUpTimeMs(5000)
                .endpoint(endpoint)
                .httpMethod(httpMethod)
                .requestBody(requestBody)
                .build();

            PerformanceMetrics metrics = executeLoadTest(baseSpec, config);
            allMetrics.add(metrics);

            // Check if system is breaking
            if (metrics.getFailedRequests() > metrics.getSuccessfulRequests()) {
                logger.warn("Breaking point reached at {} users", users);
                break;
            }

            // Cool down period
            Thread.sleep(10000);
        }

        return allMetrics;
    }

    // Execute spike test (sudden load increase)
    public static PerformanceMetrics executeSpikeTest(RequestSpecification baseSpec,
                                                     String endpoint,
                                                     String httpMethod,
                                                     int normalLoad,
                                                     int spikeLoad,
                                                     int normalDuration,
                                                     int spikeDuration) throws Exception {

        PerformanceTestExecutor executor = new PerformanceTestExecutor(baseSpec);
        LocalDateTime startTime = LocalDateTime.now();

        // Phase 1: Normal load
        logger.info("Spike Test - Phase 1: Normal load ({} users)", normalLoad);
        runLoadPhase(executor, endpoint, httpMethod, null, normalLoad, normalDuration);

        // Phase 2: Spike
        logger.info("Spike Test - Phase 2: Spike ({} users)", spikeLoad);
        runLoadPhase(executor, endpoint, httpMethod, null, spikeLoad, spikeDuration);

        // Phase 3: Back to normal
        logger.info("Spike Test - Phase 3: Back to normal ({} users)", normalLoad);
        runLoadPhase(executor, endpoint, httpMethod, null, normalLoad, normalDuration);

        LocalDateTime endTime = LocalDateTime.now();

        PerformanceMetrics metrics = executor.getMetrics(
            "Spike Test - " + endpoint,
            startTime,
            endTime
        );

        metrics.printSummary();
        return metrics;
    }

    private static void runLoadPhase(PerformanceTestExecutor executor,
                                    String endpoint,
                                    String httpMethod,
                                    Object requestBody,
                                    int users,
                                    int durationSeconds) throws Exception {

        ExecutorService executorService = Executors.newFixedThreadPool(users);
        long endTime = System.currentTimeMillis() + (durationSeconds * 1000L);

        List<Future<?>> futures = new ArrayList<>();

        for (int i = 0; i < users; i++) {
            Future<?> future = executorService.submit(() -> {
                while (System.currentTimeMillis() < endTime) {
                    try {
                        executor.executeAndMeasure(endpoint, httpMethod, requestBody);
                        Thread.sleep(100); // Small delay between requests
                    } catch (Exception e) {
                        // Continue on error
                    }
                }
            });
            futures.add(future);
        }

        for (Future<?> future : futures) {
            future.get();
        }

        executorService.shutdown();
        executorService.awaitTermination(1, TimeUnit.MINUTES);
    }
}

// 4. Performance Assertion Helper
public class PerformanceAssertions {

    // Assert response time under threshold
    public static void assertResponseTime(Response response, long maxResponseTimeMs) {
        long responseTime = response.getTime();
        Assert.assertTrue(responseTime <= maxResponseTimeMs,
            String.format("Response time (%d ms) exceeded threshold (%d ms)",
                responseTime, maxResponseTimeMs));
    }

    // Assert average response time
    public static void assertAverageResponseTime(PerformanceMetrics metrics,
                                                double maxAvgResponseTimeMs) {
        Assert.assertTrue(metrics.getAvgResponseTime() <= maxAvgResponseTimeMs,
            String.format("Average response time (%.2f ms) exceeded threshold (%.2f ms)",
                metrics.getAvgResponseTime(), maxAvgResponseTimeMs));
    }

    // Assert percentile
    public static void assert95thPercentile(PerformanceMetrics metrics,
                                           double maxPercentileMs) {
        Assert.assertTrue(metrics.getPercentile95() <= maxPercentileMs,
            String.format("95th percentile (%.2f ms) exceeded threshold (%.2f ms)",
                metrics.getPercentile95(), maxPercentileMs));
    }

    // Assert throughput
    public static void assertThroughput(PerformanceMetrics metrics,
                                       double minThroughput) {
        Assert.assertTrue(metrics.getThroughput() >= minThroughput,
            String.format("Throughput (%.2f req/s) below minimum (%.2f req/s)",
                metrics.getThroughput(), minThroughput));
    }

    // Assert success rate
    public static void assertSuccessRate(PerformanceMetrics metrics,
                                        double minSuccessRatePercent) {
        double successRate = (metrics.getSuccessfulRequests() * 100.0) /
            metrics.getTotalRequests();

        Assert.assertTrue(successRate >= minSuccessRatePercent,
            String.format("Success rate (%.2f%%) below minimum (%.2f%%)",
                successRate, minSuccessRatePercent));
    }

    // Assert no timeout errors
    public static void assertNoTimeouts(PerformanceMetrics metrics) {
        long timeoutCount = metrics.getErrorDistribution().getOrDefault("TimeoutException", 0L);
        Assert.assertEquals(timeoutCount, 0L,
            String.format("Found %d timeout errors", timeoutCount));
    }
}

// 5. Performance Report Generator
public class PerformanceReportGenerator {

    public static String generateHtmlReport(PerformanceMetrics metrics) {
        StringBuilder html = new StringBuilder();

        html.append("<!DOCTYPE html><html><head>");
        html.append("<title>Performance Test Report</title>");
        html.append("<style>");
        html.append("body { font-family: Arial, sans-serif; margin: 20px; }");
        html.append("table { border-collapse: collapse; width: 100%; margin-top: 20px; }");
        html.append("th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }");
        html.append("th { background-color: #4CAF50; color: white; }");
        html.append(".metric { background-color: #f2f2f2; }");
        html.append(".pass { color: green; }");
        html.append(".fail { color: red; }");
        html.append("</style>");
        html.append("</head><body>");

        html.append("<h1>Performance Test Report</h1>");
        html.append("<h2>").append(metrics.getTestName()).append("</h2>");

        html.append("<table>");
        html.append("<tr><th>Metric</th><th>Value</th></tr>");

        html.append("<tr class='metric'><td>Total Requests</td><td>")
            .append(metrics.getTotalRequests()).append("</td></tr>");
        html.append("<tr><td>Successful</td><td class='pass'>")
            .append(metrics.getSuccessfulRequests()).append("</td></tr>");
        html.append("<tr><td>Failed</td><td class='fail'>")
            .append(metrics.getFailedRequests()).append("</td></tr>");

        double successRate = (metrics.getSuccessfulRequests() * 100.0) /
            metrics.getTotalRequests();
        html.append("<tr class='metric'><td>Success Rate</td><td>")
            .append(String.format("%.2f%%", successRate)).append("</td></tr>");

        html.append("<tr><td>Min Response Time</td><td>")
            .append(metrics.getMinResponseTime()).append(" ms</td></tr>");
        html.append("<tr><td>Max Response Time</td><td>")
            .append(metrics.getMaxResponseTime()).append(" ms</td></tr>");
        html.append("<tr class='metric'><td>Avg Response Time</td><td>")
            .append(String.format("%.2f ms", metrics.getAvgResponseTime())).append("</td></tr>");
        html.append("<tr><td>Median</td><td>")
            .append(String.format("%.2f ms", metrics.getMedianResponseTime())).append("</td></tr>");
        html.append("<tr class='metric'><td>95th Percentile</td><td>")
            .append(String.format("%.2f ms", metrics.getPercentile95())).append("</td></tr>");
        html.append("<tr><td>99th Percentile</td><td>")
            .append(String.format("%.2f ms", metrics.getPercentile99())).append("</td></tr>");

        html.append("<tr class='metric'><td>Throughput</td><td>")
            .append(String.format("%.2f req/s", metrics.getThroughput())).append("</td></tr>");
        html.append("<tr><td>Duration</td><td>")
            .append(metrics.getTotalDuration()).append(" ms</td></tr>");

        html.append("</table>");

        html.append("</body></html>");

        return html.toString();
    }

    public static void saveReport(PerformanceMetrics metrics, String filePath) throws IOException {
        String html = generateHtmlReport(metrics);
        Files.writeString(Paths.get(filePath), html);
        logger.info("Performance report saved to: {}", filePath);
    }
}
```

**Complete Test Examples**:

```java
import org.testng.annotations.BeforeClass;
import org.testng.annotations.Test;

public class APIPerformanceTests {
    private RequestSpecification requestSpec;

    @BeforeClass
    public void setup() {
        requestSpec = SpecificationBuilder.getBaseRequestSpec();
    }

    // Test 1: Simple response time validation
    @Test
    public void testResponseTime() {
        Response response = given()
            .spec(requestSpec)
            .when()
            .get("/users/1");

        response.then()
            .statusCode(200)
            .time(lessThan(2000L)); // Response time under 2 seconds

        // Alternative assertion
        PerformanceAssertions.assertResponseTime(response, 2000);

        logger.info("Response time: {} ms", response.getTime());
    }

    // Test 2: Load test
    @Test
    public void testLoadTest() throws Exception {
        LoadTestRunner.LoadTestConfig config = LoadTestRunner.LoadTestConfig.builder()
            .totalRequests(1000)
            .concurrentUsers(10)
            .rampUpTimeMs(5000)
            .endpoint("/users")
            .httpMethod("GET")
            .thinkTimeMs(100)
            .build();

        PerformanceMetrics metrics = LoadTestRunner.executeLoadTest(requestSpec, config);

        // Assertions
        PerformanceAssertions.assertAverageResponseTime(metrics, 500);
        PerformanceAssertions.assert95thPercentile(metrics, 1000);
        PerformanceAssertions.assertSuccessRate(metrics, 95.0);
        PerformanceAssertions.assertThroughput(metrics, 10.0);

        // Generate report
        PerformanceReportGenerator.saveReport(metrics, "target/load-test-report.html");
    }

    // Test 3: Stress test
    @Test
    public void testStressTest() throws Exception {
        int[] userLevels = {10, 25, 50, 100, 200};

        List<PerformanceMetrics> results = LoadTestRunner.executeStressTest(
            requestSpec,
            "/users",
            "GET",
            null,
            userLevels,
            100
        );

        // Analyze results
        for (PerformanceMetrics metrics : results) {
            logger.info("Users: {}, Throughput: {}, Avg Response Time: {}",
                metrics.getTotalRequests() / metrics.getTotalDuration() * 1000,
                metrics.getThroughput(),
                metrics.getAvgResponseTime());
        }

        // Find breaking point
        Optional<PerformanceMetrics> breakingPoint = results.stream()
            .filter(m -> m.getFailedRequests() > m.getSuccessfulRequests())
            .findFirst();

        if (breakingPoint.isPresent()) {
            logger.warn("System breaking point found");
        }
    }

    // Test 4: Spike test
    @Test
    public void testSpikeTest() throws Exception {
        PerformanceMetrics metrics = LoadTestRunner.executeSpikeTest(
            requestSpec,
            "/users",
            "GET",
            10,  // Normal load: 10 users
            100, // Spike: 100 users
            10,  // Normal duration: 10 seconds
            5    // Spike duration: 5 seconds
        );

        // Verify system recovered after spike
        PerformanceAssertions.assertSuccessRate(metrics, 90.0);
    }

    // Test 5: API endpoint comparison
    @Test
    public void testEndpointComparison() throws Exception {
        // Test endpoint 1
        LoadTestRunner.LoadTestConfig config1 = LoadTestRunner.LoadTestConfig.builder()
            .totalRequests(100)
            .concurrentUsers(10)
            .endpoint("/users")
            .httpMethod("GET")
            .build();

        PerformanceMetrics metrics1 = LoadTestRunner.executeLoadTest(requestSpec, config1);

        // Test endpoint 2
        LoadTestRunner.LoadTestConfig config2 = LoadTestRunner.LoadTestConfig.builder()
            .totalRequests(100)
            .concurrentUsers(10)
            .endpoint("/users/search?name=John")
            .httpMethod("GET")
            .build();

        PerformanceMetrics metrics2 = LoadTestRunner.executeLoadTest(requestSpec, config2);

        // Compare
        logger.info("Endpoint 1 avg time: {} ms", metrics1.getAvgResponseTime());
        logger.info("Endpoint 2 avg time: {} ms", metrics2.getAvgResponseTime());

        // Assert the faster endpoint
        Assert.assertTrue(metrics1.getAvgResponseTime() < metrics2.getAvgResponseTime() * 2,
            "Endpoint performance degradation detected");
    }
}
```

**Best Practices**:

1. **Set SLA Targets**: Define acceptable response times (e.g., 95th percentile < 500ms)
2. **Ramp-Up**: Gradually increase load to avoid overwhelming the system
3. **Think Time**: Add realistic delays between requests
4. **Monitor Resources**: Track CPU, memory, database connections
5. **Isolate Environment**: Run performance tests in dedicated environment
6. **Baseline**: Establish performance baselines
7. **Regular Testing**: Include performance tests in CI/CD pipeline
8. **Report Generation**: Create detailed performance reports
9. **Bottleneck Analysis**: Identify and document bottlenecks
10. **Scalability Testing**: Test horizontal and vertical scaling

**Performance Testing Types**:

| Type | Purpose | Load Pattern | Duration |
|------|---------|--------------|----------|
| **Load Testing** | Test under expected load | Steady load | Hours |
| **Stress Testing** | Find breaking point | Gradually increasing | Until break |
| **Spike Testing** | Handle sudden traffic | Sudden spike | Minutes |
| **Endurance/Soak** | Memory leaks, degradation | Sustained load | Days |
| **Scalability** | Test scaling capability | Incremental increase | Varies |

**Follow-up**: How do you integrate performance testing into your CI/CD pipeline? What tools do you use for API performance monitoring in production? How do you identify performance bottlenecks? How do you test API performance under different network conditions?

---

### **Q109. How do you test GraphQL APIs using REST Assured? Explain GraphQL queries, mutations, subscriptions, schema validation, and error handling.** (6-8 Years, 9-12 Years)

**Difficulty**: Hard
**Companies**: Facebook, GitHub, Shopify, Netflix, Airbnb, Twitter, LinkedIn
**Topics**: GraphQL, Queries, Mutations, Schema Validation, Introspection

**Answer**:

GraphQL is a query language for APIs that allows clients to request exactly the data they need. Unlike REST, GraphQL uses a single endpoint and provides powerful querying capabilities. Testing GraphQL APIs requires understanding queries, mutations, fragments, and schema validation.

**Key Concepts**:

1. **Queries**: Read operations to fetch data
2. **Mutations**: Write operations (create, update, delete)
3. **Subscriptions**: Real-time data updates via WebSockets
4. **Schema**: Type system defining available operations
5. **Introspection**: Query the schema itself
6. **Fragments**: Reusable query pieces
7. **Variables**: Dynamic query parameters
8. **Directives**: Conditional query execution

**Complete Implementation**:

```java
// 1. GraphQL Request Builder
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.HashMap;
import java.util.Map;

public class GraphQLRequestBuilder {
    private static final Logger logger = LoggerFactory.getLogger(GraphQLRequestBuilder.class);
    private static final ObjectMapper objectMapper = new ObjectMapper();

    private String query;
    private String operationName;
    private Map<String, Object> variables;

    public GraphQLRequestBuilder() {
        this.variables = new HashMap<>();
    }

    public static GraphQLRequestBuilder query(String query) {
        GraphQLRequestBuilder builder = new GraphQLRequestBuilder();
        builder.query = query;
        return builder;
    }

    public GraphQLRequestBuilder operationName(String operationName) {
        this.operationName = operationName;
        return this;
    }

    public GraphQLRequestBuilder variable(String name, Object value) {
        this.variables.put(name, value);
        return this;
    }

    public GraphQLRequestBuilder variables(Map<String, Object> variables) {
        this.variables.putAll(variables);
        return this;
    }

    public String build() {
        try {
            Map<String, Object> request = new HashMap<>();
            request.put("query", query);

            if (operationName != null) {
                request.put("operationName", operationName);
            }

            if (!variables.isEmpty()) {
                request.put("variables", variables);
            }

            return objectMapper.writeValueAsString(request);
        } catch (Exception e) {
            throw new RuntimeException("Failed to build GraphQL request", e);
        }
    }

    public Map<String, Object> buildAsMap() {
        Map<String, Object> request = new HashMap<>();
        request.put("query", query);

        if (operationName != null) {
            request.put("operationName", operationName);
        }

        if (!variables.isEmpty()) {
            request.put("variables", variables);
        }

        return request;
    }
}

// 2. GraphQL Client
public class GraphQLClient {
    private static final Logger logger = LoggerFactory.getLogger(GraphQLClient.class);

    private final RequestSpecification baseSpec;
    private final String endpoint;

    public GraphQLClient(RequestSpecification baseSpec, String endpoint) {
        this.baseSpec = baseSpec;
        this.endpoint = endpoint;
    }

    // Execute GraphQL query/mutation
    public Response execute(String graphQLRequest) {
        return given()
            .spec(baseSpec)
            .contentType(ContentType.JSON)
            .body(graphQLRequest)
            .when()
            .post(endpoint);
    }

    // Execute with request builder
    public Response execute(GraphQLRequestBuilder builder) {
        return execute(builder.build());
    }

    // Execute query with variables
    public Response executeQuery(String query, Map<String, Object> variables) {
        GraphQLRequestBuilder builder = GraphQLRequestBuilder.query(query);
        if (variables != null && !variables.isEmpty()) {
            builder.variables(variables);
        }
        return execute(builder);
    }

    // Execute mutation
    public Response executeMutation(String mutation, Map<String, Object> variables) {
        return executeQuery(mutation, variables);
    }

    // Get schema via introspection
    public Response getSchema() {
        String introspectionQuery = """
            query IntrospectionQuery {
              __schema {
                types {
                  name
                  kind
                  description
                  fields {
                    name
                    description
                    type {
                      name
                      kind
                    }
                  }
                }
                queryType {
                  name
                }
                mutationType {
                  name
                }
                subscriptionType {
                  name
                }
              }
            }
            """;

        return executeQuery(introspectionQuery, null);
    }
}

// 3. GraphQL Response Validator
public class GraphQLResponseValidator {
    private static final Logger logger = LoggerFactory.getLogger(GraphQLResponseValidator.class);

    // Validate no errors in response
    public static void assertNoErrors(Response response) {
        response.then()
            .statusCode(200)
            .body("errors", nullValue());

        // Additional check
        if (response.jsonPath().get("errors") != null) {
            List<Map<String, Object>> errors = response.jsonPath().getList("errors");
            Assert.fail("GraphQL errors found: " + errors);
        }
    }

    // Validate data exists
    public static void assertDataExists(Response response) {
        response.then()
            .statusCode(200)
            .body("data", notNullValue());
    }

    // Validate specific error
    public static void assertError(Response response, String expectedErrorMessage) {
        response.then()
            .statusCode(200)
            .body("errors", notNullValue())
            .body("errors[0].message", containsString(expectedErrorMessage));
    }

    // Validate error type
    public static void assertErrorType(Response response, String errorType) {
        response.then()
            .body("errors[0].extensions.code", equalTo(errorType));
    }

    // Extract data field
    public static <T> T extractData(Response response, String path, Class<T> type) {
        assertNoErrors(response);
        return response.jsonPath().getObject("data." + path, type);
    }

    // Validate pagination
    public static void assertPagination(Response response, String connectionPath,
                                       int expectedCount, boolean hasNextPage) {
        String edgesPath = "data." + connectionPath + ".edges";
        String pageInfoPath = "data." + connectionPath + ".pageInfo";

        response.then()
            .body(edgesPath + ".size()", equalTo(expectedCount))
            .body(pageInfoPath + ".hasNextPage", equalTo(hasNextPage));
    }
}

// 4. GraphQL Query Templates
public class GraphQLQueries {

    // User queries
    public static class Users {
        public static String GET_USER = """
            query GetUser($id: ID!) {
              user(id: $id) {
                id
                name
                email
                createdAt
              }
            }
            """;

        public static String GET_USERS_WITH_PAGINATION = """
            query GetUsers($first: Int!, $after: String) {
              users(first: $first, after: $after) {
                edges {
                  node {
                    id
                    name
                    email
                  }
                  cursor
                }
                pageInfo {
                  hasNextPage
                  hasPreviousPage
                  startCursor
                  endCursor
                }
                totalCount
              }
            }
            """;

        public static String SEARCH_USERS = """
            query SearchUsers($searchTerm: String!, $filters: UserFilterInput) {
              searchUsers(searchTerm: $searchTerm, filters: $filters) {
                id
                name
                email
                profile {
                  bio
                  avatar
                }
              }
            }
            """;
    }

    // Mutation templates
    public static class Mutations {
        public static String CREATE_USER = """
            mutation CreateUser($input: CreateUserInput!) {
              createUser(input: $input) {
                user {
                  id
                  name
                  email
                  createdAt
                }
                errors {
                  field
                  message
                }
              }
            }
            """;

        public static String UPDATE_USER = """
            mutation UpdateUser($id: ID!, $input: UpdateUserInput!) {
              updateUser(id: $id, input: $input) {
                user {
                  id
                  name
                  email
                  updatedAt
                }
                errors {
                  field
                  message
                }
              }
            }
            """;

        public static String DELETE_USER = """
            mutation DeleteUser($id: ID!) {
              deleteUser(id: $id) {
                success
                message
                deletedId
              }
            }
            """;
    }

    // Fragment examples
    public static class Fragments {
        public static String USER_FIELDS = """
            fragment UserFields on User {
              id
              name
              email
              createdAt
              updatedAt
            }
            """;

        public static String POST_FIELDS = """
            fragment PostFields on Post {
              id
              title
              content
              author {
                ...UserFields
              }
              createdAt
            }
            """;

        // Query using fragments
        public static String GET_USER_WITH_POSTS = """
            query GetUserWithPosts($userId: ID!) {
              user(id: $userId) {
                ...UserFields
                posts {
                  ...PostFields
                }
              }
            }
            """ + USER_FIELDS + "\n" + POST_FIELDS;
    }

    // Directive examples
    public static class Directives {
        // @include directive
        public static String CONDITIONAL_QUERY = """
            query GetUser($id: ID!, $includeEmail: Boolean!) {
              user(id: $id) {
                id
                name
                email @include(if: $includeEmail)
              }
            }
            """;

        // @skip directive
        public static String SKIP_QUERY = """
            query GetUser($id: ID!, $skipProfile: Boolean!) {
              user(id: $id) {
                id
                name
                profile @skip(if: $skipProfile) {
                  bio
                  avatar
                }
              }
            }
            """;
    }

    // Nested queries
    public static class Nested {
        public static String GET_USER_POSTS_COMMENTS = """
            query GetUserWithPostsAndComments($userId: ID!) {
              user(id: $userId) {
                id
                name
                posts(first: 10) {
                  edges {
                    node {
                      id
                      title
                      comments(first: 5) {
                        edges {
                          node {
                            id
                            text
                            author {
                              id
                              name
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            """;
    }
}

// 5. GraphQL Schema Validator
public class GraphQLSchemaValidator {

    // Validate type exists in schema
    public static void assertTypeExists(Response schemaResponse, String typeName) {
        List<Map<String, Object>> types = schemaResponse.jsonPath()
            .getList("data.__schema.types");

        boolean typeExists = types.stream()
            .anyMatch(type -> typeName.equals(type.get("name")));

        Assert.assertTrue(typeExists,
            String.format("Type '%s' not found in schema", typeName));
    }

    // Validate field exists on type
    public static void assertFieldExists(Response schemaResponse,
                                        String typeName,
                                        String fieldName) {
        List<Map<String, Object>> types = schemaResponse.jsonPath()
            .getList("data.__schema.types");

        Map<String, Object> type = types.stream()
            .filter(t -> typeName.equals(t.get("name")))
            .findFirst()
            .orElseThrow(() -> new AssertionError("Type not found: " + typeName));

        @SuppressWarnings("unchecked")
        List<Map<String, Object>> fields = (List<Map<String, Object>>) type.get("fields");

        if (fields != null) {
            boolean fieldExists = fields.stream()
                .anyMatch(field -> fieldName.equals(field.get("name")));

            Assert.assertTrue(fieldExists,
                String.format("Field '%s' not found on type '%s'", fieldName, typeName));
        } else {
            Assert.fail("Type has no fields: " + typeName);
        }
    }

    // Validate query type
    public static void assertQueryType(Response schemaResponse, String expectedTypeName) {
        String queryType = schemaResponse.jsonPath()
            .getString("data.__schema.queryType.name");

        Assert.assertEquals(queryType, expectedTypeName,
            "Query type mismatch");
    }

    // Validate mutation type
    public static void assertMutationType(Response schemaResponse, String expectedTypeName) {
        String mutationType = schemaResponse.jsonPath()
            .getString("data.__schema.mutationType.name");

        Assert.assertEquals(mutationType, expectedTypeName,
            "Mutation type mismatch");
    }
}

// 6. GraphQL Error Handler
@Data
@Builder
public class GraphQLError {
    private String message;
    private List<GraphQLLocation> locations;
    private List<String> path;
    private Map<String, Object> extensions;

    @Data
    @AllArgsConstructor
    public static class GraphQLLocation {
        private int line;
        private int column;
    }
}

public class GraphQLErrorHandler {

    public static List<GraphQLError> extractErrors(Response response) {
        List<Map<String, Object>> errorMaps = response.jsonPath().getList("errors");

        if (errorMaps == null) {
            return Collections.emptyList();
        }

        return errorMaps.stream()
            .map(GraphQLErrorHandler::mapToGraphQLError)
            .collect(Collectors.toList());
    }

    private static GraphQLError mapToGraphQLError(Map<String, Object> errorMap) {
        return GraphQLError.builder()
            .message((String) errorMap.get("message"))
            .path((List<String>) errorMap.get("path"))
            .extensions((Map<String, Object>) errorMap.get("extensions"))
            .build();
    }

    public static void logErrors(Response response) {
        List<GraphQLError> errors = extractErrors(response);

        if (!errors.isEmpty()) {
            logger.error("GraphQL Errors:");
            errors.forEach(error -> {
                logger.error("  - Message: {}", error.getMessage());
                logger.error("    Path: {}", error.getPath());
                logger.error("    Extensions: {}", error.getExtensions());
            });
        }
    }
}

// 7. GraphQL Batch Request Handler
public class GraphQLBatchExecutor {

    // Execute multiple queries in a single request
    public static Response executeBatch(RequestSpecification baseSpec,
                                       String endpoint,
                                       List<GraphQLRequestBuilder> queries) {
        List<Map<String, Object>> batch = queries.stream()
            .map(GraphQLRequestBuilder::buildAsMap)
            .collect(Collectors.toList());

        return given()
            .spec(baseSpec)
            .contentType(ContentType.JSON)
            .body(batch)
            .when()
            .post(endpoint);
    }

    // Execute aliased queries (multiple queries in one request)
    public static Response executeAliased(RequestSpecification baseSpec,
                                         String endpoint,
                                         Map<String, String> aliasedQueries,
                                         Map<String, Object> variables) {

        StringBuilder combinedQuery = new StringBuilder("query {");

        aliasedQueries.forEach((alias, query) -> {
            combinedQuery.append("\n  ")
                .append(alias)
                .append(": ")
                .append(query);
        });

        combinedQuery.append("\n}");

        GraphQLRequestBuilder builder = GraphQLRequestBuilder
            .query(combinedQuery.toString())
            .variables(variables);

        return new GraphQLClient(baseSpec, endpoint).execute(builder);
    }
}
```

**Complete Test Examples**:

```java
import org.testng.annotations.BeforeClass;
import org.testng.annotations.Test;

public class GraphQLAPITests {
    private GraphQLClient graphQLClient;
    private String graphqlEndpoint = "/graphql";

    @BeforeClass
    public void setup() {
        RequestSpecification baseSpec = SpecificationBuilder.getBaseRequestSpec();
        graphQLClient = new GraphQLClient(baseSpec, graphqlEndpoint);
    }

    // Test 1: Simple query
    @Test
    public void testSimpleQuery() {
        String query = """
            query {
              users {
                id
                name
                email
              }
            }
            """;

        Response response = graphQLClient.executeQuery(query, null);

        GraphQLResponseValidator.assertNoErrors(response);
        response.then()
            .body("data.users", notNullValue())
            .body("data.users.size()", greaterThan(0))
            .body("data.users[0].id", notNullValue())
            .body("data.users[0].name", notNullValue())
            .body("data.users[0].email", notNullValue());
    }

    // Test 2: Query with variables
    @Test
    public void testQueryWithVariables() {
        Map<String, Object> variables = Map.of("id", "123");

        Response response = graphQLClient.executeQuery(
            GraphQLQueries.Users.GET_USER,
            variables
        );

        GraphQLResponseValidator.assertNoErrors(response);
        response.then()
            .body("data.user.id", equalTo("123"))
            .body("data.user.name", notNullValue())
            .body("data.user.email", notNullValue());
    }

    // Test 3: Mutation - Create user
    @Test
    public void testCreateUserMutation() {
        Map<String, Object> input = Map.of(
            "name", "John Doe",
            "email", "john.doe@example.com",
            "password", "SecurePass123"
        );

        Map<String, Object> variables = Map.of("input", input);

        Response response = graphQLClient.executeMutation(
            GraphQLQueries.Mutations.CREATE_USER,
            variables
        );

        GraphQLResponseValidator.assertNoErrors(response);
        response.then()
            .body("data.createUser.user.id", notNullValue())
            .body("data.createUser.user.name", equalTo("John Doe"))
            .body("data.createUser.user.email", equalTo("john.doe@example.com"))
            .body("data.createUser.errors", nullValue());

        // Extract created user ID
        String userId = response.jsonPath().getString("data.createUser.user.id");
        logger.info("Created user with ID: {}", userId);
    }

    // Test 4: Pagination
    @Test
    public void testPagination() {
        Map<String, Object> variables = Map.of(
            "first", 10,
            "after", ""
        );

        Response response = graphQLClient.executeQuery(
            GraphQLQueries.Users.GET_USERS_WITH_PAGINATION,
            variables
        );

        GraphQLResponseValidator.assertNoErrors(response);
        GraphQLResponseValidator.assertPagination(response, "users", 10, true);

        response.then()
            .body("data.users.edges.size()", equalTo(10))
            .body("data.users.pageInfo.hasNextPage", equalTo(true))
            .body("data.users.pageInfo.endCursor", notNullValue())
            .body("data.users.totalCount", greaterThan(10));

        // Get next page
        String endCursor = response.jsonPath().getString("data.users.pageInfo.endCursor");

        Map<String, Object> nextPageVars = Map.of(
            "first", 10,
            "after", endCursor
        );

        Response nextPageResponse = graphQLClient.executeQuery(
            GraphQLQueries.Users.GET_USERS_WITH_PAGINATION,
            nextPageVars
        );

        GraphQLResponseValidator.assertNoErrors(nextPageResponse);
    }

    // Test 5: Nested query
    @Test
    public void testNestedQuery() {
        Map<String, Object> variables = Map.of("userId", "123");

        Response response = graphQLClient.executeQuery(
            GraphQLQueries.Nested.GET_USER_POSTS_COMMENTS,
            variables
        );

        GraphQLResponseValidator.assertNoErrors(response);
        response.then()
            .body("data.user.id", equalTo("123"))
            .body("data.user.posts.edges", notNullValue())
            .body("data.user.posts.edges[0].node.comments.edges", notNullValue());
    }

    // Test 6: Conditional fields with directives
    @Test
    public void testDirectives() {
        // Test @include directive
        Map<String, Object> variablesWithEmail = Map.of(
            "id", "123",
            "includeEmail", true
        );

        Response responseWithEmail = graphQLClient.executeQuery(
            GraphQLQueries.Directives.CONDITIONAL_QUERY,
            variablesWithEmail
        );

        responseWithEmail.then()
            .body("data.user.email", notNullValue());

        // Test without email
        Map<String, Object> variablesWithoutEmail = Map.of(
            "id", "123",
            "includeEmail", false
        );

        Response responseWithoutEmail = graphQLClient.executeQuery(
            GraphQLQueries.Directives.CONDITIONAL_QUERY,
            variablesWithoutEmail
        );

        responseWithoutEmail.then()
            .body("data.user.email", nullValue());
    }

    // Test 7: Error handling
    @Test
    public void testErrorHandling() {
        // Query non-existent user
        Map<String, Object> variables = Map.of("id", "invalid-id");

        Response response = graphQLClient.executeQuery(
            GraphQLQueries.Users.GET_USER,
            variables
        );

        // Validate error
        GraphQLResponseValidator.assertError(response, "User not found");

        // Log errors
        GraphQLErrorHandler.logErrors(response);

        // Extract errors
        List<GraphQLError> errors = GraphQLErrorHandler.extractErrors(response);
        Assert.assertFalse(errors.isEmpty());
        Assert.assertTrue(errors.get(0).getMessage().contains("User not found"));
    }

    // Test 8: Schema introspection
    @Test
    public void testSchemaIntrospection() {
        Response schemaResponse = graphQLClient.getSchema();

        GraphQLResponseValidator.assertNoErrors(schemaResponse);

        // Validate types exist
        GraphQLSchemaValidator.assertTypeExists(schemaResponse, "User");
        GraphQLSchemaValidator.assertTypeExists(schemaResponse, "Post");

        // Validate fields
        GraphQLSchemaValidator.assertFieldExists(schemaResponse, "User", "id");
        GraphQLSchemaValidator.assertFieldExists(schemaResponse, "User", "name");
        GraphQLSchemaValidator.assertFieldExists(schemaResponse, "User", "email");

        // Validate root types
        GraphQLSchemaValidator.assertQueryType(schemaResponse, "Query");
        GraphQLSchemaValidator.assertMutationType(schemaResponse, "Mutation");
    }

    // Test 9: Aliased queries
    @Test
    public void testAliasedQueries() {
        Map<String, String> aliasedQueries = Map.of(
            "user1", "user(id: \"123\") { id name }",
            "user2", "user(id: \"456\") { id name }",
            "allUsers", "users { id name }"
        );

        Response response = GraphQLBatchExecutor.executeAliased(
            SpecificationBuilder.getBaseRequestSpec(),
            graphqlEndpoint,
            aliasedQueries,
            Map.of()
        );

        GraphQLResponseValidator.assertNoErrors(response);
        response.then()
            .body("data.user1.id", equalTo("123"))
            .body("data.user2.id", equalTo("456"))
            .body("data.allUsers", notNullValue());
    }

    // Test 10: Validation errors
    @Test
    public void testValidationErrors() {
        // Invalid input
        Map<String, Object> invalidInput = Map.of(
            "name", "", // Empty name
            "email", "invalid-email" // Invalid email
        );

        Map<String, Object> variables = Map.of("input", invalidInput);

        Response response = graphQLClient.executeMutation(
            GraphQLQueries.Mutations.CREATE_USER,
            variables
        );

        // Should have validation errors
        response.then()
            .body("data.createUser.errors", notNullValue())
            .body("data.createUser.errors.size()", greaterThan(0))
            .body("data.createUser.errors[0].field", notNullValue())
            .body("data.createUser.errors[0].message", notNullValue());
    }
}
```

**Best Practices**:

1. **Use Variables**: Always use variables instead of inline values
2. **Request Only Needed Fields**: Avoid over-fetching data
3. **Handle Errors**: Check both HTTP status and GraphQL errors
4. **Pagination**: Implement cursor-based pagination
5. **Fragments**: Use fragments for reusable field sets
6. **Introspection**: Validate schema in tests
7. **Batching**: Combine multiple queries when possible
8. **Aliases**: Use aliases for multiple calls to same field
9. **Directives**: Leverage @include and @skip for conditional fields
10. **Type Safety**: Validate response types match schema

**GraphQL vs REST Testing**:

| Aspect | GraphQL | REST |
|--------|---------|------|
| **Endpoint** | Single endpoint | Multiple endpoints |
| **Data Fetching** | Request specific fields | Fixed response structure |
| **Versioning** | Schema evolution | URL versioning |
| **Error Handling** | Errors in response body | HTTP status codes |
| **Caching** | Complex | Simple (HTTP caching) |
| **Testing Focus** | Query structure, schema | Endpoints, status codes |

**Follow-up**: How do you handle GraphQL subscriptions testing? How do you test GraphQL performance and N+1 query problems? How do you implement authentication in GraphQL tests? How do you test GraphQL schema changes and backward compatibility?

---

### **Q110: How do you test SOAP APIs using REST Assured? Explain SOAP request/response handling, WSDL parsing, namespaces, SOAP faults, and WS-Security.**

**Difficulty**: Hard
**Experience Level**: 6-8, 9-12 years
**Companies**: Oracle, SAP, IBM, Adobe, TCS, Infosys, Cognizant, Accenture
**Topics**: SOAP Testing, WSDL, Namespaces, SOAP Faults, WS-Security, XML, REST Assured

**Answer**:

SOAP (Simple Object Access Protocol) API testing requires understanding XML structure, WSDL contracts, namespaces, and security mechanisms. While REST Assured is primarily designed for RESTful APIs, it can effectively test SOAP services with proper configuration.

**Key SOAP Testing Concepts**:

1. **SOAP Envelope Structure**
   - Envelope, Header, Body, Fault
   - XML namespaces
   - SOAP 1.1 vs SOAP 1.2

2. **WSDL (Web Services Description Language)**
   - Service contract definition
   - Operations and messages
   - Binding and endpoints

3. **SOAP Faults**
   - Fault code and string
   - Fault detail
   - Error handling

4. **WS-Security**
   - Username token
   - Timestamp
   - Signature and encryption

**Complete Implementation**:

```java
// ============================================
// 1. SOAP Configuration
// ============================================

import io.restassured.RestAssured;
import io.restassured.builder.RequestSpecBuilder;
import io.restassured.config.EncoderConfig;
import io.restassured.http.ContentType;
import io.restassured.response.Response;
import io.restassured.specification.RequestSpecification;
import org.w3c.dom.Document;
import org.w3c.dom.NodeList;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathFactory;
import java.io.StringReader;
import java.util.HashMap;
import java.util.Map;

public class SOAPConfig {
    private static final String SOAP_11_CONTENT_TYPE = "text/xml; charset=utf-8";
    private static final String SOAP_12_CONTENT_TYPE = "application/soap+xml; charset=utf-8";

    public static RequestSpecification getSOAP11Spec(String endpoint) {
        return new RequestSpecBuilder()
            .setBaseUri(endpoint)
            .setContentType(SOAP_11_CONTENT_TYPE)
            .setConfig(RestAssured.config()
                .encoderConfig(EncoderConfig.encoderConfig()
                    .appendDefaultContentCharsetToContentTypeIfUndefined(false)))
            .build();
    }

    public static RequestSpecification getSOAP12Spec(String endpoint) {
        return new RequestSpecBuilder()
            .setBaseUri(endpoint)
            .setContentType(SOAP_12_CONTENT_TYPE)
            .setConfig(RestAssured.config()
                .encoderConfig(EncoderConfig.encoderConfig()
                    .appendDefaultContentCharsetToContentTypeIfUndefined(false)))
            .build();
    }
}

// ============================================
// 2. SOAP Request Builder
// ============================================

public class SOAPRequestBuilder {
    private String soapAction;
    private String namespace;
    private String methodName;
    private Map<String, String> parameters;
    private Map<String, String> headers;
    private SOAPVersion version;

    public enum SOAPVersion {
        SOAP_11("http://schemas.xmlsoap.org/soap/envelope/"),
        SOAP_12("http://www.w3.org/2003/05/soap-envelope");

        private final String namespace;

        SOAPVersion(String namespace) {
            this.namespace = namespace;
        }

        public String getNamespace() {
            return namespace;
        }
    }

    public SOAPRequestBuilder() {
        this.parameters = new HashMap<>();
        this.headers = new HashMap<>();
        this.version = SOAPVersion.SOAP_11;
    }

    public static SOAPRequestBuilder create() {
        return new SOAPRequestBuilder();
    }

    public SOAPRequestBuilder soapAction(String soapAction) {
        this.soapAction = soapAction;
        return this;
    }

    public SOAPRequestBuilder namespace(String namespace) {
        this.namespace = namespace;
        return this;
    }

    public SOAPRequestBuilder method(String methodName) {
        this.methodName = methodName;
        return this;
    }

    public SOAPRequestBuilder parameter(String key, String value) {
        this.parameters.put(key, value);
        return this;
    }

    public SOAPRequestBuilder parameters(Map<String, String> params) {
        this.parameters.putAll(params);
        return this;
    }

    public SOAPRequestBuilder header(String key, String value) {
        this.headers.put(key, value);
        return this;
    }

    public SOAPRequestBuilder version(SOAPVersion version) {
        this.version = version;
        return this;
    }

    public String build() {
        StringBuilder soap = new StringBuilder();

        // SOAP Envelope
        soap.append("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
        soap.append("<soap:Envelope ");
        soap.append("xmlns:soap=\"").append(version.getNamespace()).append("\" ");

        if (namespace != null) {
            soap.append("xmlns:ns=\"").append(namespace).append("\"");
        }
        soap.append(">\n");

        // SOAP Header (optional)
        if (!headers.isEmpty()) {
            soap.append("  <soap:Header>\n");
            headers.forEach((key, value) -> {
                soap.append("    <").append(key).append(">")
                    .append(value)
                    .append("</").append(key).append(">\n");
            });
            soap.append("  </soap:Header>\n");
        }

        // SOAP Body
        soap.append("  <soap:Body>\n");
        soap.append("    <ns:").append(methodName).append(">\n");

        parameters.forEach((key, value) -> {
            soap.append("      <ns:").append(key).append(">")
                .append(escapeXml(value))
                .append("</ns:").append(key).append(">\n");
        });

        soap.append("    </ns:").append(methodName).append(">\n");
        soap.append("  </soap:Body>\n");
        soap.append("</soap:Envelope>");

        return soap.toString();
    }

    private String escapeXml(String value) {
        if (value == null) return "";
        return value.replace("&", "&amp;")
                   .replace("<", "&lt;")
                   .replace(">", "&gt;")
                   .replace("\"", "&quot;")
                   .replace("'", "&apos;");
    }

    public String getSoapAction() {
        return soapAction;
    }
}

// ============================================
// 3. SOAP Response Parser
// ============================================

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class SOAPResponseParser {
    private static final Logger logger = LoggerFactory.getLogger(SOAPResponseParser.class);
    private Document document;
    private XPath xpath;

    public SOAPResponseParser(String soapResponse) throws Exception {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(true);
        DocumentBuilder builder = factory.newDocumentBuilder();

        this.document = builder.parse(new org.xml.sax.InputSource(
            new StringReader(soapResponse)
        ));

        this.xpath = XPathFactory.newInstance().newXPath();
    }

    public String getElementValue(String xpathExpression) {
        try {
            return (String) xpath.evaluate(xpathExpression, document, XPathConstants.STRING);
        } catch (Exception e) {
            logger.error("Error evaluating XPath: {}", xpathExpression, e);
            return null;
        }
    }

    public NodeList getElements(String xpathExpression) {
        try {
            return (NodeList) xpath.evaluate(xpathExpression, document, XPathConstants.NODESET);
        } catch (Exception e) {
            logger.error("Error evaluating XPath: {}", xpathExpression, e);
            return null;
        }
    }

    public boolean hasFault() {
        String faultCode = getElementValue("//*[local-name()='Fault']/*[local-name()='faultcode']");
        return faultCode != null && !faultCode.isEmpty();
    }

    public SOAPFault getFault() {
        if (!hasFault()) return null;

        SOAPFault fault = new SOAPFault();
        fault.setFaultCode(getElementValue("//*[local-name()='Fault']/*[local-name()='faultcode']"));
        fault.setFaultString(getElementValue("//*[local-name()='Fault']/*[local-name()='faultstring']"));
        fault.setFaultActor(getElementValue("//*[local-name()='Fault']/*[local-name()='faultactor']"));
        fault.setDetail(getElementValue("//*[local-name()='Fault']/*[local-name()='detail']"));

        return fault;
    }

    public String getBodyContent() {
        return getElementValue("//*[local-name()='Body']");
    }

    public Map<String, String> extractFields(Map<String, String> xpathMap) {
        Map<String, String> result = new HashMap<>();
        xpathMap.forEach((key, xpathExpr) -> {
            String value = getElementValue(xpathExpr);
            result.put(key, value);
        });
        return result;
    }
}

// ============================================
// 4. SOAP Fault Model
// ============================================

public class SOAPFault {
    private String faultCode;
    private String faultString;
    private String faultActor;
    private String detail;

    // Getters and setters
    public String getFaultCode() { return faultCode; }
    public void setFaultCode(String faultCode) { this.faultCode = faultCode; }

    public String getFaultString() { return faultString; }
    public void setFaultString(String faultString) { this.faultString = faultString; }

    public String getFaultActor() { return faultActor; }
    public void setFaultActor(String faultActor) { this.faultActor = faultActor; }

    public String getDetail() { return detail; }
    public void setDetail(String detail) { this.detail = detail; }

    @Override
    public String toString() {
        return String.format("SOAPFault{code='%s', string='%s', actor='%s', detail='%s'}",
            faultCode, faultString, faultActor, detail);
    }
}

// ============================================
// 5. WS-Security Handler
// ============================================

import java.security.MessageDigest;
import java.text.SimpleDateFormat;
import java.util.Base64;
import java.util.Date;
import java.util.TimeZone;
import java.util.UUID;

public class WSSecurityHandler {

    public static String addUsernameToken(String soapRequest, String username, String password) {
        String nonce = generateNonce();
        String created = generateTimestamp();
        String passwordDigest = generatePasswordDigest(nonce, created, password);

        String securityHeader = buildSecurityHeader(username, passwordDigest, nonce, created);

        // Insert security header into SOAP envelope
        return soapRequest.replace("<soap:Header>",
            "<soap:Header>\n" + securityHeader);
    }

    private static String buildSecurityHeader(String username, String passwordDigest,
                                             String nonce, String created) {
        StringBuilder header = new StringBuilder();
        header.append("    <wsse:Security xmlns:wsse=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd\" ");
        header.append("xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">\n");
        header.append("      <wsse:UsernameToken wsu:Id=\"UsernameToken-").append(UUID.randomUUID()).append("\">\n");
        header.append("        <wsse:Username>").append(username).append("</wsse:Username>\n");
        header.append("        <wsse:Password Type=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordDigest\">");
        header.append(passwordDigest).append("</wsse:Password>\n");
        header.append("        <wsse:Nonce EncodingType=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary\">");
        header.append(nonce).append("</wsse:Nonce>\n");
        header.append("        <wsu:Created>").append(created).append("</wsu:Created>\n");
        header.append("      </wsse:UsernameToken>\n");
        header.append("    </wsse:Security>\n");
        return header.toString();
    }

    private static String generateNonce() {
        byte[] nonceBytes = new byte[16];
        new java.security.SecureRandom().nextBytes(nonceBytes);
        return Base64.getEncoder().encodeToString(nonceBytes);
    }

    private static String generateTimestamp() {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'");
        sdf.setTimeZone(TimeZone.getTimeZone("UTC"));
        return sdf.format(new Date());
    }

    private static String generatePasswordDigest(String nonce, String created, String password) {
        try {
            byte[] nonceBytes = Base64.getDecoder().decode(nonce);
            byte[] createdBytes = created.getBytes("UTF-8");
            byte[] passwordBytes = password.getBytes("UTF-8");

            byte[] combined = new byte[nonceBytes.length + createdBytes.length + passwordBytes.length];
            System.arraycopy(nonceBytes, 0, combined, 0, nonceBytes.length);
            System.arraycopy(createdBytes, 0, combined, nonceBytes.length, createdBytes.length);
            System.arraycopy(passwordBytes, 0, combined, nonceBytes.length + createdBytes.length, passwordBytes.length);

            MessageDigest digest = MessageDigest.getInstance("SHA-1");
            byte[] hash = digest.digest(combined);

            return Base64.getEncoder().encodeToString(hash);
        } catch (Exception e) {
            throw new RuntimeException("Error generating password digest", e);
        }
    }

    public static String addTimestamp(String soapRequest, int expiryMinutes) {
        String created = generateTimestamp();
        String expires = generateExpiryTimestamp(expiryMinutes);

        String timestampHeader = buildTimestampHeader(created, expires);

        return soapRequest.replace("<soap:Header>",
            "<soap:Header>\n" + timestampHeader);
    }

    private static String generateExpiryTimestamp(int minutes) {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'");
        sdf.setTimeZone(TimeZone.getTimeZone("UTC"));
        Date expiry = new Date(System.currentTimeMillis() + (minutes * 60 * 1000));
        return sdf.format(expiry);
    }

    private static String buildTimestampHeader(String created, String expires) {
        StringBuilder header = new StringBuilder();
        header.append("    <wsu:Timestamp xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\" ");
        header.append("wsu:Id=\"Timestamp-").append(UUID.randomUUID()).append("\">\n");
        header.append("      <wsu:Created>").append(created).append("</wsu:Created>\n");
        header.append("      <wsu:Expires>").append(expires).append("</wsu:Expires>\n");
        header.append("    </wsu:Timestamp>\n");
        return header.toString();
    }
}

// ============================================
// 6. SOAP Client
// ============================================

import static io.restassured.RestAssured.given;

public class SOAPClient {
    private static final Logger logger = LoggerFactory.getLogger(SOAPClient.class);
    private String endpoint;
    private RequestSpecification requestSpec;

    public SOAPClient(String endpoint) {
        this.endpoint = endpoint;
        this.requestSpec = SOAPConfig.getSOAP11Spec(endpoint);
    }

    public SOAPClient(String endpoint, SOAPRequestBuilder.SOAPVersion version) {
        this.endpoint = endpoint;
        if (version == SOAPRequestBuilder.SOAPVersion.SOAP_11) {
            this.requestSpec = SOAPConfig.getSOAP11Spec(endpoint);
        } else {
            this.requestSpec = SOAPConfig.getSOAP12Spec(endpoint);
        }
    }

    public Response sendRequest(SOAPRequestBuilder builder) {
        String soapRequest = builder.build();
        logger.info("Sending SOAP Request:\n{}", soapRequest);

        Response response = given()
            .spec(requestSpec)
            .header("SOAPAction", builder.getSoapAction())
            .body(soapRequest)
        .when()
            .post()
        .then()
            .extract().response();

        logger.info("Received SOAP Response:\nStatus Code: {}\nBody:\n{}",
            response.getStatusCode(), response.getBody().asString());

        return response;
    }

    public Response sendSecureRequest(SOAPRequestBuilder builder, String username, String password) {
        String soapRequest = builder.build();

        // Add WS-Security headers
        soapRequest = WSSecurityHandler.addUsernameToken(soapRequest, username, password);
        soapRequest = WSSecurityHandler.addTimestamp(soapRequest, 5);

        logger.info("Sending Secure SOAP Request:\n{}", soapRequest);

        Response response = given()
            .spec(requestSpec)
            .header("SOAPAction", builder.getSoapAction())
            .body(soapRequest)
        .when()
            .post()
        .then()
            .extract().response();

        logger.info("Received SOAP Response:\nStatus Code: {}\nBody:\n{}",
            response.getStatusCode(), response.getBody().asString());

        return response;
    }

    public SOAPResponseParser parseResponse(Response response) {
        try {
            return new SOAPResponseParser(response.getBody().asString());
        } catch (Exception e) {
            logger.error("Error parsing SOAP response", e);
            throw new RuntimeException("Failed to parse SOAP response", e);
        }
    }
}

// ============================================
// 7. SOAP Test Examples
// ============================================

import org.testng.annotations.BeforeClass;
import org.testng.annotations.Test;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.*;

public class SOAPAPITest {
    private SOAPClient soapClient;
    private static final String ENDPOINT = "http://www.dneonline.com/calculator.asmx";
    private static final String NAMESPACE = "http://tempuri.org/";

    @BeforeClass
    public void setup() {
        soapClient = new SOAPClient(ENDPOINT);
    }

    @Test(description = "Test basic SOAP request - Add operation")
    public void testAddOperation() throws Exception {
        // Build SOAP request
        SOAPRequestBuilder builder = SOAPRequestBuilder.create()
            .soapAction(NAMESPACE + "Add")
            .namespace(NAMESPACE)
            .method("Add")
            .parameter("intA", "10")
            .parameter("intB", "20");

        // Send request
        Response response = soapClient.sendRequest(builder);

        // Parse response
        SOAPResponseParser parser = soapClient.parseResponse(response);

        // Assertions
        assertThat(response.getStatusCode(), equalTo(200));
        assertThat(parser.hasFault(), is(false));

        String result = parser.getElementValue("//*[local-name()='AddResult']");
        assertThat(result, equalTo("30"));
    }

    @Test(description = "Test SOAP request with multiply operation")
    public void testMultiplyOperation() throws Exception {
        SOAPRequestBuilder builder = SOAPRequestBuilder.create()
            .soapAction(NAMESPACE + "Multiply")
            .namespace(NAMESPACE)
            .method("Multiply")
            .parameter("intA", "5")
            .parameter("intB", "6");

        Response response = soapClient.sendRequest(builder);
        SOAPResponseParser parser = soapClient.parseResponse(response);

        assertThat(response.getStatusCode(), equalTo(200));

        String result = parser.getElementValue("//*[local-name()='MultiplyResult']");
        assertThat(result, equalTo("30"));
    }

    @Test(description = "Test SOAP fault handling")
    public void testSOAPFault() throws Exception {
        // Intentionally send invalid request to trigger fault
        SOAPRequestBuilder builder = SOAPRequestBuilder.create()
            .soapAction(NAMESPACE + "InvalidOperation")
            .namespace(NAMESPACE)
            .method("InvalidOperation")
            .parameter("invalidParam", "test");

        Response response = soapClient.sendRequest(builder);
        SOAPResponseParser parser = soapClient.parseResponse(response);

        // Verify fault is present
        if (parser.hasFault()) {
            SOAPFault fault = parser.getFault();
            logger.info("SOAP Fault detected: {}", fault);

            assertThat(fault.getFaultCode(), notNullValue());
            assertThat(fault.getFaultString(), notNullValue());
        }
    }

    @Test(description = "Test SOAP 1.2 version")
    public void testSOAP12() throws Exception {
        SOAPClient soap12Client = new SOAPClient(ENDPOINT,
            SOAPRequestBuilder.SOAPVersion.SOAP_12);

        SOAPRequestBuilder builder = SOAPRequestBuilder.create()
            .version(SOAPRequestBuilder.SOAPVersion.SOAP_12)
            .soapAction(NAMESPACE + "Add")
            .namespace(NAMESPACE)
            .method("Add")
            .parameter("intA", "15")
            .parameter("intB", "25");

        Response response = soap12Client.sendRequest(builder);

        assertThat(response.getStatusCode(), equalTo(200));
        assertThat(response.getContentType(), containsString("application/soap+xml"));
    }

    @Test(description = "Test WS-Security with username token")
    public void testWSSecurityUsernameToken() throws Exception {
        String secureEndpoint = "https://secure-soap-service.example.com/service";
        SOAPClient secureClient = new SOAPClient(secureEndpoint);

        SOAPRequestBuilder builder = SOAPRequestBuilder.create()
            .soapAction("http://example.com/GetUserInfo")
            .namespace("http://example.com/")
            .method("GetUserInfo")
            .parameter("userId", "12345");

        // Send secure request with WS-Security
        Response response = secureClient.sendSecureRequest(builder, "testuser", "password123");

        // Verify security headers were added
        String requestBody = builder.build();
        assertThat(requestBody, containsString("wsse:Security"));
        assertThat(requestBody, containsString("wsse:UsernameToken"));
    }

    @Test(description = "Test extracting multiple fields from response")
    public void testExtractMultipleFields() throws Exception {
        SOAPRequestBuilder builder = SOAPRequestBuilder.create()
            .soapAction(NAMESPACE + "Add")
            .namespace(NAMESPACE)
            .method("Add")
            .parameter("intA", "100")
            .parameter("intB", "200");

        Response response = soapClient.sendRequest(builder);
        SOAPResponseParser parser = soapClient.parseResponse(response);

        // Define fields to extract with XPath
        Map<String, String> xpathMap = new HashMap<>();
        xpathMap.put("result", "//*[local-name()='AddResult']");

        Map<String, String> extractedData = parser.extractFields(xpathMap);

        assertThat(extractedData.get("result"), equalTo("300"));
        logger.info("Extracted data: {}", extractedData);
    }

    @Test(description = "Test SOAP with custom headers")
    public void testSOAPWithCustomHeaders() throws Exception {
        SOAPRequestBuilder builder = SOAPRequestBuilder.create()
            .soapAction(NAMESPACE + "Add")
            .namespace(NAMESPACE)
            .method("Add")
            .parameter("intA", "50")
            .parameter("intB", "75")
            .header("CustomHeader", "CustomValue")
            .header("RequestId", UUID.randomUUID().toString());

        Response response = soapClient.sendRequest(builder);
        SOAPResponseParser parser = soapClient.parseResponse(response);

        assertThat(response.getStatusCode(), equalTo(200));
        assertThat(parser.hasFault(), is(false));
    }
}

// ============================================
// 8. WSDL Parser (Basic)
// ============================================

import javax.wsdl.*;
import javax.wsdl.factory.WSDLFactory;
import javax.wsdl.xml.WSDLReader;
import java.util.ArrayList;
import java.util.List;

public class WSDLParser {
    private Definition wsdlDefinition;

    public WSDLParser(String wsdlUrl) throws Exception {
        WSDLFactory factory = WSDLFactory.newInstance();
        WSDLReader reader = factory.newWSDLReader();
        reader.setFeature("javax.wsdl.verbose", false);
        this.wsdlDefinition = reader.readWSDL(wsdlUrl);
    }

    public List<String> getOperations() {
        List<String> operations = new ArrayList<>();

        wsdlDefinition.getPortTypes().values().forEach(portType -> {
            ((PortType) portType).getOperations().forEach(operation -> {
                operations.add(((Operation) operation).getName());
            });
        });

        return operations;
    }

    public String getServiceEndpoint() {
        Service service = (Service) wsdlDefinition.getServices().values().iterator().next();
        Port port = (Port) service.getPorts().values().iterator().next();

        if (port.getExtensibilityElements().size() > 0) {
            return ((javax.wsdl.extensions.soap.SOAPAddress)
                port.getExtensibilityElements().get(0)).getLocationURI();
        }

        return null;
    }

    public String getTargetNamespace() {
        return wsdlDefinition.getTargetNamespace();
    }
}
```

**Best Practices**:

1. **Namespace Handling**: Always use namespace-aware XML parsing
2. **SOAP Action**: Include SOAPAction header for SOAP 1.1
3. **Error Handling**: Always check for SOAP faults before parsing body
4. **Security**: Use WS-Security for authentication when required
5. **Logging**: Log both request and response for debugging
6. **XPath**: Use local-name() to avoid namespace issues
7. **Validation**: Validate against WSDL schema when possible
8. **Content Type**: Use correct content type (text/xml for SOAP 1.1, application/soap+xml for SOAP 1.2)
9. **Character Encoding**: Explicitly set UTF-8 encoding
10. **Timeouts**: Configure appropriate timeouts for SOAP services

**SOAP vs REST Comparison**:

| Aspect | SOAP | REST |
|--------|------|------|
| **Protocol** | Protocol (strict standards) | Architectural style |
| **Message Format** | XML only | JSON, XML, others |
| **Transport** | HTTP, SMTP, TCP, others | Primarily HTTP |
| **Security** | WS-Security | OAuth, JWT, Basic Auth |
| **Contract** | WSDL (mandatory) | OpenAPI (optional) |
| **State** | Stateless or stateful | Stateless |
| **Error Handling** | SOAP Faults | HTTP status codes |
| **Performance** | Slower (XML overhead) | Faster (JSON) |
| **Testing Complexity** | Higher | Lower |

**Follow-up**: How do you handle SOAP attachments (MTOM/SwA)? How do you test SOAP services with complex types and nested structures? How do you integrate SOAP tests with CI/CD? How do you mock SOAP services for testing?

---

### **Q111: How do you test WebSocket APIs? Explain WebSocket protocol, handshake, message handling, and real-time event testing.**

**Difficulty**: Hard
**Experience Level**: 6-8, 9-12 years
**Companies**: Uber, Ola, Swiggy, Zomato, Google, Microsoft, Amazon, PhonePe, Paytm
**Topics**: WebSocket, Real-time Testing, WSS, Java-WebSocket, Event-driven Testing

**Answer**:

WebSocket is a communication protocol providing full-duplex communication channels over a single TCP connection. It's widely used for real-time applications like chat, live notifications, trading platforms, and collaborative tools. Testing WebSocket APIs requires understanding the protocol, connection lifecycle, message handling, and event-driven testing approaches.

**Key WebSocket Concepts**:

1. **WebSocket Protocol**
   - Full-duplex bidirectional communication
   - Persistent connection
   - Low latency
   - ws:// (insecure) and wss:// (secure)

2. **Connection Lifecycle**
   - Handshake (HTTP upgrade)
   - Open connection
   - Message exchange
   - Close connection

3. **Message Types**
   - Text messages (UTF-8)
   - Binary messages
   - Control frames (ping/pong, close)

4. **Testing Challenges**
   - Asynchronous nature
   - Event-driven messages
   - Connection state management
   - Performance under load

**Complete Implementation**:

```java
// ============================================
// 1. WebSocket Client Implementation
// ============================================

import org.java_websocket.client.WebSocketClient;
import org.java_websocket.handshake.ServerHandshake;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.net.URI;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

public class TestWebSocketClient extends WebSocketClient {
    private static final Logger logger = LoggerFactory.getLogger(TestWebSocketClient.class);

    private List<String> receivedMessages;
    private CountDownLatch connectLatch;
    private CountDownLatch messageLatch;
    private CountDownLatch closeLatch;
    private AtomicBoolean isConnected;
    private String lastError;
    private int expectedMessageCount;

    public TestWebSocketClient(URI serverUri) {
        super(serverUri);
        this.receivedMessages = new ArrayList<>();
        this.connectLatch = new CountDownLatch(1);
        this.closeLatch = new CountDownLatch(1);
        this.isConnected = new AtomicBoolean(false);
        this.expectedMessageCount = 0;
    }

    public TestWebSocketClient(URI serverUri, int expectedMessages) {
        this(serverUri);
        this.expectedMessageCount = expectedMessages;
        this.messageLatch = new CountDownLatch(expectedMessages);
    }

    @Override
    public void onOpen(ServerHandshake handshakedata) {
        logger.info("WebSocket connection opened");
        logger.info("Status: {}", handshakedata.getHttpStatus());
        logger.info("Status Message: {}", handshakedata.getHttpStatusMessage());

        isConnected.set(true);
        connectLatch.countDown();
    }

    @Override
    public void onMessage(String message) {
        logger.info("Received message: {}", message);
        receivedMessages.add(message);

        if (messageLatch != null) {
            messageLatch.countDown();
        }
    }

    @Override
    public void onClose(int code, String reason, boolean remote) {
        logger.info("WebSocket connection closed. Code: {}, Reason: {}, Remote: {}",
            code, reason, remote);
        isConnected.set(false);
        closeLatch.countDown();
    }

    @Override
    public void onError(Exception ex) {
        logger.error("WebSocket error occurred", ex);
        this.lastError = ex.getMessage();
    }

    // Helper methods for testing
    public boolean waitForConnection(long timeout, TimeUnit unit) throws InterruptedException {
        return connectLatch.await(timeout, unit);
    }

    public boolean waitForMessages(long timeout, TimeUnit unit) throws InterruptedException {
        if (messageLatch == null) {
            throw new IllegalStateException("Expected message count not set");
        }
        return messageLatch.await(timeout, unit);
    }

    public boolean waitForClose(long timeout, TimeUnit unit) throws InterruptedException {
        return closeLatch.await(timeout, unit);
    }

    public List<String> getReceivedMessages() {
        return new ArrayList<>(receivedMessages);
    }

    public void clearMessages() {
        receivedMessages.clear();
    }

    public boolean isConnected() {
        return isConnected.get();
    }

    public String getLastError() {
        return lastError;
    }

    public int getReceivedMessageCount() {
        return receivedMessages.size();
    }
}

// ============================================
// 2. WebSocket Configuration
// ============================================

import java.net.URI;
import java.util.HashMap;
import java.util.Map;

public class WebSocketConfig {
    private String url;
    private Map<String, String> headers;
    private int connectionTimeout;
    private boolean autoReconnect;
    private int maxReconnectAttempts;

    private WebSocketConfig(Builder builder) {
        this.url = builder.url;
        this.headers = builder.headers;
        this.connectionTimeout = builder.connectionTimeout;
        this.autoReconnect = builder.autoReconnect;
        this.maxReconnectAttempts = builder.maxReconnectAttempts;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static class Builder {
        private String url;
        private Map<String, String> headers = new HashMap<>();
        private int connectionTimeout = 5000; // 5 seconds
        private boolean autoReconnect = false;
        private int maxReconnectAttempts = 3;

        public Builder url(String url) {
            this.url = url;
            return this;
        }

        public Builder header(String key, String value) {
            this.headers.put(key, value);
            return this;
        }

        public Builder connectionTimeout(int timeoutMs) {
            this.connectionTimeout = timeoutMs;
            return this;
        }

        public Builder autoReconnect(boolean autoReconnect) {
            this.autoReconnect = autoReconnect;
            return this;
        }

        public Builder maxReconnectAttempts(int attempts) {
            this.maxReconnectAttempts = attempts;
            return this;
        }

        public WebSocketConfig build() {
            if (url == null || url.isEmpty()) {
                throw new IllegalArgumentException("WebSocket URL is required");
            }
            return new WebSocketConfig(this);
        }
    }

    // Getters
    public String getUrl() { return url; }
    public Map<String, String> getHeaders() { return headers; }
    public int getConnectionTimeout() { return connectionTimeout; }
    public boolean isAutoReconnect() { return autoReconnect; }
    public int getMaxReconnectAttempts() { return maxReconnectAttempts; }
}

// ============================================
// 3. WebSocket Message Handler
// ============================================

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Consumer;

public class WebSocketMessageHandler {
    private static final Logger logger = LoggerFactory.getLogger(WebSocketMessageHandler.class);
    private static final ObjectMapper objectMapper = new ObjectMapper();

    private Map<String, Consumer<JsonNode>> eventHandlers;

    public WebSocketMessageHandler() {
        this.eventHandlers = new HashMap<>();
    }

    public void registerHandler(String eventType, Consumer<JsonNode> handler) {
        eventHandlers.put(eventType, handler);
        logger.info("Registered handler for event type: {}", eventType);
    }

    public void handleMessage(String message) {
        try {
            JsonNode jsonNode = objectMapper.readTree(message);
            String eventType = jsonNode.has("type") ? jsonNode.get("type").asText() : "unknown";

            Consumer<JsonNode> handler = eventHandlers.get(eventType);
            if (handler != null) {
                logger.info("Handling event type: {}", eventType);
                handler.accept(jsonNode);
            } else {
                logger.warn("No handler found for event type: {}", eventType);
            }
        } catch (Exception e) {
            logger.error("Error handling message: {}", message, e);
        }
    }

    public void removeHandler(String eventType) {
        eventHandlers.remove(eventType);
    }

    public void clearHandlers() {
        eventHandlers.clear();
    }
}

// ============================================
// 4. Advanced WebSocket Client with Handlers
// ============================================

public class AdvancedWebSocketClient extends TestWebSocketClient {
    private WebSocketMessageHandler messageHandler;
    private Map<String, Object> receivedEvents;

    public AdvancedWebSocketClient(URI serverUri) {
        super(serverUri);
        this.messageHandler = new WebSocketMessageHandler();
        this.receivedEvents = new HashMap<>();
    }

    public void registerEventHandler(String eventType, Consumer<JsonNode> handler) {
        messageHandler.registerHandler(eventType, handler);
    }

    @Override
    public void onMessage(String message) {
        super.onMessage(message);
        messageHandler.handleMessage(message);
    }

    public void storeEvent(String eventType, Object data) {
        receivedEvents.put(eventType, data);
    }

    public <T> T getEvent(String eventType) {
        return (T) receivedEvents.get(eventType);
    }

    public boolean hasEvent(String eventType) {
        return receivedEvents.containsKey(eventType);
    }

    public void clearEvents() {
        receivedEvents.clear();
    }
}

// ============================================
// 5. WebSocket Test Helper
// ============================================

import java.net.URI;
import java.util.concurrent.TimeUnit;

public class WebSocketTestHelper {
    private static final Logger logger = LoggerFactory.getLogger(WebSocketTestHelper.class);

    public static TestWebSocketClient connectAndWait(String url, long timeout, TimeUnit unit)
            throws Exception {
        URI uri = new URI(url);
        TestWebSocketClient client = new TestWebSocketClient(uri);

        client.connectBlocking();

        boolean connected = client.waitForConnection(timeout, unit);
        if (!connected) {
            throw new RuntimeException("WebSocket connection timeout");
        }

        logger.info("WebSocket connected successfully");
        return client;
    }

    public static void sendAndWaitForResponse(TestWebSocketClient client, String message,
            int expectedResponses, long timeout, TimeUnit unit) throws Exception {

        client.send(message);
        logger.info("Sent message: {}", message);

        boolean received = client.waitForMessages(timeout, unit);
        if (!received) {
            throw new RuntimeException("Timeout waiting for responses");
        }

        logger.info("Received expected responses");
    }

    public static void closeAndWait(TestWebSocketClient client, long timeout, TimeUnit unit)
            throws Exception {
        client.close();

        boolean closed = client.waitForClose(timeout, unit);
        if (!closed) {
            throw new RuntimeException("WebSocket close timeout");
        }

        logger.info("WebSocket closed successfully");
    }

    public static String buildJsonMessage(String type, Map<String, Object> data) {
        try {
            ObjectMapper mapper = new ObjectMapper();
            Map<String, Object> message = new HashMap<>();
            message.put("type", type);
            message.put("data", data);
            return mapper.writeValueAsString(message);
        } catch (Exception e) {
            throw new RuntimeException("Error building JSON message", e);
        }
    }
}

// ============================================
// 6. WebSocket Test Examples
// ============================================

import org.testng.annotations.AfterMethod;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.Test;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.*;
import com.fasterxml.jackson.databind.JsonNode;
import java.net.URI;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;

public class WebSocketAPITest {
    private static final String WS_URL = "ws://echo.websocket.org";
    private static final String WSS_URL = "wss://echo.websocket.org";
    private TestWebSocketClient client;

    @BeforeMethod
    public void setup() {
        // Setup is done per test method
    }

    @AfterMethod
    public void tearDown() {
        if (client != null && client.isConnected()) {
            client.close();
        }
    }

    @Test(description = "Test basic WebSocket connection")
    public void testBasicConnection() throws Exception {
        client = WebSocketTestHelper.connectAndWait(WS_URL, 5, TimeUnit.SECONDS);

        assertThat(client.isConnected(), is(true));
        assertThat(client.getLastError(), nullValue());
    }

    @Test(description = "Test sending and receiving text messages")
    public void testSendReceiveTextMessage() throws Exception {
        URI uri = new URI(WS_URL);
        client = new TestWebSocketClient(uri, 1); // Expect 1 message

        client.connectBlocking();
        client.waitForConnection(5, TimeUnit.SECONDS);

        // Send message
        String testMessage = "Hello WebSocket!";
        client.send(testMessage);

        // Wait for echo response
        boolean received = client.waitForMessages(5, TimeUnit.SECONDS);
        assertThat(received, is(true));

        // Verify received message
        List<String> messages = client.getReceivedMessages();
        assertThat(messages, hasSize(1));
        assertThat(messages.get(0), equalTo(testMessage));
    }

    @Test(description = "Test sending JSON message")
    public void testSendJsonMessage() throws Exception {
        client = WebSocketTestHelper.connectAndWait(WS_URL, 5, TimeUnit.SECONDS);

        // Build JSON message
        Map<String, Object> data = new HashMap<>();
        data.put("userId", "12345");
        data.put("action", "subscribe");

        String jsonMessage = WebSocketTestHelper.buildJsonMessage("subscribe", data);
        client.send(jsonMessage);

        // Wait for response
        Thread.sleep(2000);

        assertThat(client.getReceivedMessageCount(), greaterThan(0));
    }

    @Test(description = "Test multiple messages")
    public void testMultipleMessages() throws Exception {
        URI uri = new URI(WS_URL);
        client = new TestWebSocketClient(uri, 5); // Expect 5 messages

        client.connectBlocking();
        client.waitForConnection(5, TimeUnit.SECONDS);

        // Send 5 messages
        for (int i = 1; i <= 5; i++) {
            client.send("Message " + i);
            Thread.sleep(100); // Small delay between messages
        }

        // Wait for all responses
        boolean received = client.waitForMessages(10, TimeUnit.SECONDS);
        assertThat(received, is(true));

        List<String> messages = client.getReceivedMessages();
        assertThat(messages, hasSize(5));
    }

    @Test(description = "Test WebSocket with event handlers")
    public void testWithEventHandlers() throws Exception {
        URI uri = new URI(WS_URL);
        AdvancedWebSocketClient advancedClient = new AdvancedWebSocketClient(uri);

        // Register event handlers
        advancedClient.registerEventHandler("welcome", node -> {
            logger.info("Received welcome event");
            advancedClient.storeEvent("welcome", node.get("data"));
        });

        advancedClient.registerEventHandler("notification", node -> {
            logger.info("Received notification event");
            advancedClient.storeEvent("notification", node.get("data"));
        });

        advancedClient.connectBlocking();
        advancedClient.waitForConnection(5, TimeUnit.SECONDS);

        // Send messages with different event types
        String welcomeMsg = "{\"type\":\"welcome\",\"data\":{\"message\":\"Hello\"}}";
        advancedClient.send(welcomeMsg);

        Thread.sleep(2000);

        advancedClient.close();
        this.client = advancedClient; // For cleanup
    }

    @Test(description = "Test secure WebSocket (WSS)")
    public void testSecureWebSocket() throws Exception {
        client = WebSocketTestHelper.connectAndWait(WSS_URL, 5, TimeUnit.SECONDS);

        assertThat(client.isConnected(), is(true));

        client.send("Secure message");
        Thread.sleep(2000);

        assertThat(client.getReceivedMessageCount(), greaterThan(0));
    }

    @Test(description = "Test connection close")
    public void testConnectionClose() throws Exception {
        client = WebSocketTestHelper.connectAndWait(WS_URL, 5, TimeUnit.SECONDS);

        assertThat(client.isConnected(), is(true));

        WebSocketTestHelper.closeAndWait(client, 5, TimeUnit.SECONDS);

        assertThat(client.isConnected(), is(false));
    }

    @Test(description = "Test connection timeout", expectedExceptions = RuntimeException.class)
    public void testConnectionTimeout() throws Exception {
        // Use invalid URL to test timeout
        client = WebSocketTestHelper.connectAndWait("ws://invalid-url-12345.com", 2, TimeUnit.SECONDS);
    }

    @Test(description = "Test ping-pong mechanism")
    public void testPingPong() throws Exception {
        client = WebSocketTestHelper.connectAndWait(WS_URL, 5, TimeUnit.SECONDS);

        // Send ping
        client.sendPing();

        Thread.sleep(1000);

        // WebSocket should automatically respond with pong
        assertThat(client.isConnected(), is(true));
    }
}

// ============================================
// 7. WebSocket Load Testing Helper
// ============================================

import java.net.URI;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

public class WebSocketLoadTester {
    private static final Logger logger = LoggerFactory.getLogger(WebSocketLoadTester.class);
    private ExecutorService executorService;

    public LoadTestResult runLoadTest(String url, int clientCount, int messagesPerClient,
            long durationSeconds) throws Exception {

        logger.info("Starting load test: {} clients, {} messages each, {} seconds",
            clientCount, messagesPerClient, durationSeconds);

        executorService = Executors.newFixedThreadPool(clientCount);
        List<Future<ClientStats>> futures = new ArrayList<>();
        AtomicInteger successfulConnections = new AtomicInteger(0);
        AtomicInteger failedConnections = new AtomicInteger(0);

        long startTime = System.currentTimeMillis();

        // Create and start clients
        for (int i = 0; i < clientCount; i++) {
            final int clientId = i;
            Future<ClientStats> future = executorService.submit(() -> {
                return runClient(clientId, url, messagesPerClient);
            });
            futures.add(future);
        }

        // Collect results
        List<ClientStats> allStats = new ArrayList<>();
        for (Future<ClientStats> future : futures) {
            try {
                ClientStats stats = future.get(durationSeconds + 10, TimeUnit.SECONDS);
                allStats.add(stats);
                if (stats.isConnected) {
                    successfulConnections.incrementAndGet();
                } else {
                    failedConnections.incrementAndGet();
                }
            } catch (Exception e) {
                logger.error("Error getting client stats", e);
                failedConnections.incrementAndGet();
            }
        }

        long endTime = System.currentTimeMillis();
        executorService.shutdown();

        return new LoadTestResult(allStats, successfulConnections.get(),
            failedConnections.get(), endTime - startTime);
    }

    private ClientStats runClient(int clientId, String url, int messageCount) {
        ClientStats stats = new ClientStats(clientId);

        try {
            URI uri = new URI(url);
            TestWebSocketClient client = new TestWebSocketClient(uri);

            long connectStart = System.currentTimeMillis();
            client.connectBlocking();
            client.waitForConnection(5, TimeUnit.SECONDS);
            long connectEnd = System.currentTimeMillis();

            stats.isConnected = client.isConnected();
            stats.connectionTime = connectEnd - connectStart;

            if (stats.isConnected) {
                long sendStart = System.currentTimeMillis();
                for (int i = 0; i < messageCount; i++) {
                    client.send("Message " + i + " from client " + clientId);
                    Thread.sleep(10); // Small delay
                }
                long sendEnd = System.currentTimeMillis();

                Thread.sleep(1000); // Wait for responses

                stats.messagesSent = messageCount;
                stats.messagesReceived = client.getReceivedMessageCount();
                stats.totalTime = sendEnd - sendStart;
            }

            client.close();

        } catch (Exception e) {
            logger.error("Error in client {}", clientId, e);
            stats.error = e.getMessage();
        }

        return stats;
    }

    public void shutdown() {
        if (executorService != null) {
            executorService.shutdown();
        }
    }

    // Stats classes
    public static class ClientStats {
        int clientId;
        boolean isConnected;
        long connectionTime;
        int messagesSent;
        int messagesReceived;
        long totalTime;
        String error;

        public ClientStats(int clientId) {
            this.clientId = clientId;
        }
    }

    public static class LoadTestResult {
        List<ClientStats> clientStats;
        int successfulConnections;
        int failedConnections;
        long totalDuration;

        public LoadTestResult(List<ClientStats> stats, int successful, int failed, long duration) {
            this.clientStats = stats;
            this.successfulConnections = successful;
            this.failedConnections = failed;
            this.totalDuration = duration;
        }

        public void printSummary() {
            logger.info("=== Load Test Summary ===");
            logger.info("Total Clients: {}", clientStats.size());
            logger.info("Successful Connections: {}", successfulConnections);
            logger.info("Failed Connections: {}", failedConnections);
            logger.info("Total Duration: {} ms", totalDuration);

            long avgConnectionTime = clientStats.stream()
                .filter(s -> s.isConnected)
                .mapToLong(s -> s.connectionTime)
                .sum() / Math.max(1, successfulConnections);

            int totalSent = clientStats.stream().mapToInt(s -> s.messagesSent).sum();
            int totalReceived = clientStats.stream().mapToInt(s -> s.messagesReceived).sum();

            logger.info("Average Connection Time: {} ms", avgConnectionTime);
            logger.info("Total Messages Sent: {}", totalSent);
            logger.info("Total Messages Received: {}", totalReceived);
            logger.info("Message Success Rate: {}%",
                totalSent > 0 ? (totalReceived * 100.0 / totalSent) : 0);
        }
    }
}
```

**Best Practices**:

1. **Connection Management**: Always close connections in finally block or @AfterMethod
2. **Timeouts**: Use appropriate timeouts for connection and message waits
3. **Threading**: Use CountDownLatch or CompletableFuture for async operations
4. **Message Validation**: Parse and validate JSON messages properly
5. **Error Handling**: Implement onError handler and log all errors
6. **Heartbeat**: Implement ping-pong for connection health checks
7. **Reconnection**: Implement automatic reconnection logic for production
8. **Event Handling**: Use event-driven handlers for different message types
9. **Load Testing**: Test with multiple concurrent connections
10. **Security**: Use WSS (secure WebSocket) for sensitive data

**WebSocket vs HTTP Comparison**:

| Aspect | WebSocket | HTTP |
|--------|-----------|------|
| **Communication** | Full-duplex (bidirectional) | Half-duplex (request-response) |
| **Connection** | Persistent | Connection per request |
| **Latency** | Very low | Higher |
| **Overhead** | Low (after handshake) | High (headers per request) |
| **Use Case** | Real-time updates | Traditional APIs |
| **Testing** | Event-driven, async | Synchronous |
| **Protocol** | ws:// or wss:// | http:// or https:// |

**Follow-up**: How do you test WebSocket authentication and authorization? How do you handle WebSocket reconnection scenarios? How do you test WebSocket performance under high message volume? How do you integrate WebSocket tests with CI/CD?

---

### **Q112: How do you mock and stub APIs using WireMock? Explain request matching, response stubbing, verification, and fault injection.**

**Difficulty**: Hard
**Experience Level**: 6-8, 9-12 years
**Companies**: Amazon, Google, Microsoft, Uber, Flipkart, Adobe, Oracle, all Service companies
**Topics**: API Mocking, WireMock, Stubbing, Test Doubles, Fault Injection, Service Virtualization

**Answer**:

API mocking and stubbing are essential testing techniques that allow you to test your code in isolation without depending on external services. WireMock is a powerful library for mocking HTTP-based APIs, enabling you to simulate various scenarios including success, failures, delays, and complex response patterns.

**Key WireMock Concepts**:

1. **Stubbing**
   - Define request-response mappings
   - Match incoming requests
   - Return configured responses

2. **Request Matching**
   - URL patterns (exact, regex, path templates)
   - HTTP methods
   - Headers, query parameters
   - Request body

3. **Response Configuration**
   - Status codes
   - Headers
   - Body (static, dynamic, templated)
   - Delays

4. **Verification**
   - Verify requests were made
   - Count matching requests
   - Validate request details

**Complete Implementation**:

```java
// ============================================
// 1. WireMock Configuration
// ============================================

import com.github.tomakehurst.wiremock.WireMockServer;
import com.github.tomakehurst.wiremock.core.WireMockConfiguration;
import com.github.tomakehurst.wiremock.extension.responsetemplating.ResponseTemplateTransformer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class WireMockConfig {
    private static final Logger logger = LoggerFactory.getLogger(WireMockConfig.class);
    private static WireMockServer wireMockServer;

    public static WireMockServer startServer() {
        return startServer(8080);
    }

    public static WireMockServer startServer(int port) {
        if (wireMockServer == null || !wireMockServer.isRunning()) {
            wireMockServer = new WireMockServer(
                WireMockConfiguration.options()
                    .port(port)
                    .extensions(new ResponseTemplateTransformer(false))
                    .enableBrowserProxying(true)
                    .stubRequestLoggingDisabled(false)
            );
            wireMockServer.start();
            logger.info("WireMock server started on port: {}", port);
        }
        return wireMockServer;
    }

    public static void stopServer() {
        if (wireMockServer != null && wireMockServer.isRunning()) {
            wireMockServer.stop();
            logger.info("WireMock server stopped");
        }
    }

    public static void resetServer() {
        if (wireMockServer != null) {
            wireMockServer.resetAll();
            logger.info("WireMock server reset");
        }
    }

    public static WireMockServer getServer() {
        return wireMockServer;
    }

    public static String getBaseUrl() {
        return "http://localhost:" + wireMockServer.port();
    }
}

// ============================================
// 2. WireMock Stub Builder
// ============================================

import com.github.tomakehurst.wiremock.client.WireMock;
import com.github.tomakehurst.wiremock.matching.StringValuePattern;
import static com.github.tomakehurst.wiremock.client.WireMock.*;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.util.HashMap;
import java.util.Map;

public class WireMockStubBuilder {
    private static final ObjectMapper objectMapper = new ObjectMapper();

    public static void stubGetRequest(String url, int statusCode, String responseBody) {
        stubFor(get(urlEqualTo(url))
            .willReturn(aResponse()
                .withStatus(statusCode)
                .withHeader("Content-Type", "application/json")
                .withBody(responseBody)));
    }

    public static void stubGetRequestWithHeaders(String url, Map<String, String> requestHeaders,
            int statusCode, String responseBody, Map<String, String> responseHeaders) {

        var mappingBuilder = get(urlEqualTo(url));

        // Add request header matching
        requestHeaders.forEach((key, value) -> {
            mappingBuilder.withHeader(key, equalTo(value));
        });

        // Build response
        var responseBuilder = aResponse()
            .withStatus(statusCode)
            .withBody(responseBody);

        // Add response headers
        responseHeaders.forEach(responseBuilder::withHeader);

        stubFor(mappingBuilder.willReturn(responseBuilder));
    }

    public static void stubPostRequest(String url, String requestBody, int statusCode,
            String responseBody) {

        stubFor(post(urlEqualTo(url))
            .withRequestBody(equalToJson(requestBody))
            .willReturn(aResponse()
                .withStatus(statusCode)
                .withHeader("Content-Type", "application/json")
                .withBody(responseBody)));
    }

    public static void stubPutRequest(String url, String requestBody, int statusCode,
            String responseBody) {

        stubFor(put(urlEqualTo(url))
            .withRequestBody(equalToJson(requestBody))
            .willReturn(aResponse()
                .withStatus(statusCode)
                .withHeader("Content-Type", "application/json")
                .withBody(responseBody)));
    }

    public static void stubDeleteRequest(String url, int statusCode) {
        stubFor(delete(urlEqualTo(url))
            .willReturn(aResponse()
                .withStatus(statusCode)));
    }

    public static void stubWithDelay(String url, int statusCode, String responseBody,
            int delayMs) {

        stubFor(get(urlEqualTo(url))
            .willReturn(aResponse()
                .withStatus(statusCode)
                .withHeader("Content-Type", "application/json")
                .withBody(responseBody)
                .withFixedDelay(delayMs)));
    }

    public static void stubWithRegexUrl(String urlPattern, int statusCode, String responseBody) {
        stubFor(get(urlMatching(urlPattern))
            .willReturn(aResponse()
                .withStatus(statusCode)
                .withHeader("Content-Type", "application/json")
                .withBody(responseBody)));
    }

    public static void stubWithQueryParams(String url, Map<String, String> queryParams,
            int statusCode, String responseBody) {

        var mappingBuilder = get(urlPathEqualTo(url));

        queryParams.forEach((key, value) -> {
            mappingBuilder.withQueryParam(key, equalTo(value));
        });

        stubFor(mappingBuilder.willReturn(aResponse()
            .withStatus(statusCode)
            .withHeader("Content-Type", "application/json")
            .withBody(responseBody)));
    }

    public static <T> String toJson(T object) {
        try {
            return objectMapper.writeValueAsString(object);
        } catch (Exception e) {
            throw new RuntimeException("Error converting object to JSON", e);
        }
    }
}

// ============================================
// 3. Advanced WireMock Stubs
// ============================================

import com.github.tomakehurst.wiremock.client.ResponseDefinitionBuilder;
import com.github.tomakehurst.wiremock.extension.Parameters;
import com.github.tomakehurst.wiremock.http.Fault;
import static com.github.tomakehurst.wiremock.client.WireMock.*;

public class AdvancedWireMockStubs {

    // Stub with dynamic response templating
    public static void stubWithResponseTemplate(String url) {
        stubFor(get(urlPathMatching(url))
            .willReturn(aResponse()
                .withStatus(200)
                .withHeader("Content-Type", "application/json")
                .withBody("{\"requestUrl\": \"{{request.url}}\", " +
                         "\"method\": \"{{request.method}}\", " +
                         "\"timestamp\": \"{{now}}\"}")
                .withTransformers("response-template")));
    }

    // Stub with conditional response based on request
    public static void stubConditionalResponse(String url, String headerName,
            String headerValue, String responseIfMatch, String responseIfNotMatch) {

        // Stub for matching header
        stubFor(get(urlEqualTo(url))
            .withHeader(headerName, equalTo(headerValue))
            .willReturn(aResponse()
                .withStatus(200)
                .withBody(responseIfMatch)));

        // Stub for non-matching header (lower priority)
        stubFor(get(urlEqualTo(url))
            .atPriority(5) // Higher number = lower priority
            .willReturn(aResponse()
                .withStatus(200)
                .withBody(responseIfNotMatch)));
    }

    // Stub with fault injection (network errors)
    public static void stubWithConnectionReset(String url) {
        stubFor(get(urlEqualTo(url))
            .willReturn(aResponse()
                .withFault(Fault.CONNECTION_RESET_BY_PEER)));
    }

    public static void stubWithEmptyResponse(String url) {
        stubFor(get(urlEqualTo(url))
            .willReturn(aResponse()
                .withFault(Fault.EMPTY_RESPONSE)));
    }

    public static void stubWithMalformedResponse(String url) {
        stubFor(get(urlEqualTo(url))
            .willReturn(aResponse()
                .withFault(Fault.MALFORMED_RESPONSE_CHUNK)));
    }

    // Stub with random delays
    public static void stubWithRandomDelay(String url, int minDelayMs, int maxDelayMs) {
        stubFor(get(urlEqualTo(url))
            .willReturn(aResponse()
                .withStatus(200)
                .withBody("{\"status\": \"success\"}")
                .withRandomDelay(new com.github.tomakehurst.wiremock.http.DelayDistribution() {
                    @Override
                    public long sampleMillis() {
                        return minDelayMs + (long)(Math.random() * (maxDelayMs - minDelayMs));
                    }
                })));
    }

    // Stub with scenario (stateful behavior)
    public static void stubStatefulScenario() {
        // Initial state - not logged in
        stubFor(get(urlEqualTo("/api/profile"))
            .inScenario("Login Flow")
            .whenScenarioStateIs(com.github.tomakehurst.wiremock.stubbing.Scenario.STARTED)
            .willReturn(aResponse()
                .withStatus(401)
                .withBody("{\"error\": \"Unauthorized\"}")));

        // Login request - transitions to logged in state
        stubFor(post(urlEqualTo("/api/login"))
            .inScenario("Login Flow")
            .whenScenarioStateIs(com.github.tomakehurst.wiremock.stubbing.Scenario.STARTED)
            .willReturn(aResponse()
                .withStatus(200)
                .withBody("{\"token\": \"abc123\"}"))
            .willSetStateTo("Logged In"));

        // Subsequent profile request - returns data when logged in
        stubFor(get(urlEqualTo("/api/profile"))
            .inScenario("Login Flow")
            .whenScenarioStateIs("Logged In")
            .willReturn(aResponse()
                .withStatus(200)
                .withBody("{\"name\": \"John Doe\", \"email\": \"john@example.com\"}")));
    }

    // Stub with request body pattern matching
    public static void stubWithJsonPathMatching(String url, String jsonPath, String expectedValue) {
        stubFor(post(urlEqualTo(url))
            .withRequestBody(matchingJsonPath(jsonPath, equalTo(expectedValue)))
            .willReturn(aResponse()
                .withStatus(200)
                .withBody("{\"status\": \"matched\"}")));
    }

    // Stub with partial JSON matching
    public static void stubWithPartialJsonMatch(String url, String partialJson) {
        stubFor(post(urlEqualTo(url))
            .withRequestBody(equalToJson(partialJson, true, true)) // ignore extra elements and array order
            .willReturn(aResponse()
                .withStatus(200)
                .withBody("{\"status\": \"created\"}")));
    }

    // Stub with basic authentication
    public static void stubWithBasicAuth(String url, String username, String password) {
        stubFor(get(urlEqualTo(url))
            .withBasicAuth(username, password)
            .willReturn(aResponse()
                .withStatus(200)
                .withBody("{\"authenticated\": true}")));

        // Unauthorized response for invalid credentials
        stubFor(get(urlEqualTo(url))
            .atPriority(5)
            .willReturn(aResponse()
                .withStatus(401)
                .withBody("{\"error\": \"Unauthorized\"}")));
    }

    // Stub with chunked dribble delay (simulate slow response)
    public static void stubWithChunkedDribbleDelay(String url) {
        stubFor(get(urlEqualTo(url))
            .willReturn(aResponse()
                .withStatus(200)
                .withBody("{\"large\": \"response data\"}")
                .withChunkedDribbleDelay(5, 1000))); // 5 chunks, 1 second between chunks
    }
}

// ============================================
// 4. WireMock Verification Helper
// ============================================

import com.github.tomakehurst.wiremock.client.VerificationException;
import com.github.tomakehurst.wiremock.verification.LoggedRequest;
import static com.github.tomakehurst.wiremock.client.WireMock.*;
import java.util.List;

public class WireMockVerificationHelper {
    private static final Logger logger = LoggerFactory.getLogger(WireMockVerificationHelper.class);

    public static void verifyGetRequestMade(String url) {
        verify(getRequestedFor(urlEqualTo(url)));
        logger.info("Verified GET request to: {}", url);
    }

    public static void verifyGetRequestMadeTimes(String url, int count) {
        verify(count, getRequestedFor(urlEqualTo(url)));
        logger.info("Verified GET request to {} was made {} times", url, count);
    }

    public static void verifyPostRequestWithBody(String url, String requestBody) {
        verify(postRequestedFor(urlEqualTo(url))
            .withRequestBody(equalToJson(requestBody)));
        logger.info("Verified POST request to: {}", url);
    }

    public static void verifyRequestWithHeader(String url, String headerName, String headerValue) {
        verify(getRequestedFor(urlEqualTo(url))
            .withHeader(headerName, equalTo(headerValue)));
        logger.info("Verified request to {} with header {}:{}", url, headerName, headerValue);
    }

    public static void verifyNoRequestMade(String url) {
        verify(0, getRequestedFor(urlEqualTo(url)));
        logger.info("Verified NO request made to: {}", url);
    }

    public static List<LoggedRequest> getAllRequests() {
        return findAll(anyRequestedFor(anyUrl()));
    }

    public static List<LoggedRequest> getRequestsForUrl(String url) {
        return findAll(getRequestedFor(urlEqualTo(url)));
    }

    public static void printAllRequests() {
        List<LoggedRequest> requests = getAllRequests();
        logger.info("=== All Requests ===");
        requests.forEach(request -> {
            logger.info("Method: {}, URL: {}", request.getMethod(), request.getUrl());
            logger.info("Headers: {}", request.getHeaders());
            logger.info("Body: {}", request.getBodyAsString());
            logger.info("---");
        });
    }

    public static int getRequestCount(String url) {
        return findAll(getRequestedFor(urlEqualTo(url))).size();
    }
}

// ============================================
// 5. WireMock Test Examples
// ============================================

import io.restassured.RestAssured;
import io.restassured.response.Response;
import org.testng.annotations.AfterClass;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.Test;
import static io.restassured.RestAssured.given;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.*;
import java.util.HashMap;
import java.util.Map;

public class WireMockAPITest {
    private WireMockServer wireMockServer;

    @BeforeClass
    public void setup() {
        wireMockServer = WireMockConfig.startServer(8080);
        RestAssured.baseURI = WireMockConfig.getBaseUrl();
    }

    @AfterMethod
    public void resetStubs() {
        WireMockConfig.resetServer();
    }

    @AfterClass
    public void tearDown() {
        WireMockConfig.stopServer();
    }

    @Test(description = "Test basic GET request stubbing")
    public void testBasicGetStub() {
        // Setup stub
        String responseBody = "{\"id\": 1, \"name\": \"John Doe\"}";
        WireMockStubBuilder.stubGetRequest("/api/users/1", 200, responseBody);

        // Make request
        Response response = given()
            .when().get("/api/users/1")
            .then().extract().response();

        // Assertions
        assertThat(response.getStatusCode(), equalTo(200));
        assertThat(response.jsonPath().getInt("id"), equalTo(1));
        assertThat(response.jsonPath().getString("name"), equalTo("John Doe"));

        // Verify request was made
        WireMockVerificationHelper.verifyGetRequestMade("/api/users/1");
    }

    @Test(description = "Test POST request with request body matching")
    public void testPostRequestStub() {
        // Setup stub
        String requestBody = "{\"name\": \"Jane Doe\", \"email\": \"jane@example.com\"}";
        String responseBody = "{\"id\": 2, \"name\": \"Jane Doe\", \"email\": \"jane@example.com\"}";

        WireMockStubBuilder.stubPostRequest("/api/users", requestBody, 201, responseBody);

        // Make request
        Response response = given()
            .contentType("application/json")
            .body(requestBody)
            .when().post("/api/users")
            .then().extract().response();

        // Assertions
        assertThat(response.getStatusCode(), equalTo(201));
        assertThat(response.jsonPath().getInt("id"), equalTo(2));

        // Verify
        WireMockVerificationHelper.verifyPostRequestWithBody("/api/users", requestBody);
    }

    @Test(description = "Test stub with delay")
    public void testStubWithDelay() {
        // Setup stub with 2 second delay
        WireMockStubBuilder.stubWithDelay("/api/slow", 200, "{\"status\": \"slow\"}", 2000);

        // Measure response time
        long startTime = System.currentTimeMillis();

        Response response = given()
            .when().get("/api/slow")
            .then().extract().response();

        long endTime = System.currentTimeMillis();
        long duration = endTime - startTime;

        // Assertions
        assertThat(response.getStatusCode(), equalTo(200));
        assertThat(duration, greaterThanOrEqualTo(2000L));
        logger.info("Response time: {} ms", duration);
    }

    @Test(description = "Test stub with query parameters")
    public void testStubWithQueryParams() {
        // Setup stub
        Map<String, String> queryParams = new HashMap<>();
        queryParams.put("page", "1");
        queryParams.put("limit", "10");

        String responseBody = "{\"users\": [], \"page\": 1, \"limit\": 10}";
        WireMockStubBuilder.stubWithQueryParams("/api/users", queryParams, 200, responseBody);

        // Make request
        Response response = given()
            .queryParam("page", "1")
            .queryParam("limit", "10")
            .when().get("/api/users")
            .then().extract().response();

        // Assertions
        assertThat(response.getStatusCode(), equalTo(200));
        assertThat(response.jsonPath().getInt("page"), equalTo(1));
    }

    @Test(description = "Test stub with headers")
    public void testStubWithHeaders() {
        // Setup stub
        Map<String, String> requestHeaders = Map.of("Authorization", "Bearer token123");
        Map<String, String> responseHeaders = Map.of("X-Custom-Header", "custom-value");

        WireMockStubBuilder.stubGetRequestWithHeaders("/api/profile", requestHeaders,
            200, "{\"name\": \"John\"}", responseHeaders);

        // Make request
        Response response = given()
            .header("Authorization", "Bearer token123")
            .when().get("/api/profile")
            .then().extract().response();

        // Assertions
        assertThat(response.getStatusCode(), equalTo(200));
        assertThat(response.getHeader("X-Custom-Header"), equalTo("custom-value"));
    }

    @Test(description = "Test fault injection - connection reset")
    public void testConnectionResetFault() {
        // Setup stub with connection reset
        AdvancedWireMockStubs.stubWithConnectionReset("/api/faulty");

        // Expect exception when making request
        try {
            given().when().get("/api/faulty").then().extract().response();
        } catch (Exception e) {
            logger.info("Expected exception caught: {}", e.getClass().getSimpleName());
            assertThat(e, notNullValue());
        }
    }

    @Test(description = "Test stateful scenario")
    public void testStatefulScenario() {
        // Setup stateful stubs
        AdvancedWireMockStubs.stubStatefulScenario();

        // 1. Try to access profile without login - should fail
        Response profileResponse1 = given()
            .when().get("/api/profile")
            .then().extract().response();

        assertThat(profileResponse1.getStatusCode(), equalTo(401));

        // 2. Login
        Response loginResponse = given()
            .contentType("application/json")
            .body("{\"username\": \"john\", \"password\": \"pass123\"}")
            .when().post("/api/login")
            .then().extract().response();

        assertThat(loginResponse.getStatusCode(), equalTo(200));

        // 3. Access profile after login - should succeed
        Response profileResponse2 = given()
            .when().get("/api/profile")
            .then().extract().response();

        assertThat(profileResponse2.getStatusCode(), equalTo(200));
        assertThat(profileResponse2.jsonPath().getString("name"), equalTo("John Doe"));
    }

    @Test(description = "Test request verification")
    public void testRequestVerification() {
        // Setup stub
        WireMockStubBuilder.stubGetRequest("/api/products", 200, "{\"products\": []}");

        // Make multiple requests
        given().when().get("/api/products");
        given().when().get("/api/products");
        given().when().get("/api/products");

        // Verify request count
        WireMockVerificationHelper.verifyGetRequestMadeTimes("/api/products", 3);

        int count = WireMockVerificationHelper.getRequestCount("/api/products");
        assertThat(count, equalTo(3));
    }

    @Test(description = "Test regex URL matching")
    public void testRegexUrlMatching() {
        // Stub with regex pattern - match /api/users/any-number
        WireMockStubBuilder.stubWithRegexUrl("/api/users/[0-9]+", 200,
            "{\"id\": 1, \"name\": \"User\"}");

        // Test with different user IDs
        Response response1 = given().when().get("/api/users/123").then().extract().response();
        Response response2 = given().when().get("/api/users/456").then().extract().response();

        assertThat(response1.getStatusCode(), equalTo(200));
        assertThat(response2.getStatusCode(), equalTo(200));
    }

    @Test(description = "Test JSON path matching")
    public void testJsonPathMatching() {
        // Stub that matches only when request body contains specific JSON path
        AdvancedWireMockStubs.stubWithJsonPathMatching("/api/orders",
            "$.userId", "12345");

        // Request with matching userId
        String requestBody = "{\"userId\": \"12345\", \"product\": \"laptop\"}";

        Response response = given()
            .contentType("application/json")
            .body(requestBody)
            .when().post("/api/orders")
            .then().extract().response();

        assertThat(response.getStatusCode(), equalTo(200));
        assertThat(response.jsonPath().getString("status"), equalTo("matched"));
    }
}

// ============================================
// 6. WireMock Integration Helper
// ============================================

public class WireMockIntegrationHelper {

    public static void stubExternalAPISuccess(String externalApiUrl, String endpoint) {
        String responseBody = "{\"success\": true, \"data\": {\"message\": \"Mocked response\"}}";
        WireMockStubBuilder.stubGetRequest(endpoint, 200, responseBody);
    }

    public static void stubExternalAPIFailure(String endpoint, int statusCode, String errorMessage) {
        String responseBody = String.format("{\"success\": false, \"error\": \"%s\"}", errorMessage);
        WireMockStubBuilder.stubGetRequest(endpoint, statusCode, responseBody);
    }

    public static void stubPaymentGateway(String endpoint, boolean success) {
        if (success) {
            WireMockStubBuilder.stubPostRequest(endpoint,
                "{\"amount\": 100, \"currency\": \"USD\"}",
                200,
                "{\"transactionId\": \"txn123\", \"status\": \"success\"}");
        } else {
            WireMockStubBuilder.stubPostRequest(endpoint,
                "{\"amount\": 100, \"currency\": \"USD\"}",
                400,
                "{\"error\": \"Payment failed\", \"code\": \"INSUFFICIENT_FUNDS\"}");
        }
    }

    public static void stubThirdPartyAPI(String baseUrl, String endpoint, String responseFile) {
        // Load response from file (useful for complex responses)
        try {
            String responseBody = new String(
                java.nio.file.Files.readAllBytes(
                    java.nio.file.Paths.get("src/test/resources/mocks/" + responseFile)
                )
            );
            WireMockStubBuilder.stubGetRequest(endpoint, 200, responseBody);
        } catch (Exception e) {
            throw new RuntimeException("Error loading mock response file", e);
        }
    }
}
```

**Best Practices**:

1. **Isolation**: Use WireMock to test in isolation from external dependencies
2. **Reset**: Always reset stubs between tests to avoid interference
3. **Verification**: Verify that expected requests were made
4. **Realistic Responses**: Use realistic response data and status codes
5. **Error Scenarios**: Test both success and failure scenarios
6. **Delays**: Simulate network delays to test timeout handling
7. **Stateful Testing**: Use scenarios for testing stateful workflows
8. **CI/CD**: WireMock enables testing without external dependencies in CI
9. **Documentation**: Document mock behavior for team understanding
10. **Versioning**: Version your mock stubs along with tests

**WireMock vs Real API Testing**:

| Aspect | WireMock (Mocking) | Real API |
|--------|-------------------|----------|
| **Speed** | Very fast | Slower (network, processing) |
| **Reliability** | Always available | May have downtime |
| **Control** | Full control over responses | Limited control |
| **Cost** | Free | May have API call costs |
| **Realistic** | Simulated behavior | Actual behavior |
| **Use Case** | Unit/Integration tests | E2E tests |
| **Network Issues** | Can simulate | Real issues only |
| **Dependencies** | None | Requires external service |

**Follow-up**: How do you handle complex response transformations in WireMock? How do you organize WireMock stubs for large test suites? How do you integrate WireMock with Docker for containerized testing? How do you version and share WireMock stubs across teams?

---

### **Q113: How do you test asynchronous APIs? Explain polling, callbacks, webhooks, and testing long-running operations.**

**Difficulty**: Hard
**Experience Level**: 6-8, 9-12 years
**Companies**: Amazon, Google, Microsoft, Uber, Flipkart, Swiggy, Adobe, Netflix
**Topics**: Async API Testing, Polling, Callbacks, Webhooks, Long-running Operations, CompletableFuture

**Answer**:

Asynchronous API testing involves testing APIs that don't return immediate responses. These APIs typically return a job/task ID and the client must poll for status, wait for a callback/webhook, or subscribe to events. Common use cases include file processing, report generation, batch operations, and data imports.

**Key Async API Patterns**:

1. **Polling Pattern**
   - Client repeatedly checks status
   - API returns job ID immediately
   - Client polls until completion

2. **Callback/Webhook Pattern**
   - API calls client's endpoint when done
   - Requires client server to receive callbacks
   - Event-driven approach

3. **Long Polling**
   - Client sends request and waits
   - Server holds connection until data available
   - Reduces polling overhead

4. **Server-Sent Events (SSE)**
   - Server pushes updates to client
   - One-way communication
   - HTTP-based streaming

**Complete Implementation**:

```java
// ============================================
// 1. Async API Models
// ============================================

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

@Data
public class AsyncJobResponse {
    private String jobId;
    private String status; // PENDING, PROCESSING, COMPLETED, FAILED
    private String message;
    private Integer progress; // 0-100
    private String resultUrl;
    private Long createdAt;
    private Long completedAt;

    public boolean isCompleted() {
        return "COMPLETED".equalsIgnoreCase(status);
    }

    public boolean isFailed() {
        return "FAILED".equalsIgnoreCase(status);
    }

    public boolean isInProgress() {
        return "PENDING".equalsIgnoreCase(status) || "PROCESSING".equalsIgnoreCase(status);
    }
}

@Data
public class JobSubmitRequest {
    private String type;
    private Map<String, Object> parameters;
    private String callbackUrl;
}

@Data
public class WebhookPayload {
    private String jobId;
    private String status;
    private Map<String, Object> result;
    private String errorMessage;
    private Long timestamp;
}

// ============================================
// 2. Async API Client with Polling
// ============================================

import io.restassured.response.Response;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import static io.restassured.RestAssured.given;
import java.time.Duration;
import java.util.concurrent.TimeUnit;
import java.util.function.Predicate;

public class AsyncAPIClient {
    private static final Logger logger = LoggerFactory.getLogger(AsyncAPIClient.class);
    private String baseUrl;
    private int defaultPollIntervalMs;
    private int defaultMaxAttempts;

    public AsyncAPIClient(String baseUrl) {
        this.baseUrl = baseUrl;
        this.defaultPollIntervalMs = 2000; // 2 seconds
        this.defaultMaxAttempts = 30; // Total 60 seconds timeout
    }

    // Submit async job
    public AsyncJobResponse submitJob(String endpoint, JobSubmitRequest request) {
        logger.info("Submitting async job to: {}", endpoint);

        Response response = given()
            .baseUri(baseUrl)
            .contentType("application/json")
            .body(request)
        .when()
            .post(endpoint)
        .then()
            .statusCode(202) // Accepted
            .extract().response();

        AsyncJobResponse jobResponse = response.as(AsyncJobResponse.class);
        logger.info("Job submitted successfully. Job ID: {}", jobResponse.getJobId());

        return jobResponse;
    }

    // Poll for job completion
    public AsyncJobResponse pollUntilComplete(String jobId) {
        return pollUntilComplete(jobId, defaultPollIntervalMs, defaultMaxAttempts);
    }

    public AsyncJobResponse pollUntilComplete(String jobId, int pollIntervalMs, int maxAttempts) {
        logger.info("Starting to poll for job: {}", jobId);

        for (int attempt = 1; attempt <= maxAttempts; attempt++) {
            logger.info("Poll attempt {}/{} for job: {}", attempt, maxAttempts, jobId);

            AsyncJobResponse status = getJobStatus(jobId);

            if (status.isCompleted()) {
                logger.info("Job completed successfully: {}", jobId);
                return status;
            }

            if (status.isFailed()) {
                logger.error("Job failed: {}. Message: {}", jobId, status.getMessage());
                throw new RuntimeException("Job failed: " + status.getMessage());
            }

            logger.info("Job {} status: {}, progress: {}%",
                jobId, status.getStatus(), status.getProgress());

            if (attempt < maxAttempts) {
                sleep(pollIntervalMs);
            }
        }

        throw new RuntimeException("Job timeout: " + jobId + " after " + maxAttempts + " attempts");
    }

    // Poll with custom condition
    public AsyncJobResponse pollUntilCondition(String jobId,
            Predicate<AsyncJobResponse> condition, int pollIntervalMs, int maxAttempts) {

        for (int attempt = 1; attempt <= maxAttempts; attempt++) {
            AsyncJobResponse status = getJobStatus(jobId);

            if (condition.test(status)) {
                logger.info("Condition met for job: {}", jobId);
                return status;
            }

            if (attempt < maxAttempts) {
                sleep(pollIntervalMs);
            }
        }

        throw new RuntimeException("Condition not met for job: " + jobId);
    }

    // Get job status
    public AsyncJobResponse getJobStatus(String jobId) {
        Response response = given()
            .baseUri(baseUrl)
        .when()
            .get("/jobs/" + jobId)
        .then()
            .statusCode(200)
            .extract().response();

        return response.as(AsyncJobResponse.class);
    }

    // Get job result
    public Response getJobResult(String jobId) {
        AsyncJobResponse status = pollUntilComplete(jobId);

        if (status.getResultUrl() != null) {
            return given()
                .baseUri(baseUrl)
            .when()
                .get(status.getResultUrl())
            .then()
                .statusCode(200)
                .extract().response();
        }

        throw new RuntimeException("No result URL available for job: " + jobId);
    }

    private void sleep(int milliseconds) {
        try {
            Thread.sleep(milliseconds);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException("Polling interrupted", e);
        }
    }
}

// ============================================
// 3. Async API Client with CompletableFuture
// ============================================

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeoutException;

public class AsyncAPIClientWithFuture {
    private static final Logger logger = LoggerFactory.getLogger(AsyncAPIClientWithFuture.class);
    private AsyncAPIClient asyncClient;
    private ExecutorService executorService;

    public AsyncAPIClientWithFuture(String baseUrl) {
        this.asyncClient = new AsyncAPIClient(baseUrl);
        this.executorService = Executors.newFixedThreadPool(10);
    }

    // Submit and wait asynchronously
    public CompletableFuture<AsyncJobResponse> submitAndWaitAsync(String endpoint,
            JobSubmitRequest request) {

        return CompletableFuture.supplyAsync(() -> {
            AsyncJobResponse jobResponse = asyncClient.submitJob(endpoint, request);
            return asyncClient.pollUntilComplete(jobResponse.getJobId());
        }, executorService);
    }

    // Submit multiple jobs in parallel
    public CompletableFuture<List<AsyncJobResponse>> submitMultipleJobs(String endpoint,
            List<JobSubmitRequest> requests) {

        List<CompletableFuture<AsyncJobResponse>> futures = requests.stream()
            .map(request -> submitAndWaitAsync(endpoint, request))
            .collect(java.util.stream.Collectors.toList());

        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .thenApply(v -> futures.stream()
                .map(CompletableFuture::join)
                .collect(java.util.stream.Collectors.toList()));
    }

    // Wait for any job to complete
    public CompletableFuture<AsyncJobResponse> waitForAnyCompletion(List<String> jobIds) {
        List<CompletableFuture<AsyncJobResponse>> futures = jobIds.stream()
            .map(jobId -> CompletableFuture.supplyAsync(() ->
                asyncClient.pollUntilComplete(jobId), executorService))
            .collect(java.util.stream.Collectors.toList());

        return CompletableFuture.anyOf(futures.toArray(new CompletableFuture[0]))
            .thenApply(result -> (AsyncJobResponse) result);
    }

    // Wait with timeout
    public AsyncJobResponse submitAndWaitWithTimeout(String endpoint, JobSubmitRequest request,
            long timeout, TimeUnit unit) throws TimeoutException {

        try {
            return submitAndWaitAsync(endpoint, request)
                .get(timeout, unit);
        } catch (java.util.concurrent.TimeoutException e) {
            throw new TimeoutException("Job submission timeout after " + timeout + " " + unit);
        } catch (Exception e) {
            throw new RuntimeException("Error submitting job", e);
        }
    }

    public void shutdown() {
        executorService.shutdown();
    }
}

// ============================================
// 4. Webhook Server for Testing
// ============================================

import com.sun.net.httpserver.HttpServer;
import com.sun.net.httpserver.HttpHandler;
import com.sun.net.httpserver.HttpExchange;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.io.IOException;
import java.io.OutputStream;
import java.net.InetSocketAddress;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

public class WebhookTestServer {
    private static final Logger logger = LoggerFactory.getLogger(WebhookTestServer.class);
    private static final ObjectMapper objectMapper = new ObjectMapper();

    private HttpServer server;
    private BlockingQueue<WebhookPayload> receivedWebhooks;
    private int port;

    public WebhookTestServer(int port) {
        this.port = port;
        this.receivedWebhooks = new LinkedBlockingQueue<>();
    }

    public void start() throws IOException {
        server = HttpServer.create(new InetSocketAddress(port), 0);

        server.createContext("/webhook", exchange -> {
            if ("POST".equals(exchange.getRequestMethod())) {
                handleWebhook(exchange);
            } else {
                exchange.sendResponseHeaders(405, -1); // Method Not Allowed
            }
        });

        server.setExecutor(null);
        server.start();
        logger.info("Webhook server started on port: {}", port);
    }

    private void handleWebhook(HttpExchange exchange) throws IOException {
        try {
            // Read request body
            String requestBody = new String(exchange.getRequestBody().readAllBytes());
            logger.info("Received webhook: {}", requestBody);

            // Parse webhook payload
            WebhookPayload payload = objectMapper.readValue(requestBody, WebhookPayload.class);
            receivedWebhooks.offer(payload);

            // Send response
            String response = "{\"status\": \"received\"}";
            exchange.getResponseHeaders().set("Content-Type", "application/json");
            exchange.sendResponseHeaders(200, response.length());

            OutputStream os = exchange.getResponseBody();
            os.write(response.getBytes());
            os.close();

        } catch (Exception e) {
            logger.error("Error handling webhook", e);
            exchange.sendResponseHeaders(500, -1);
        }
    }

    public WebhookPayload waitForWebhook(long timeout, TimeUnit unit) throws InterruptedException {
        WebhookPayload payload = receivedWebhooks.poll(timeout, unit);
        if (payload == null) {
            throw new RuntimeException("Timeout waiting for webhook");
        }
        return payload;
    }

    public WebhookPayload waitForWebhookWithJobId(String jobId, long timeout, TimeUnit unit)
            throws InterruptedException {

        long endTime = System.currentTimeMillis() + unit.toMillis(timeout);

        while (System.currentTimeMillis() < endTime) {
            WebhookPayload payload = receivedWebhooks.poll(1, TimeUnit.SECONDS);
            if (payload != null && jobId.equals(payload.getJobId())) {
                return payload;
            }
        }

        throw new RuntimeException("Timeout waiting for webhook for job: " + jobId);
    }

    public List<WebhookPayload> getAllReceivedWebhooks() {
        return new ArrayList<>(receivedWebhooks);
    }

    public void clearWebhooks() {
        receivedWebhooks.clear();
    }

    public void stop() {
        if (server != null) {
            server.stop(0);
            logger.info("Webhook server stopped");
        }
    }

    public String getWebhookUrl() {
        return "http://localhost:" + port + "/webhook";
    }
}

// ============================================
// 5. Async API Test Helper
// ============================================

import java.util.HashMap;
import java.util.Map;

public class AsyncAPITestHelper {
    private static final Logger logger = LoggerFactory.getLogger(AsyncAPITestHelper.class);

    // Submit job and wait for completion
    public static AsyncJobResponse submitAndWait(AsyncAPIClient client, String endpoint,
            String jobType, Map<String, Object> parameters) {

        JobSubmitRequest request = new JobSubmitRequest();
        request.setType(jobType);
        request.setParameters(parameters);

        AsyncJobResponse submitResponse = client.submitJob(endpoint, request);
        return client.pollUntilComplete(submitResponse.getJobId());
    }

    // Submit with webhook callback
    public static AsyncJobResponse submitWithWebhook(AsyncAPIClient client, String endpoint,
            String jobType, Map<String, Object> parameters, String webhookUrl) {

        JobSubmitRequest request = new JobSubmitRequest();
        request.setType(jobType);
        request.setParameters(parameters);
        request.setCallbackUrl(webhookUrl);

        return client.submitJob(endpoint, request);
    }

    // Verify job completed within time
    public static void verifyCompletionTime(AsyncJobResponse response, long maxDurationMs) {
        long duration = response.getCompletedAt() - response.getCreatedAt();

        if (duration > maxDurationMs) {
            throw new AssertionError(
                String.format("Job took %d ms, expected max %d ms", duration, maxDurationMs)
            );
        }

        logger.info("Job completed in {} ms (max: {} ms)", duration, maxDurationMs);
    }

    // Build job parameters
    public static Map<String, Object> buildJobParameters(Object... keyValues) {
        Map<String, Object> params = new HashMap<>();
        for (int i = 0; i < keyValues.length; i += 2) {
            params.put((String) keyValues[i], keyValues[i + 1]);
        }
        return params;
    }
}

// ============================================
// 6. Async API Test Examples
// ============================================

import org.testng.annotations.*;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;

public class AsyncAPITest {
    private static final String BASE_URL = "https://api.example.com";
    private AsyncAPIClient asyncClient;
    private AsyncAPIClientWithFuture asyncFutureClient;
    private WebhookTestServer webhookServer;

    @BeforeClass
    public void setup() throws Exception {
        asyncClient = new AsyncAPIClient(BASE_URL);
        asyncFutureClient = new AsyncAPIClientWithFuture(BASE_URL);

        // Start webhook server on port 9090
        webhookServer = new WebhookTestServer(9090);
        webhookServer.start();
    }

    @AfterClass
    public void tearDown() {
        asyncFutureClient.shutdown();
        webhookServer.stop();
    }

    @AfterMethod
    public void clearWebhooks() {
        webhookServer.clearWebhooks();
    }

    @Test(description = "Test basic async job with polling")
    public void testAsyncJobWithPolling() {
        // Submit job
        Map<String, Object> params = AsyncAPITestHelper.buildJobParameters(
            "inputFile", "data.csv",
            "format", "json"
        );

        AsyncJobResponse result = AsyncAPITestHelper.submitAndWait(
            asyncClient, "/api/jobs/process", "DATA_PROCESSING", params
        );

        // Assertions
        assertThat(result.getStatus(), equalTo("COMPLETED"));
        assertThat(result.getJobId(), notNullValue());
        assertThat(result.getResultUrl(), notNullValue());

        logger.info("Job completed with result URL: {}", result.getResultUrl());
    }

    @Test(description = "Test async job with webhook callback")
    public void testAsyncJobWithWebhook() throws Exception {
        // Submit job with webhook URL
        Map<String, Object> params = AsyncAPITestHelper.buildJobParameters(
            "reportType", "monthly",
            "format", "pdf"
        );

        AsyncJobResponse submitResponse = AsyncAPITestHelper.submitWithWebhook(
            asyncClient, "/api/jobs/generate-report", "REPORT_GENERATION",
            params, webhookServer.getWebhookUrl()
        );

        logger.info("Job submitted: {}", submitResponse.getJobId());

        // Wait for webhook callback
        WebhookPayload webhook = webhookServer.waitForWebhookWithJobId(
            submitResponse.getJobId(), 60, TimeUnit.SECONDS
        );

        // Assertions
        assertThat(webhook.getJobId(), equalTo(submitResponse.getJobId()));
        assertThat(webhook.getStatus(), equalTo("COMPLETED"));
        assertThat(webhook.getResult(), notNullValue());

        logger.info("Webhook received for job: {}", webhook.getJobId());
    }

    @Test(description = "Test async job with CompletableFuture")
    public void testAsyncJobWithFuture() throws Exception {
        // Submit job asynchronously
        JobSubmitRequest request = new JobSubmitRequest();
        request.setType("IMAGE_PROCESSING");
        request.setParameters(AsyncAPITestHelper.buildJobParameters(
            "imageUrl", "https://example.com/image.jpg",
            "operation", "resize"
        ));

        CompletableFuture<AsyncJobResponse> future =
            asyncFutureClient.submitAndWaitAsync("/api/jobs/process-image", request);

        // Wait for completion
        AsyncJobResponse result = future.get(60, TimeUnit.SECONDS);

        // Assertions
        assertThat(result.isCompleted(), is(true));
        assertThat(result.getProgress(), equalTo(100));
    }

    @Test(description = "Test multiple async jobs in parallel")
    public void testMultipleAsyncJobsInParallel() throws Exception {
        // Create multiple job requests
        List<JobSubmitRequest> requests = new ArrayList<>();
        for (int i = 1; i <= 5; i++) {
            JobSubmitRequest request = new JobSubmitRequest();
            request.setType("BATCH_PROCESSING");
            request.setParameters(AsyncAPITestHelper.buildJobParameters(
                "batchId", "batch-" + i,
                "items", 100
            ));
            requests.add(request);
        }

        // Submit all jobs in parallel
        long startTime = System.currentTimeMillis();

        CompletableFuture<List<AsyncJobResponse>> allJobsFuture =
            asyncFutureClient.submitMultipleJobs("/api/jobs/batch", requests);

        List<AsyncJobResponse> results = allJobsFuture.get(120, TimeUnit.SECONDS);

        long duration = System.currentTimeMillis() - startTime;

        // Assertions
        assertThat(results, hasSize(5));
        results.forEach(result -> {
            assertThat(result.isCompleted(), is(true));
        });

        logger.info("All 5 jobs completed in {} ms", duration);
    }

    @Test(description = "Test async job with custom polling condition")
    public void testAsyncJobWithCustomCondition() {
        // Submit job
        JobSubmitRequest request = new JobSubmitRequest();
        request.setType("LONG_RUNNING_TASK");
        request.setParameters(AsyncAPITestHelper.buildJobParameters("duration", 30));

        AsyncJobResponse submitResponse = asyncClient.submitJob("/api/jobs/task", request);

        // Poll until progress reaches 50%
        AsyncJobResponse result = asyncClient.pollUntilCondition(
            submitResponse.getJobId(),
            response -> response.getProgress() >= 50,
            1000, // 1 second interval
            60    // max 60 attempts
        );

        // Assertions
        assertThat(result.getProgress(), greaterThanOrEqualTo(50));
        logger.info("Job reached 50% progress");
    }

    @Test(description = "Test async job timeout handling")
    public void testAsyncJobTimeout() {
        // Submit job
        JobSubmitRequest request = new JobSubmitRequest();
        request.setType("SLOW_TASK");
        request.setParameters(new HashMap<>());

        AsyncJobResponse submitResponse = asyncClient.submitJob("/api/jobs/slow", request);

        // Try to poll with short timeout
        try {
            asyncClient.pollUntilComplete(
                submitResponse.getJobId(),
                1000, // 1 second interval
                3     // max 3 attempts (3 seconds total)
            );

            // Should not reach here
            throw new AssertionError("Expected timeout exception");

        } catch (RuntimeException e) {
            // Expected timeout
            assertThat(e.getMessage(), containsString("timeout"));
            logger.info("Job timeout handled correctly");
        }
    }

    @Test(description = "Test async job failure handling")
    public void testAsyncJobFailure() {
        // Submit job that will fail
        JobSubmitRequest request = new JobSubmitRequest();
        request.setType("FAILING_TASK");
        request.setParameters(AsyncAPITestHelper.buildJobParameters("failAt", 50));

        AsyncJobResponse submitResponse = asyncClient.submitJob("/api/jobs/fail", request);

        // Poll and expect failure
        try {
            asyncClient.pollUntilComplete(submitResponse.getJobId());
            throw new AssertionError("Expected job failure exception");

        } catch (RuntimeException e) {
            assertThat(e.getMessage(), containsString("Job failed"));
            logger.info("Job failure handled correctly: {}", e.getMessage());
        }
    }

    @Test(description = "Test get job result after completion")
    public void testGetJobResult() {
        // Submit job
        Map<String, Object> params = AsyncAPITestHelper.buildJobParameters(
            "query", "SELECT * FROM users",
            "format", "csv"
        );

        JobSubmitRequest request = new JobSubmitRequest();
        request.setType("DATABASE_EXPORT");
        request.setParameters(params);

        AsyncJobResponse submitResponse = asyncClient.submitJob("/api/jobs/export", request);

        // Get result
        Response resultResponse = asyncClient.getJobResult(submitResponse.getJobId());

        // Assertions
        assertThat(resultResponse.getStatusCode(), equalTo(200));
        assertThat(resultResponse.getBody().asString(), notNullValue());
        assertThat(resultResponse.getContentType(), containsString("text/csv"));

        logger.info("Retrieved job result successfully");
    }

    @Test(description = "Test wait for any job completion")
    public void testWaitForAnyJobCompletion() throws Exception {
        // Submit multiple jobs
        List<String> jobIds = new ArrayList<>();

        for (int i = 1; i <= 3; i++) {
            JobSubmitRequest request = new JobSubmitRequest();
            request.setType("VARIABLE_DURATION_TASK");
            request.setParameters(AsyncAPITestHelper.buildJobParameters(
                "duration", i * 10
            ));

            AsyncJobResponse response = asyncClient.submitJob("/api/jobs/variable", request);
            jobIds.add(response.getJobId());
        }

        // Wait for any job to complete
        CompletableFuture<AsyncJobResponse> firstCompleted =
            asyncFutureClient.waitForAnyCompletion(jobIds);

        AsyncJobResponse result = firstCompleted.get(60, TimeUnit.SECONDS);

        // Assertions
        assertThat(result.isCompleted(), is(true));
        assertThat(jobIds, hasItem(result.getJobId()));

        logger.info("First job completed: {}", result.getJobId());
    }
}
```

**Best Practices**:

1. **Polling Strategy**: Use exponential backoff for polling to reduce server load
2. **Timeouts**: Always set maximum polling attempts to prevent infinite loops
3. **Error Handling**: Handle both timeout and job failure scenarios
4. **Parallel Testing**: Use CompletableFuture for testing multiple async jobs
5. **Webhook Testing**: Set up local webhook server for callback testing
6. **Idempotency**: Ensure job submissions are idempotent
7. **Status Tracking**: Log job progress for debugging
8. **Resource Cleanup**: Always shutdown executors and servers in tearDown
9. **Realistic Delays**: Use realistic polling intervals (1-5 seconds)
10. **Monitoring**: Track job completion times and success rates

**Async API Patterns Comparison**:

| Pattern | Pros | Cons | Use Case |
|---------|------|------|----------|
| **Polling** | Simple, client-controlled | Network overhead, delay | Short-running jobs |
| **Webhook** | Real-time, efficient | Requires server, complex | Long-running jobs |
| **Long Polling** | Near real-time | Ties up connections | Chat, notifications |
| **SSE** | Server push, HTTP-based | One-way only | Live updates |
| **WebSocket** | Full-duplex, low latency | Complex setup | Real-time bidirectional |

**Follow-up**: How do you handle async API testing in CI/CD with limited time? How do you test webhook reliability and retries? How do you implement exponential backoff in polling? How do you test async APIs with message queues (Kafka, RabbitMQ)?

---

[Q141-Q165 covering all TestNG topics]

[Q166-Q205 covering framework design, patterns, architecture]

---

# ðŸ‘” LEADERSHIP & STRATEGY (20 Questions)

[Q206-Q225 covering leadership, mentoring, strategy]

---

# ðŸ”§ MAVEN & GRADLE (15 Questions)

[Q226-Q240 covering build tools]

---

# ðŸ”€ GIT & VERSION CONTROL (15 Questions)

[Q241-Q255 covering Git, branching, collaboration]

---

# ðŸš€ CI/CD (25 Questions)

[Q256-Q280 covering Jenkins, Docker, GitHub Actions]

---

# ðŸ¥’ BDD & CUCUMBER (20 Questions)

[Q281-Q300 covering BDD, Gherkin, Cucumber]

---

**Total: 300 Questions across all topics**

---

# ðŸ“… 4-WEEK STUDY PLAN FOR 8 YEARS EXPERIENCE

## Week 1: Framework Architecture & Leadership (Must Master)
**Goal**: Master all Hard questions in these categories

### Monday
- Framework Architecture Q1-10
- Practice: Whiteboard your framework architecture

### Tuesday  
- Framework Architecture Q11-20
- Practice: Explain design patterns used

### Wednesday
- Framework Architecture Q21-30
- Practice: CI/CD pipeline design

### Thursday
- Leadership & Strategy Q1-10
- Practice: Prepare STAR stories

### Friday
- Leadership & Strategy Q11-20
- Practice: Mock leadership interview

### Weekend
- Review all week's questions
- Create framework architecture diagram
- Prepare 5 STAR method stories

---

## Week 2: Advanced Selenium & API Testing
**Goal**: Master all Hard Selenium and API questions

### Monday
- Selenium Advanced Q40-50
- Practice: Parallel execution code

### Tuesday
- Selenium Framework Q51-60
- Practice: Page Object Model refactoring

### Wednesday
- API Testing Advanced Q30-40
- Practice: Contract testing implementation

### Thursday
- REST Assured Patterns Q41-50
- Practice: Request/Response specifications

### Friday
- API Performance & Security Q51-60
- Practice: Performance testing scenarios

### Weekend
- Review all Hard questions
- Build sample framework component
- Practice explaining concepts

---

## Week 3: Java, TestNG, Build Tools
**Goal**: Review fundamentals, master intermediate

### Monday
- Java Collections Q20-30
- Java Multithreading Q31-40

### Tuesday
- Java 8+ Features Q41-50
- Practice: Lambda, Streams, Optional

### Wednesday
- TestNG Advanced Q15-25
- Practice: Parallel execution, listeners

### Thursday
- Maven & Gradle Q1-15
- Practice: POM configuration

### Friday
- Git & Version Control Q1-15
- Practice: Branching strategies

### Weekend
- Review all Medium questions
- Practice coding exercises
- Mock technical interview

---

## Week 4: CI/CD, Mock Interviews, Final Prep
**Goal**: Integration topics and interview practice

### Monday
- CI/CD Jenkins Q1-15
- Practice: Pipeline creation

### Tuesday
- Docker & Containers Q16-25
- Practice: Dockerfile, docker-compose

### Wednesday
- BDD & Cucumber Q1-20
- Practice: Feature files, step definitions

### Thursday
- Full Mock Interview (Technical)
- Practice all Hard questions

### Friday
- Full Mock Interview (Leadership)
- Practice STAR stories

### Weekend
- Final review of weak areas
- Prepare questions for interviewer
- Confidence building

---

# ðŸŽ¯ DAILY PRACTICE ROUTINE

**Morning (1 hour)**
- Read 5-7 questions
- Understand concepts deeply
- Write code examples

**Evening (1 hour)**
- Practice explaining to someone
- Whiteboard complex topics
- Mock interview practice

**Total**: 2 hours/day = 14 hours/week

---

**Database ready\! Each question has: difficulty, experience level, companies, code examples, and follow-ups.**
