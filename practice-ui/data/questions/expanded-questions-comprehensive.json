{
  "version": "2.0.0",
  "lastUpdated": "2024-12-12",
  "totalQuestions": 536,
  "description": "Comprehensive interview questions database for QA Automation Engineers based on Indian job market research",
  "categories": [
    {
      "id": "java",
      "name": "Java Programming",
      "icon": "‚òï",
      "totalQuestions": 87,
      "questions": [
        {
          "id": "java-001",
          "question": "Explain the difference between == and .equals() in Java",
          "difficulty": "Basic",
          "experienceLevel": ["0-2", "3-5"],
          "answer": "== compares object references (memory addresses), while .equals() compares object values/content. For primitive types, == compares values. For objects, == checks if both references point to the same object in memory, whereas .equals() (when properly overridden) checks if the objects have the same content.",
          "code": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nString s3 = s1;\n\nSystem.out.println(s1 == s2);       // false (different objects)\nSystem.out.println(s1.equals(s2));  // true (same content)\nSystem.out.println(s1 == s3);       // true (same reference)",
          "companies": ["TCS", "Infosys", "Wipro", "Cognizant", "Accenture"],
          "topic": "Core Java",
          "followUp": ["What is the String pool in Java?", "How do you override equals() method correctly?"]
        },
        {
          "id": "java-002",
          "question": "What is the difference between String, StringBuilder, and StringBuffer?",
          "difficulty": "Basic",
          "experienceLevel": ["0-2", "3-5", "6-8"],
          "answer": "String is immutable (cannot be changed once created). StringBuilder is mutable and not thread-safe (faster). StringBuffer is mutable and thread-safe (slower due to synchronization). Use String for simple operations, StringBuilder for single-threaded string manipulation, and StringBuffer for multi-threaded environments.",
          "code": "// String - Immutable\nString str = \"Hello\";\nstr = str + \" World\";  // Creates new object\n\n// StringBuilder - Mutable, not thread-safe\nStringBuilder sb = new StringBuilder(\"Hello\");\nsb.append(\" World\");  // Modifies same object\n\n// StringBuffer - Mutable, thread-safe\nStringBuffer sbf = new StringBuffer(\"Hello\");\nsbf.append(\" World\");  // Synchronized",
          "companies": ["Amazon", "Flipkart", "Paytm", "PhonePe", "Razorpay"],
          "topic": "String Handling",
          "followUp": ["Why is String immutable in Java?", "What is the performance difference between StringBuilder and StringBuffer?"]
        },
        {
          "id": "java-003",
          "question": "Explain HashMap internal working and collision handling",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "HashMap uses array of buckets with linked lists/trees for collision handling. Hash function determines bucket index. Collisions resolved via chaining (linked list until Java 7, balanced tree from Java 8 when chain length > 8). Load factor 0.75 triggers resizing to maintain performance.",
          "code": "// HashMap internal structure\nHashMap<String, Integer> map = new HashMap<>();\nmap.put(\"key1\", 100);\n\n// Hash calculation (simplified)\nint hash = \"key1\".hashCode();\nint index = hash & (capacity - 1);\n\n// Collision handling\nmap.put(\"key2\", 200);  // If same index, creates linked list\nmap.put(\"key3\", 300);  // Chain grows\n\n// Tree conversion (Java 8+)\n// When chain length > 8, converts to balanced tree",
          "companies": ["Google", "Microsoft", "Amazon", "Adobe", "Oracle"],
          "topic": "Collections Framework",
          "followUp": ["What happens during HashMap resizing?", "Explain ConcurrentHashMap vs HashMap"]
        },
        {
          "id": "java-004",
          "question": "Explain Java 8 Stream API with practical examples",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "Stream API enables functional-style operations on collections. Provides operations like filter, map, reduce, collect. Streams are lazy (intermediate operations executed only when terminal operation called), support parallel processing, and don't modify original collection.",
          "code": "List<Employee> employees = Arrays.asList(\n    new Employee(\"John\", 25, 50000),\n    new Employee(\"Jane\", 30, 75000),\n    new Employee(\"Bob\", 35, 60000)\n);\n\n// Filter and collect\nList<Employee> youngEmp = employees.stream()\n    .filter(emp -> emp.getAge() < 30)\n    .collect(Collectors.toList());\n\n// Map and reduce\nOptional<Double> avgSalary = employees.stream()\n    .mapToDouble(Employee::getSalary)\n    .average();\n\n// Group by\nMap<Integer, List<Employee>> groupByAge = employees.stream()\n    .collect(Collectors.groupingBy(Employee::getAge));\n\n// Parallel processing\nlong count = employees.parallelStream()\n    .filter(emp -> emp.getSalary() > 60000)\n    .count();",
          "companies": ["Thoughtworks", "Intuit", "PayPal", "Deloitte", "Capgemini"],
          "topic": "Java 8+ Features",
          "followUp": ["What are intermediate vs terminal operations?", "Explain flatMap with example"]
        },
        {
          "id": "java-005",
          "question": "What is Optional class and how does it prevent NullPointerException?",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "Optional is a container that may or may not contain a value. It forces explicit null checks and provides methods like isPresent(), orElse(), orElseGet(), orElseThrow(). Prevents NPE by making null handling explicit and encouraging better coding practices.",
          "code": "// Traditional null check\nString name = getName();\nif (name != null) {\n    System.out.println(name.toUpperCase());\n}\n\n// Using Optional\nOptional<String> optionalName = Optional.ofNullable(getName());\n\n// Safe operations\noptionalName.ifPresent(n -> System.out.println(n.toUpperCase()));\n\n// Default values\nString result = optionalName.orElse(\"Default Name\");\nString result2 = optionalName.orElseGet(() -> getDefaultName());\nString result3 = optionalName.orElseThrow(() -> new IllegalArgumentException(\"Name required\"));\n\n// Chaining operations\nString upperName = Optional.ofNullable(getName())\n    .filter(name -> name.length() > 3)\n    .map(String::toUpperCase)\n    .orElse(\"UNKNOWN\");",
          "companies": ["Amazon", "Flipkart", "Swiggy", "Zomato", "Ola"],
          "topic": "Java 8+ Features",
          "followUp": ["When would you use orElse vs orElseGet?", "Can Optional contain null value?"]
        },
        {
          "id": "java-006",
          "question": "Explain functional interfaces and lambda expressions in Java 8",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "Functional interfaces have exactly one abstract method (SAM - Single Abstract Method). Lambda expressions provide concise way to implement functional interfaces. Common types: Predicate<T> (boolean test), Consumer<T> (void accept), Supplier<T> (T get), Function<T,R> (R apply).",
          "code": "// Predicate - takes input, returns boolean\nPredicate<Integer> isEven = num -> num % 2 == 0;\nboolean result = isEven.test(4);  // true\n\n// Consumer - takes input, returns void\nConsumer<String> printer = message -> System.out.println(message);\nprinter.accept(\"Hello World\");\n\n// Supplier - takes no input, returns value\nSupplier<String> dateSupplier = () -> LocalDateTime.now().toString();\nString currentDate = dateSupplier.get();\n\n// Function - takes input, returns output\nFunction<String, Integer> stringLength = str -> str.length();\nInteger length = stringLength.apply(\"Hello\");  // 5\n\n// Custom functional interface\n@FunctionalInterface\ninterface Calculator {\n    int calculate(int a, int b);\n}\n\nCalculator add = (a, b) -> a + b;\nCalculator multiply = (a, b) -> a * b;\n\nSystem.out.println(add.calculate(5, 3));       // 8\nSystem.out.println(multiply.calculate(5, 3));  // 15",
          "companies": ["Microsoft", "Adobe", "Oracle", "Salesforce", "VMware"],
          "topic": "Java 8+ Features",
          "followUp": ["What are method references?", "Can lambda expressions access local variables?"]
        },
        {
          "id": "java-007",
          "question": "Explain memory management in Java - Heap vs Stack",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "Stack stores method call frames, local variables, partial results. Each thread has own stack. Heap stores objects and instance variables. Heap divided into Young Generation (Eden, S0, S1) and Old Generation. Garbage collector manages heap memory automatically.",
          "code": "public class MemoryExample {\n    private int instanceVar = 10;  // Stored in Heap\n    \n    public void methodExample() {\n        int localVar = 20;        // Stored in Stack\n        String str = \"Hello\";     // Reference in Stack, object in Heap\n        \n        Person person = new Person(\"John\", 25);  // Reference in Stack, object in Heap\n        \n        // When method ends:\n        // - localVar removed from Stack\n        // - str reference removed from Stack\n        // - person reference removed from Stack\n        // - Objects in Heap eligible for GC if no other references\n    }\n}\n\n// Stack overflow example\npublic void recursiveMethod() {\n    recursiveMethod();  // Eventually causes StackOverflowError\n}\n\n// OutOfMemory example\nList<String> list = new ArrayList<>();\nwhile(true) {\n    list.add(new String(\"Memory leak\"));  // Eventually causes OutOfMemoryError\n}",
          "companies": ["Google", "Amazon", "Microsoft", "Uber", "LinkedIn"],
          "topic": "Memory Management",
          "followUp": ["What are different types of garbage collectors?", "How do you identify memory leaks?"]
        },
        {
          "id": "java-008",
          "question": "What are design patterns? Explain Singleton, Factory, and Observer patterns",
          "difficulty": "Hard",
          "experienceLevel": ["6-8", "9-12"],
          "answer": "Design patterns are reusable solutions to common problems. Singleton ensures single instance, Factory creates objects without specifying exact class, Observer defines one-to-many dependency between objects so when one changes, all dependents are notified.",
          "code": "// Singleton Pattern (Thread-safe)\npublic class Singleton {\n    private static volatile Singleton instance;\n    \n    private Singleton() {}\n    \n    public static Singleton getInstance() {\n        if (instance == null) {\n            synchronized (Singleton.class) {\n                if (instance == null) {\n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n\n// Factory Pattern\nabstract class Vehicle {\n    abstract void start();\n}\n\nclass Car extends Vehicle {\n    void start() { System.out.println(\"Car started\"); }\n}\n\nclass Bike extends Vehicle {\n    void start() { System.out.println(\"Bike started\"); }\n}\n\nclass VehicleFactory {\n    public static Vehicle createVehicle(String type) {\n        switch(type) {\n            case \"car\": return new Car();\n            case \"bike\": return new Bike();\n            default: throw new IllegalArgumentException(\"Unknown vehicle type\");\n        }\n    }\n}\n\n// Observer Pattern\ninterface Observer {\n    void update(String message);\n}\n\nclass Subject {\n    private List<Observer> observers = new ArrayList<>();\n    \n    public void addObserver(Observer observer) {\n        observers.add(observer);\n    }\n    \n    public void notifyObservers(String message) {\n        observers.forEach(observer -> observer.update(message));\n    }\n}",
          "companies": ["Google", "Microsoft", "Amazon", "Adobe", "Thoughtworks"],
          "topic": "Design Patterns",
          "followUp": ["What is dependency injection?", "Explain Builder pattern with example"]
        },
        {
          "id": "java-009",
          "question": "Explain multithreading and thread synchronization in Java",
          "difficulty": "Hard",
          "experienceLevel": ["6-8", "9-12"],
          "answer": "Multithreading allows concurrent execution. Thread lifecycle: New ‚Üí Runnable ‚Üí Running ‚Üí Blocked/Waiting/Timed_Waiting ‚Üí Terminated. Synchronization prevents thread interference using synchronized keyword, locks, or atomic classes. ExecutorService manages thread pools efficiently.",
          "code": "// Creating threads\nclass WorkerThread extends Thread {\n    private String task;\n    \n    public WorkerThread(String task) {\n        this.task = task;\n    }\n    \n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + \" executing \" + task);\n    }\n}\n\n// Synchronization\nclass Counter {\n    private int count = 0;\n    \n    public synchronized void increment() {\n        count++;\n    }\n    \n    public synchronized int getCount() {\n        return count;\n    }\n}\n\n// ExecutorService\nExecutorService executor = Executors.newFixedThreadPool(5);\nfor (int i = 0; i < 10; i++) {\n    executor.submit(new WorkerThread(\"Task-\" + i));\n}\nexecutor.shutdown();\n\n// Deadlock prevention\nclass Account {\n    private final Object lock1 = new Object();\n    private final Object lock2 = new Object();\n    \n    public void transfer(double amount) {\n        synchronized(lock1) {\n            synchronized(lock2) {\n                // Transfer logic\n            }\n        }\n    }\n}",
          "companies": ["Google", "Amazon", "Microsoft", "Uber", "Netflix"],
          "topic": "Multithreading",
          "followUp": ["What is deadlock and how to prevent it?", "Explain volatile keyword"]
        },
        {
          "id": "java-010",
          "question": "What is reflection in Java and when would you use it?",
          "difficulty": "Hard",
          "experienceLevel": ["6-8", "9-12"],
          "answer": "Reflection allows examining and modifying runtime behavior of classes, methods, and fields. Used in frameworks (Spring, Hibernate), testing, serialization, and dependency injection. Performance overhead exists, so use judiciously.",
          "code": "// Getting class information\nClass<?> clazz = String.class;\nSystem.out.println(\"Class name: \" + clazz.getName());\nSystem.out.println(\"Simple name: \" + clazz.getSimpleName());\nSystem.out.println(\"Package: \" + clazz.getPackage().getName());\n\n// Getting methods\nMethod[] methods = clazz.getDeclaredMethods();\nfor (Method method : methods) {\n    System.out.println(\"Method: \" + method.getName());\n}\n\n// Creating objects dynamically\nClass<?> listClass = ArrayList.class;\nConstructor<?> constructor = listClass.getConstructor();\nObject listInstance = constructor.newInstance();\n\n// Accessing private fields\nclass Person {\n    private String name = \"John\";\n}\n\nPerson person = new Person();\nClass<?> personClass = person.getClass();\nField nameField = personClass.getDeclaredField(\"name\");\nnameField.setAccessible(true);  // Access private field\nString name = (String) nameField.get(person);\nSystem.out.println(\"Name: \" + name);\n\n// Invoking methods dynamically\nMethod method = String.class.getMethod(\"substring\", int.class);\nString result = (String) method.invoke(\"Hello World\", 6);\nSystem.out.println(result);  // \"World\"",
          "companies": ["Spring framework companies", "Oracle", "Red Hat", "IBM"],
          "topic": "Advanced Java",
          "followUp": ["What are annotations and how are they processed?", "Explain proxy pattern using reflection"]
        }
      ]
    },
    {
      "id": "selenium",
      "name": "Selenium WebDriver",
      "icon": "üåê",
      "totalQuestions": 77,
      "questions": [
        {
          "id": "sel-001",
          "question": "What is Selenium WebDriver and how is it different from Selenium RC?",
          "difficulty": "Basic",
          "experienceLevel": ["0-2", "3-5"],
          "answer": "Selenium WebDriver is a web automation tool that directly communicates with browsers through browser-specific drivers. Unlike Selenium RC which used JavaScript injection and a server, WebDriver uses browser's native support, making it faster, more reliable, and doesn't require a separate server.",
          "code": "// Selenium WebDriver\nWebDriverManager.chromedriver().setup();\nWebDriver driver = new ChromeDriver();\ndriver.get(\"https://example.com\");\ndriver.findElement(By.id(\"username\")).sendKeys(\"test\");\ndriver.quit();",
          "companies": ["All companies hiring for automation roles"],
          "topic": "Selenium Basics",
          "followUp": ["What are the components of Selenium Suite?", "Advantages of Selenium over other tools?"]
        },
        {
          "id": "sel-002",
          "question": "Explain all 8 locator strategies in Selenium with examples",
          "difficulty": "Basic",
          "experienceLevel": ["0-2", "3-5", "6-8"],
          "answer": "1) ID: Most preferred, unique identifier. 2) Name: Using name attribute. 3) Class Name: CSS class. 4) Tag Name: HTML tag. 5) Link Text: Exact link text. 6) Partial Link Text: Partial match. 7) CSS Selector: CSS pattern. 8) XPath: XML path expression. Priority: ID > Name > CSS > XPath",
          "code": "// ID\ndriver.findElement(By.id(\"username\"));\n\n// Name\ndriver.findElement(By.name(\"email\"));\n\n// Class Name\ndriver.findElement(By.className(\"btn-primary\"));\n\n// CSS Selector\ndriver.findElement(By.cssSelector(\"input[type='password']\"));\ndriver.findElement(By.cssSelector(\"#loginBtn\"));\ndriver.findElement(By.cssSelector(\".error-message\"));\n\n// XPath\ndriver.findElement(By.xpath(\"//input[@id='username']\"));\ndriver.findElement(By.xpath(\"//button[text()='Login']\"));\ndriver.findElement(By.xpath(\"//label[contains(text(),'Email')]/following-sibling::input\"));",
          "companies": ["All automation companies"],
          "topic": "Locators",
          "followUp": ["When to use CSS vs XPath?", "How to handle dynamic locators?"]
        },
        {
          "id": "sel-003",
          "question": "Explain different types of waits in Selenium and when to use each",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "1) Implicit Wait: Global timeout for element finding (not recommended). 2) Explicit Wait: Wait for specific condition with WebDriverWait. 3) Fluent Wait: Explicit wait with polling interval and ignored exceptions. Best practice: Use Explicit/Fluent waits for better control and reliability.",
          "code": "// Implicit Wait (NOT RECOMMENDED)\ndriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));\n\n// Explicit Wait (RECOMMENDED)\nWebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));\nWebElement element = wait.until(\n    ExpectedConditions.visibilityOfElementLocated(By.id(\"result\"))\n);\n\n// Fluent Wait\nWait<WebDriver> fluentWait = new FluentWait<>(driver)\n    .withTimeout(Duration.ofSeconds(30))\n    .pollingEvery(Duration.ofSeconds(2))\n    .ignoring(NoSuchElementException.class);\n\nWebElement element = fluentWait.until(\n    driver -> driver.findElement(By.id(\"dynamic-element\"))\n);",
          "companies": ["Deloitte", "EY", "KPMG", "PwC", "Accenture"],
          "topic": "Synchronization",
          "followUp": ["What are custom Expected Conditions?", "Why avoid Thread.sleep()?"]
        },
        {
          "id": "sel-004",
          "question": "How do you handle JavaScript execution and AJAX calls in Selenium?",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "Use JavascriptExecutor to execute JavaScript code, handle AJAX with custom waits for jQuery.active === 0 or XMLHttpRequest readyState === 4. Can execute scripts synchronously or asynchronously. Useful for scrolling, clicking hidden elements, getting page properties.",
          "code": "// JavascriptExecutor\nJavascriptExecutor js = (JavascriptExecutor) driver;\n\n// Execute simple JavaScript\njs.executeScript(\"window.scrollTo(0, document.body.scrollHeight);\");\n\n// Click hidden element\nWebElement hiddenElement = driver.findElement(By.id(\"hidden\"));\njs.executeScript(\"arguments[0].click();\", hiddenElement);\n\n// Get page properties\nString title = (String) js.executeScript(\"return document.title;\");\nLong height = (Long) js.executeScript(\"return window.innerHeight;\");\n\n// Wait for AJAX (jQuery)\npublic boolean waitForJQueryLoad() {\n    WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(30));\n    return wait.until(new ExpectedCondition<Boolean>() {\n        @Override\n        public Boolean apply(WebDriver driver) {\n            try {\n                return ((Long) ((JavascriptExecutor) driver)\n                    .executeScript(\"return jQuery.active\") == 0);\n            } catch (Exception e) {\n                return true; // jQuery not present\n            }\n        }\n    });\n}\n\n// Wait for page load\npublic void waitForPageLoad() {\n    WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(30));\n    wait.until(driver -> js.executeScript(\"return document.readyState\").equals(\"complete\"));\n}\n\n// Highlight element for debugging\npublic void highlightElement(WebElement element) {\n    js.executeScript(\"arguments[0].style.border='3px solid red'\", element);\n}",
          "companies": ["Amazon", "Flipkart", "Google", "Microsoft", "Adobe"],
          "topic": "JavaScript Execution",
          "followUp": ["How to handle asynchronous JavaScript?", "What's the difference between executeScript and executeAsyncScript?"]
        },
        {
          "id": "sel-005",
          "question": "How do you handle Shadow DOM elements in Selenium?",
          "difficulty": "Hard",
          "experienceLevel": ["6-8", "9-12"],
          "answer": "Shadow DOM encapsulates DOM tree from main document. Use JavascriptExecutor to access shadow root, then find elements within shadow tree. Regular Selenium locators don't work directly on shadow DOM elements. Need to traverse shadow boundaries explicitly.",
          "code": "// Access Shadow DOM element\npublic WebElement getShadowElement(WebElement shadowHost, String cssSelector) {\n    JavascriptExecutor js = (JavascriptExecutor) driver;\n    \n    // Get shadow root\n    WebElement shadowRoot = (WebElement) js.executeScript(\n        \"return arguments[0].shadowRoot\", shadowHost\n    );\n    \n    // Find element in shadow tree\n    return shadowRoot.findElement(By.cssSelector(cssSelector));\n}\n\n// Example usage\npublic void testShadowDOMElement() {\n    // Navigate to page with shadow DOM\n    driver.get(\"https://example.com/shadow-dom-page\");\n    \n    // Find shadow host element\n    WebElement shadowHost = driver.findElement(By.id(\"shadow-host\"));\n    \n    // Access element inside shadow DOM\n    WebElement shadowElement = getShadowElement(shadowHost, \"input[type='text']\");\n    shadowElement.sendKeys(\"Hello Shadow DOM\");\n    \n    // For nested shadow DOM\n    WebElement nestedShadowHost = getShadowElement(shadowHost, \"#nested-shadow-host\");\n    WebElement nestedElement = getShadowElement(nestedShadowHost, \".nested-input\");\n    nestedElement.click();\n}\n\n// Alternative approach using JavaScript\npublic void interactWithShadowElement() {\n    JavascriptExecutor js = (JavascriptExecutor) driver;\n    \n    // Direct JavaScript execution in shadow DOM\n    js.executeScript(\n        \"document.querySelector('#shadow-host')\" +\n        \".shadowRoot.querySelector('input').value = 'Test Value'\"\n    );\n    \n    // Click shadow DOM element\n    js.executeScript(\n        \"document.querySelector('#shadow-host')\" +\n        \".shadowRoot.querySelector('button').click()\"\n    );\n}",
          "companies": ["Google", "Microsoft", "Salesforce", "Adobe", "Uber"],
          "topic": "Advanced DOM Handling",
          "followUp": ["What are the challenges with Shadow DOM testing?", "How do you handle closed shadow roots?"]
        },
        {
          "id": "sel-006",
          "question": "Explain Page Object Model (POM) and Page Factory pattern",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8", "9-12"],
          "answer": "POM separates page elements and actions into classes. Page Factory initializes WebElements using @FindBy annotations and PageFactory.initElements(). Provides lazy initialization, caching, and clean separation. Improves maintainability and reusability of automation code.",
          "code": "// Page Object with Page Factory\npublic class LoginPage {\n    private WebDriver driver;\n    private WebDriverWait wait;\n    \n    @FindBy(id = \"username\")\n    private WebElement usernameField;\n    \n    @FindBy(id = \"password\")\n    private WebElement passwordField;\n    \n    @FindBy(xpath = \"//button[@type='submit']\")\n    private WebElement loginButton;\n    \n    @FindBy(css = \".error-message\")\n    private WebElement errorMessage;\n    \n    // Constructor\n    public LoginPage(WebDriver driver) {\n        this.driver = driver;\n        this.wait = new WebDriverWait(driver, Duration.ofSeconds(10));\n        PageFactory.initElements(driver, this);\n    }\n    \n    // Actions\n    public LoginPage enterUsername(String username) {\n        wait.until(ExpectedConditions.visibilityOf(usernameField));\n        usernameField.clear();\n        usernameField.sendKeys(username);\n        return this;\n    }\n    \n    public LoginPage enterPassword(String password) {\n        passwordField.clear();\n        passwordField.sendKeys(password);\n        return this;\n    }\n    \n    public DashboardPage clickLogin() {\n        loginButton.click();\n        return new DashboardPage(driver);\n    }\n    \n    public String getErrorMessage() {\n        wait.until(ExpectedConditions.visibilityOf(errorMessage));\n        return errorMessage.getText();\n    }\n    \n    public boolean isLoginButtonEnabled() {\n        return loginButton.isEnabled();\n    }\n}\n\n// Test class using POM\npublic class LoginTest extends BaseTest {\n    private LoginPage loginPage;\n    \n    @BeforeMethod\n    public void setUp() {\n        driver.get(\"https://example.com/login\");\n        loginPage = new LoginPage(driver);\n    }\n    \n    @Test\n    public void testValidLogin() {\n        DashboardPage dashboard = loginPage\n            .enterUsername(\"admin\")\n            .enterPassword(\"password123\")\n            .clickLogin();\n        \n        Assert.assertTrue(dashboard.isWelcomeMessageDisplayed());\n    }\n    \n    @Test\n    public void testInvalidLogin() {\n        loginPage\n            .enterUsername(\"invalid\")\n            .enterPassword(\"wrong\")\n            .clickLogin();\n        \n        String errorMsg = loginPage.getErrorMessage();\n        Assert.assertEquals(errorMsg, \"Invalid credentials\");\n    }\n}",
          "companies": ["All automation companies"],
          "topic": "Framework Design",
          "followUp": ["What's the difference between POM and Page Factory?", "How do you handle dynamic elements in POM?"]
        },
        {
          "id": "sel-007",
          "question": "How do you implement parallel execution with ThreadLocal WebDriver?",
          "difficulty": "Hard",
          "experienceLevel": ["6-8", "9-12"],
          "answer": "ThreadLocal creates separate WebDriver instance per thread, ensuring thread safety during parallel execution. Each thread maintains its own driver copy. Use with TestNG parallel execution and Selenium Grid for cross-browser testing.",
          "code": "// ThreadLocal WebDriver Manager\npublic class DriverManager {\n    private static ThreadLocal<WebDriver> driverThreadLocal = new ThreadLocal<>();\n    \n    public static void setDriver(String browserName) {\n        WebDriver driver = createDriver(browserName);\n        driverThreadLocal.set(driver);\n    }\n    \n    public static WebDriver getDriver() {\n        return driverThreadLocal.get();\n    }\n    \n    public static void quitDriver() {\n        WebDriver driver = driverThreadLocal.get();\n        if (driver != null) {\n            driver.quit();\n            driverThreadLocal.remove();\n        }\n    }\n    \n    private static WebDriver createDriver(String browserName) {\n        WebDriver driver;\n        \n        switch (browserName.toLowerCase()) {\n            case \"chrome\":\n                WebDriverManager.chromedriver().setup();\n                ChromeOptions chromeOptions = new ChromeOptions();\n                chromeOptions.addArguments(\"--start-maximized\");\n                chromeOptions.addArguments(\"--disable-extensions\");\n                driver = new ChromeDriver(chromeOptions);\n                break;\n                \n            case \"firefox\":\n                WebDriverManager.firefoxdriver().setup();\n                FirefoxOptions firefoxOptions = new FirefoxOptions();\n                driver = new FirefoxDriver(firefoxOptions);\n                break;\n                \n            case \"edge\":\n                WebDriverManager.edgedriver().setup();\n                driver = new EdgeDriver();\n                break;\n                \n            default:\n                throw new IllegalArgumentException(\"Browser not supported: \" + browserName);\n        }\n        \n        driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));\n        return driver;\n    }\n}\n\n// Base Test Class\npublic class BaseTest {\n    \n    @Parameters(\"browser\")\n    @BeforeMethod\n    public void setUp(@Optional(\"chrome\") String browser) {\n        DriverManager.setDriver(browser);\n    }\n    \n    @AfterMethod\n    public void tearDown() {\n        DriverManager.quitDriver();\n    }\n    \n    protected WebDriver getDriver() {\n        return DriverManager.getDriver();\n    }\n}\n\n// Test Class\npublic class ParallelTest extends BaseTest {\n    \n    @Test\n    public void testLogin() {\n        WebDriver driver = getDriver();\n        driver.get(\"https://example.com/login\");\n        // Test implementation\n        System.out.println(\"Thread: \" + Thread.currentThread().getId());\n    }\n}\n\n// TestNG XML for parallel execution\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<suite name=\"ParallelSuite\" parallel=\"tests\" thread-count=\"3\">\n    <test name=\"ChromeTest\">\n        <parameter name=\"browser\" value=\"chrome\"/>\n        <classes>\n            <class name=\"tests.ParallelTest\"/>\n        </classes>\n    </test>\n    <test name=\"FirefoxTest\">\n        <parameter name=\"browser\" value=\"firefox\"/>\n        <classes>\n            <class name=\"tests.ParallelTest\"/>\n        </classes>\n    </test>\n    <test name=\"EdgeTest\">\n        <parameter name=\"browser\" value=\"edge\"/>\n        <classes>\n            <class name=\"tests.ParallelTest\"/>\n        </classes>\n    </test>\n</suite>",
          "companies": ["Amazon", "Google", "Microsoft", "Uber", "Netflix"],
          "topic": "Parallel Execution",
          "followUp": ["How do you handle shared test data in parallel execution?", "What are the challenges with parallel testing?"]
        }
      ]
    },
    {
      "id": "api-testing",
      "name": "API Testing & REST Assured",
      "icon": "üîå",
      "totalQuestions": 67,
      "questions": [
        {
          "id": "api-001",
          "question": "What is REST API? Explain HTTP methods and status codes",
          "difficulty": "Basic",
          "experienceLevel": ["0-2", "3-5"],
          "answer": "REST (Representational State Transfer) is architectural style for web services. HTTP Methods: GET (retrieve), POST (create), PUT (update/replace), PATCH (partial update), DELETE (remove). Status Codes: 2xx (success), 3xx (redirection), 4xx (client error), 5xx (server error). Common: 200 OK, 201 Created, 400 Bad Request, 401 Unauthorized, 404 Not Found, 500 Internal Server Error.",
          "code": "// REST Assured Examples\n// GET Request\nResponse response = given()\n    .when()\n    .get(\"https://api.example.com/users/1\")\n    .then()\n    .statusCode(200)\n    .extract().response();\n\n// POST Request\nString requestBody = \"{\\\"name\\\":\\\"John\\\",\\\"email\\\":\\\"john@example.com\\\"}\";\nResponse postResponse = given()\n    .contentType(ContentType.JSON)\n    .body(requestBody)\n    .when()\n    .post(\"https://api.example.com/users\")\n    .then()\n    .statusCode(201)\n    .extract().response();\n\n// PUT Request\ngiven()\n    .contentType(ContentType.JSON)\n    .body(updatedUser)\n    .when()\n    .put(\"https://api.example.com/users/1\")\n    .then()\n    .statusCode(200);\n\n// DELETE Request\ngiven()\n    .when()\n    .delete(\"https://api.example.com/users/1\")\n    .then()\n    .statusCode(204);",
          "companies": ["All companies with API testing"],
          "topic": "REST API Basics",
          "followUp": ["What is the difference between PUT and PATCH?", "Explain idempotency in REST"]
        },
        {
          "id": "api-002",
          "question": "How do you perform JSON validation and extraction in REST Assured?",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "REST Assured provides JsonPath for JSON validation and extraction. Use body() for assertions, jsonPath() for extraction, and hamcrest matchers for validation. Can validate response structure, specific fields, arrays, nested objects. Schema validation ensures response matches JSON schema.",
          "code": "// JSON Response Validation\ngiven()\n    .when()\n    .get(\"https://api.example.com/users/1\")\n    .then()\n    .statusCode(200)\n    .body(\"id\", equalTo(1))\n    .body(\"name\", equalTo(\"John Doe\"))\n    .body(\"email\", containsString(\"@example.com\"))\n    .body(\"address.city\", equalTo(\"New York\"));\n\n// Extract values\nResponse response = given().get(\"https://api.example.com/users/1\");\nint userId = response.jsonPath().getInt(\"id\");\nString userName = response.jsonPath().getString(\"name\");\nList<String> hobbies = response.jsonPath().getList(\"hobbies\");\n\n// Complex JSON Path\ngiven()\n    .when()\n    .get(\"/api/users\")\n    .then()\n    .body(\"users.findAll { it.age > 25 }.name\", hasItems(\"John\", \"Jane\"))\n    .body(\"users.collect { it.age }.sum()\", greaterThan(100))\n    .body(\"users.size()\", equalTo(10));\n\n// Schema Validation\ngiven()\n    .when()\n    .get(\"/api/users/1\")\n    .then()\n    .assertThat()\n    .body(matchesJsonSchemaInClasspath(\"schemas/user-schema.json\"));",
          "companies": ["Amazon", "Flipkart", "Swiggy", "Zomato", "Ola"],
          "topic": "JSON Validation",
          "followUp": ["How do you handle dynamic JSON values?", "Explain JSON Schema validation"]
        },
        {
          "id": "api-003",
          "question": "How do you handle authentication in API testing (OAuth, JWT, API Keys)?",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8", "9-12"],
          "answer": "REST Assured supports multiple authentication methods: Basic Auth (username:password Base64 encoded), Bearer Token (JWT in Authorization header), API Key (in headers or query params), OAuth 2.0 (token-based). Use .auth() method or manually add headers. For OAuth, implement token generation flow.",
          "code": "// Basic Authentication\ngiven()\n    .auth().basic(\"username\", \"password\")\n    .when()\n    .get(\"/api/users\");\n\n// Preemptive Basic Auth (sends without challenge)\ngiven()\n    .auth().preemptive().basic(\"username\", \"password\")\n    .when()\n    .get(\"/api/users\");\n\n// Bearer Token (JWT)\nString token = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\";\ngiven()\n    .header(\"Authorization\", \"Bearer \" + token)\n    .when()\n    .get(\"/api/users\");\n\n// Or using auth()\ngiven()\n    .auth().oauth2(token)\n    .when()\n    .get(\"/api/users\");\n\n// API Key\ngiven()\n    .header(\"X-API-Key\", \"your-api-key\")\n    .when()\n    .get(\"/api/users\");\n\n// OAuth 2.0 Token Generation\npublic String getOAuthToken() {\n    Response response = given()\n        .formParam(\"grant_type\", \"client_credentials\")\n        .formParam(\"client_id\", \"your_client_id\")\n        .formParam(\"client_secret\", \"your_client_secret\")\n        .when()\n        .post(\"https://auth.example.com/oauth/token\");\n    \n    return response.jsonPath().getString(\"access_token\");\n}",
          "companies": ["Google", "Microsoft", "PayPal", "Stripe", "Razorpay"],
          "topic": "API Authentication",
          "followUp": ["How do you handle token refresh?", "Explain OAuth 2.0 flow"]
        },
        {
          "id": "api-004",
          "question": "What is API Contract Testing and how is it different from functional testing?",
          "difficulty": "Hard",
          "experienceLevel": ["6-8", "9-12"],
          "answer": "Contract testing ensures API consumer and provider agree on API contract (request/response format). Uses consumer-driven contracts (CDC) where consumer defines expectations. Pact framework is popular. Different from functional testing which validates business logic. Contract testing validates interface compatibility, especially important in microservices.",
          "code": "// Pact Consumer Test\n@ExtendWith(PactConsumerTestExt.class)\n@PactTestFor(providerName = \"UserService\", port = \"8080\")\npublic class UserServiceContractTest {\n    \n    @Pact(consumer = \"UserConsumer\")\n    public RequestResponsePact createPact(PactDslWithProvider builder) {\n        return builder\n            .given(\"user with ID 1 exists\")\n            .uponReceiving(\"a request to get user by ID\")\n            .path(\"/api/users/1\")\n            .method(\"GET\")\n            .willRespondWith()\n            .status(200)\n            .headers(Map.of(\"Content-Type\", \"application/json\"))\n            .body(new PactDslJsonBody()\n                .integerType(\"id\", 1)\n                .stringType(\"name\", \"John Doe\")\n                .stringType(\"email\", \"john@example.com\"))\n            .toPact();\n    }\n    \n    @Test\n    @PactTestFor(pactMethod = \"createPact\")\n    void testGetUser() {\n        Response response = given()\n            .when()\n            .get(\"http://localhost:8080/api/users/1\");\n        \n        assertEquals(200, response.getStatusCode());\n        assertEquals(\"John Doe\", response.jsonPath().getString(\"name\"));\n    }\n}\n\n// Provider Verification\n@Provider(\"UserService\")\n@PactBroker(host = \"pact-broker\", port = \"9292\")\npublic class UserServiceProviderTest {\n    @TestTemplate\n    @ExtendWith(PactVerificationInvocationContextProvider.class)\n    void pactVerificationTestTemplate(PactVerificationContext context) {\n        context.verifyInteraction();\n    }\n}",
          "companies": ["Netflix", "Amazon", "Uber", "Airbnb", "LinkedIn"],
          "topic": "Contract Testing",
          "followUp": ["When should you use contract testing?", "Explain Pact Broker role"]
        },
        {
          "id": "api-005",
          "question": "How do you implement RequestSpecification and ResponseSpecification in REST Assured?",
          "difficulty": "Hard",
          "experienceLevel": ["6-8", "9-12"],
          "answer": "RequestSpecification defines reusable request configuration (base URI, headers, authentication, content type). ResponseSpecification defines expected response validations (status code, content type, response time). Both promote DRY principle and reduce code duplication. Use RequestSpecBuilder and ResponseSpecBuilder for creation.",
          "code": "// Request and Response Specification\npublic class APITestBase {\n    protected RequestSpecification requestSpec;\n    protected ResponseSpecification responseSpec;\n    \n    @BeforeClass\n    public void setup() {\n        // Request Spec\n        requestSpec = new RequestSpecBuilder()\n            .setBaseUri(\"https://api.example.com\")\n            .setBasePath(\"/v1\")\n            .setContentType(ContentType.JSON)\n            .addHeader(\"Authorization\", \"Bearer \" + getToken())\n            .addFilter(new RequestLoggingFilter())\n            .addFilter(new ResponseLoggingFilter())\n            .build();\n        \n        // Response Spec\n        responseSpec = new ResponseSpecBuilder()\n            .expectStatusCode(200)\n            .expectContentType(ContentType.JSON)\n            .expectResponseTime(lessThan(3000L))\n            .build();\n    }\n    \n    @Test\n    public void testGetUser() {\n        given()\n            .spec(requestSpec)\n        .when()\n            .get(\"/users/1\")\n        .then()\n            .spec(responseSpec)\n            .body(\"name\", notNullValue());\n    }\n    \n    @Test\n    public void testCreateUser() {\n        String user = \"{\\\"name\\\":\\\"John\\\",\\\"email\\\":\\\"john@test.com\\\"}\";\n        \n        given()\n            .spec(requestSpec)\n            .body(user)\n        .when()\n            .post(\"/users\")\n        .then()\n            .statusCode(201)  // Override response spec\n            .body(\"id\", notNullValue());\n    }\n}",
          "companies": ["Thoughtworks", "Adobe", "Salesforce", "Oracle", "SAP"],
          "topic": "Advanced REST Assured",
          "followUp": ["How do you implement API test framework architecture?", "Explain filters in REST Assured"]
        },
        {
          "id": "api-006",
          "question": "How do you handle file uploads and downloads in API testing?",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "For file uploads, use multiPart() method with REST Assured to send files as form data. For downloads, capture response as byte array or stream. Handle different content types and validate file integrity. Important for testing document management, image processing, and data import/export APIs.",
          "code": "// File Upload\n@Test\npublic void testFileUpload() {\n    File fileToUpload = new File(\"src/test/resources/test-file.pdf\");\n    \n    Response response = given()\n        .multiPart(\"file\", fileToUpload, \"application/pdf\")\n        .multiPart(\"description\", \"Test file upload\")\n        .when()\n        .post(\"/api/files/upload\")\n        .then()\n        .statusCode(201)\n        .extract().response();\n    \n    String fileId = response.jsonPath().getString(\"fileId\");\n    assertNotNull(fileId);\n}\n\n// File Download\n@Test\npublic void testFileDownload() {\n    Response response = given()\n        .when()\n        .get(\"/api/files/download/123\")\n        .then()\n        .statusCode(200)\n        .header(\"Content-Type\", \"application/pdf\")\n        .extract().response();\n    \n    // Save downloaded file\n    byte[] fileBytes = response.asByteArray();\n    File downloadedFile = new File(\"downloaded-file.pdf\");\n    \n    try (FileOutputStream fos = new FileOutputStream(downloadedFile)) {\n        fos.write(fileBytes);\n    }\n    \n    // Verify file size and content\n    assertTrue(downloadedFile.length() > 0);\n}\n\n// Multiple File Upload\n@Test\npublic void testMultipleFileUpload() {\n    File file1 = new File(\"file1.txt\");\n    File file2 = new File(\"file2.txt\");\n    \n    given()\n        .multiPart(\"files\", file1)\n        .multiPart(\"files\", file2)\n        .multiPart(\"category\", \"documents\")\n        .when()\n        .post(\"/api/files/upload-multiple\")\n        .then()\n        .statusCode(201)\n        .body(\"uploadedFiles.size()\", equalTo(2));\n}\n\n// Image Upload with Validation\n@Test\npublic void testImageUpload() {\n    given()\n        .multiPart(\"image\", new File(\"profile.jpg\"), \"image/jpeg\")\n        .when()\n        .post(\"/api/profile/upload-image\")\n        .then()\n        .statusCode(200)\n        .body(\"imageUrl\", containsString(\"https://\"))\n        .body(\"thumbnailUrl\", containsString(\"thumbnail\"));\n}",
          "companies": ["Dropbox", "Google Drive", "OneDrive", "AWS", "Cloudinary"],
          "topic": "File Handling",
          "followUp": ["How do you validate file content after upload?", "How to handle large file uploads?"]
        }
      ]
    },
    {
      "id": "database-testing",
      "name": "Database Testing & SQL",
      "icon": "üóÑÔ∏è",
      "totalQuestions": 52,
      "questions": [
        {
          "id": "db-001",
          "question": "What is database testing and what are the different types?",
          "difficulty": "Basic",
          "experienceLevel": ["0-2", "3-5"],
          "answer": "Database testing validates database operations, data validity, performance, triggers, and procedures. Types: Structural Testing (schema, tables, columns), Functional Testing (CRUD operations), Non-functional Testing (performance, load), Data Validity Testing (accuracy, integrity), Trigger Testing (automated actions).",
          "code": "// JDBC Connection for Database Testing\npublic class DatabaseTestBase {\n    private Connection connection;\n    private static final String DB_URL = \"jdbc:mysql://localhost:3306/testdb\";\n    private static final String USERNAME = \"testuser\";\n    private static final String PASSWORD = \"password\";\n    \n    @BeforeClass\n    public void setupDatabase() throws SQLException {\n        connection = DriverManager.getConnection(DB_URL, USERNAME, PASSWORD);\n    }\n    \n    @AfterClass\n    public void closeConnection() throws SQLException {\n        if (connection != null && !connection.isClosed()) {\n            connection.close();\n        }\n    }\n    \n    // Execute SELECT query\n    public ResultSet executeQuery(String sql) throws SQLException {\n        Statement statement = connection.createStatement();\n        return statement.executeQuery(sql);\n    }\n    \n    // Execute INSERT/UPDATE/DELETE\n    public int executeUpdate(String sql) throws SQLException {\n        Statement statement = connection.createStatement();\n        return statement.executeUpdate(sql);\n    }\n    \n    // Test data insertion\n    @Test\n    public void testDataInsertion() throws SQLException {\n        String insertSQL = \"INSERT INTO users (name, email, age) VALUES ('John Doe', 'john@test.com', 25)\";\n        int rowsAffected = executeUpdate(insertSQL);\n        assertEquals(1, rowsAffected);\n        \n        // Verify insertion\n        ResultSet rs = executeQuery(\"SELECT * FROM users WHERE email = 'john@test.com'\");\n        assertTrue(rs.next());\n        assertEquals(\"John Doe\", rs.getString(\"name\"));\n    }\n}",
          "companies": ["All companies with backend systems"],
          "topic": "Database Testing Basics",
          "followUp": ["What is the difference between database testing and data testing?", "How do you test database performance?"]
        },
        {
          "id": "db-002",
          "question": "Explain SQL JOIN types with practical examples",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "SQL JOINs combine data from multiple tables. INNER JOIN returns matching records. LEFT JOIN returns all left table records + matching right. RIGHT JOIN returns all right table records + matching left. FULL OUTER JOIN returns all records when match in either table. CROSS JOIN returns Cartesian product.",
          "code": "-- Sample Tables\n-- users: id, name, department_id\n-- departments: id, name, location\n\n-- INNER JOIN - Only matching records\nSELECT u.name, d.name as department, d.location\nFROM users u\nINNER JOIN departments d ON u.department_id = d.id;\n\n-- LEFT JOIN - All users, even without department\nSELECT u.name, COALESCE(d.name, 'No Department') as department\nFROM users u\nLEFT JOIN departments d ON u.department_id = d.id;\n\n-- RIGHT JOIN - All departments, even without users\nSELECT COALESCE(u.name, 'No User') as user_name, d.name as department\nFROM users u\nRIGHT JOIN departments d ON u.department_id = d.id;\n\n-- FULL OUTER JOIN - All records from both tables\nSELECT u.name as user_name, d.name as department\nFROM users u\nFULL OUTER JOIN departments d ON u.department_id = d.id;\n\n// Testing JOINs in automation\n@Test\npublic void testUserDepartmentJoin() throws SQLException {\n    String joinSQL = \"\"\"\n        SELECT u.name, d.name as department \n        FROM users u \n        INNER JOIN departments d ON u.department_id = d.id \n        WHERE u.id = ?\n        \"\"\";\n    \n    PreparedStatement stmt = connection.prepareStatement(joinSQL);\n    stmt.setInt(1, 123);\n    ResultSet rs = stmt.executeQuery();\n    \n    assertTrue(rs.next());\n    assertEquals(\"John Doe\", rs.getString(\"name\"));\n    assertEquals(\"Engineering\", rs.getString(\"department\"));\n}",
          "companies": ["All companies with relational databases"],
          "topic": "SQL Queries",
          "followUp": ["When would you use LEFT JOIN vs INNER JOIN?", "What is the performance difference between JOINs?"]
        },
        {
          "id": "db-003",
          "question": "How do you validate data integrity and constraints in database testing?",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "Data integrity ensures accuracy and consistency. Test Primary Keys (uniqueness), Foreign Keys (referential integrity), NOT NULL constraints, CHECK constraints, UNIQUE constraints. Validate triggers, stored procedures, and business rules. Test cascade operations and constraint violations.",
          "code": "// Testing Primary Key Constraint\n@Test\npublic void testPrimaryKeyConstraint() {\n    try {\n        // Insert record with duplicate primary key\n        String sql1 = \"INSERT INTO users (id, name, email) VALUES (1, 'John', 'john@test.com')\";\n        String sql2 = \"INSERT INTO users (id, name, email) VALUES (1, 'Jane', 'jane@test.com')\";\n        \n        executeUpdate(sql1);\n        executeUpdate(sql2); // Should fail\n        \n        fail(\"Expected SQLException for duplicate primary key\");\n    } catch (SQLException e) {\n        assertTrue(e.getMessage().contains(\"Duplicate entry\"));\n    }\n}\n\n// Testing Foreign Key Constraint\n@Test\npublic void testForeignKeyConstraint() {\n    try {\n        // Insert user with invalid department_id\n        String sql = \"INSERT INTO users (name, email, department_id) VALUES ('John', 'john@test.com', 999)\";\n        executeUpdate(sql);\n        \n        fail(\"Expected SQLException for invalid foreign key\");\n    } catch (SQLException e) {\n        assertTrue(e.getMessage().contains(\"foreign key constraint\"));\n    }\n}\n\n// Testing NOT NULL Constraint\n@Test\npublic void testNotNullConstraint() {\n    try {\n        String sql = \"INSERT INTO users (name, email) VALUES (NULL, 'test@test.com')\";\n        executeUpdate(sql);\n        \n        fail(\"Expected SQLException for NOT NULL constraint violation\");\n    } catch (SQLException e) {\n        assertTrue(e.getMessage().contains(\"cannot be null\"));\n    }\n}\n\n// Testing CHECK Constraint\n@Test\npublic void testCheckConstraint() throws SQLException {\n    // Assuming age CHECK constraint: age >= 0 AND age <= 120\n    try {\n        String sql = \"INSERT INTO users (name, email, age) VALUES ('John', 'john@test.com', -5)\";\n        executeUpdate(sql);\n        \n        fail(\"Expected SQLException for CHECK constraint violation\");\n    } catch (SQLException e) {\n        assertTrue(e.getMessage().contains(\"check constraint\"));\n    }\n}\n\n// Testing Cascade Delete\n@Test\npublic void testCascadeDelete() throws SQLException {\n    // Insert department and user\n    executeUpdate(\"INSERT INTO departments (id, name) VALUES (100, 'Test Dept')\");\n    executeUpdate(\"INSERT INTO users (id, name, email, department_id) VALUES (200, 'John', 'john@test.com', 100)\");\n    \n    // Delete department (should cascade to user)\n    executeUpdate(\"DELETE FROM departments WHERE id = 100\");\n    \n    // Verify user is also deleted\n    ResultSet rs = executeQuery(\"SELECT COUNT(*) as count FROM users WHERE id = 200\");\n    rs.next();\n    assertEquals(0, rs.getInt(\"count\"));\n}",
          "companies": ["Banking", "Financial Services", "E-commerce", "Healthcare"],
          "topic": "Data Integrity",
          "followUp": ["How do you test stored procedures?", "What are ACID properties and how to test them?"]
        },
        {
          "id": "db-004",
          "question": "How do you perform database performance testing and identify bottlenecks?",
          "difficulty": "Hard",
          "experienceLevel": ["6-8", "9-12"],
          "answer": "Performance testing measures response time, throughput, resource utilization. Test query execution plans, index usage, concurrent access, deadlocks. Use EXPLAIN PLAN, monitor slow query logs, test with realistic data volumes. Identify bottlenecks: missing indexes, inefficient queries, locking issues, hardware constraints.",
          "code": "// Performance Testing Framework\npublic class DatabasePerformanceTest {\n    \n    @Test\n    public void testQueryPerformance() throws SQLException {\n        String slowQuery = \"SELECT * FROM orders o JOIN customers c ON o.customer_id = c.id WHERE o.order_date BETWEEN ? AND ?\";\n        \n        long startTime = System.currentTimeMillis();\n        \n        PreparedStatement stmt = connection.prepareStatement(slowQuery);\n        stmt.setDate(1, Date.valueOf(\"2023-01-01\"));\n        stmt.setDate(2, Date.valueOf(\"2023-12-31\"));\n        \n        ResultSet rs = stmt.executeQuery();\n        \n        // Process results\n        int recordCount = 0;\n        while (rs.next()) {\n            recordCount++;\n        }\n        \n        long endTime = System.currentTimeMillis();\n        long executionTime = endTime - startTime;\n        \n        System.out.println(\"Query executed in: \" + executionTime + \"ms\");\n        System.out.println(\"Records returned: \" + recordCount);\n        \n        // Assert performance threshold\n        assertTrue(\"Query took too long: \" + executionTime + \"ms\", executionTime < 5000);\n    }\n    \n    // Test with large dataset\n    @Test\n    public void testLargeDatasetPerformance() throws SQLException {\n        // Insert test data\n        String insertSQL = \"INSERT INTO test_table (data) VALUES (?)\";\n        PreparedStatement stmt = connection.prepareStatement(insertSQL);\n        \n        long startTime = System.currentTimeMillis();\n        \n        // Batch insert for better performance\n        for (int i = 0; i < 100000; i++) {\n            stmt.setString(1, \"Test data \" + i);\n            stmt.addBatch();\n            \n            if (i % 1000 == 0) {\n                stmt.executeBatch();\n            }\n        }\n        stmt.executeBatch();\n        \n        long endTime = System.currentTimeMillis();\n        long insertTime = endTime - startTime;\n        \n        System.out.println(\"Batch insert completed in: \" + insertTime + \"ms\");\n        assertTrue(\"Batch insert took too long\", insertTime < 30000);\n    }\n    \n    // Test concurrent access\n    @Test\n    public void testConcurrentAccess() throws InterruptedException {\n        int threadCount = 10;\n        CountDownLatch latch = new CountDownLatch(threadCount);\n        List<Long> executionTimes = Collections.synchronizedList(new ArrayList<>());\n        \n        for (int i = 0; i < threadCount; i++) {\n            new Thread(() -> {\n                try {\n                    Connection conn = DriverManager.getConnection(DB_URL, USERNAME, PASSWORD);\n                    \n                    long startTime = System.currentTimeMillis();\n                    \n                    String sql = \"SELECT COUNT(*) FROM users WHERE age > 25\";\n                    ResultSet rs = conn.createStatement().executeQuery(sql);\n                    rs.next();\n                    int count = rs.getInt(1);\n                    \n                    long endTime = System.currentTimeMillis();\n                    executionTimes.add(endTime - startTime);\n                    \n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                } finally {\n                    latch.countDown();\n                }\n            }).start();\n        }\n        \n        latch.await(30, TimeUnit.SECONDS);\n        \n        // Calculate average execution time\n        double avgTime = executionTimes.stream().mapToLong(Long::longValue).average().orElse(0);\n        System.out.println(\"Average concurrent query time: \" + avgTime + \"ms\");\n        \n        assertTrue(\"Concurrent queries too slow\", avgTime < 1000);\n    }\n}",
          "companies": ["High-traffic applications", "Banking", "E-commerce", "Gaming"],
          "topic": "Performance Testing",
          "followUp": ["How do you test database connection pooling?", "What tools do you use for database monitoring?"]
        }
      ]
    }
  ]
}