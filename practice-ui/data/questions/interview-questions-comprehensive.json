{
  "metadata": {
    "version": "2.0",
    "totalQuestions": 250,
    "lastUpdated": "2025-12-01",
    "categories": 12
  },
  "categories": [
    {
      "id": "java-core",
      "name": "Java Core Concepts",
      "icon": "☕",
      "totalQuestions": 30,
      "questions": [
        {
          "id": "java-core-001",
          "question": "Explain the difference between == and .equals() in Java",
          "difficulty": "Basic",
          "experienceLevel": ["0-2", "3-5"],
          "answer": "== compares object references (memory addresses), while .equals() compares object values/content. For primitive types, == compares values. For objects, == checks if both references point to the same object in memory, whereas .equals() (when properly overridden) checks if the objects have the same content.",
          "code": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nString s3 = s1;\n\nSystem.out.println(s1 == s2);       // false (different objects)\nSystem.out.println(s1.equals(s2));  // true (same content)\nSystem.out.println(s1 == s3);       // true (same reference)",
          "companies": ["TCS", "Infosys", "Wipro", "Cognizant", "Accenture", "HCL"],
          "topic": "Object Comparison",
          "followUp": ["What is the String pool in Java?", "How do you override equals() method correctly?", "Why should you override hashCode() when you override equals()?"]
        },
        {
          "id": "java-core-002",
          "question": "What is the difference between String, StringBuilder, and StringBuffer?",
          "difficulty": "Basic",
          "experienceLevel": ["0-2", "3-5", "6-8"],
          "answer": "String is immutable (cannot be changed once created). StringBuilder is mutable and not thread-safe (faster). StringBuffer is mutable and thread-safe (slower due to synchronization). Use String for simple operations, StringBuilder for single-threaded string manipulation, and StringBuffer for multi-threaded environments.",
          "code": "// String - Immutable\nString str = \"Hello\";\nstr = str + \" World\";  // Creates new object\n\n// StringBuilder - Mutable, not thread-safe\nStringBuilder sb = new StringBuilder(\"Hello\");\nsb.append(\" World\");  // Modifies same object\n\n// StringBuffer - Mutable, thread-safe\nStringBuffer sbf = new StringBuffer(\"Hello\");\nsbf.append(\" World\");  // Synchronized",
          "companies": ["Amazon", "Flipkart", "Paytm", "PhonePe", "Razorpay", "Swiggy"],
          "topic": "String Handling",
          "followUp": ["Why is String immutable in Java?", "What is the performance difference between StringBuilder and StringBuffer?", "When would you use String concatenation (+) vs StringBuilder?"]
        },
        {
          "id": "java-core-003",
          "question": "Explain the four pillars of Object-Oriented Programming with examples",
          "difficulty": "Basic",
          "experienceLevel": ["0-2", "3-5"],
          "answer": "1) Encapsulation: Bundling data and methods together, hiding internal details using access modifiers. 2) Inheritance: Creating new classes from existing ones, promoting code reuse using 'extends'. 3) Polymorphism: Objects taking multiple forms - compile-time (overloading) and runtime (overriding). 4) Abstraction: Hiding complex implementation details, showing only essential features using abstract classes and interfaces.",
          "code": "// Encapsulation\nclass Account {\n    private double balance;\n    public void setBalance(double balance) { this.balance = balance; }\n    public double getBalance() { return balance; }\n}\n\n// Inheritance\nclass SavingsAccount extends Account {\n    private double interestRate;\n}\n\n// Polymorphism - Overriding\nclass Parent {\n    void display() { System.out.println(\"Parent\"); }\n}\nclass Child extends Parent {\n    @Override\n    void display() { System.out.println(\"Child\"); }\n}\n\n// Abstraction\nabstract class Shape {\n    abstract void draw();\n}\nclass Circle extends Shape {\n    void draw() { System.out.println(\"Drawing Circle\"); }\n}",
          "companies": ["All companies"],
          "topic": "OOP Fundamentals",
          "followUp": ["Give real-world examples of each OOP principle", "How does Java achieve abstraction?", "What's the difference between abstraction and encapsulation?"]
        },
        {
          "id": "java-core-004",
          "question": "What is the difference between abstract class and interface?",
          "difficulty": "Medium",
          "experienceLevel": ["0-2", "3-5", "6-8"],
          "answer": "Abstract Class: Can have both abstract and concrete methods, can have constructors, instance variables, and any access modifiers. A class can extend only one abstract class. Interface: All methods are abstract by default (before Java 8), can have default and static methods (Java 8+), all variables are public static final, a class can implement multiple interfaces. Use abstract class for 'is-a' relationship with common base implementation, use interface for 'can-do' relationship and multiple inheritance.",
          "code": "// Abstract Class\nabstract class Vehicle {\n    protected String brand;\n    \n    public Vehicle(String brand) {\n        this.brand = brand;\n    }\n    \n    abstract void start();\n    \n    void stop() {\n        System.out.println(\"Vehicle stopped\");\n    }\n}\n\n// Interface\ninterface Drivable {\n    void drive();\n    \n    default void honk() {\n        System.out.println(\"Honking...\");\n    }\n}\n\nclass Car extends Vehicle implements Drivable {\n    public Car(String brand) {\n        super(brand);\n    }\n    \n    @Override\n    void start() {\n        System.out.println(brand + \" car started\");\n    }\n    \n    @Override\n    public void drive() {\n        System.out.println(\"Driving \" + brand);\n    }\n}",
          "companies": ["Amazon", "Google", "Microsoft", "Oracle", "SAP", "Adobe"],
          "topic": "OOP Concepts",
          "followUp": ["When would you choose abstract class over interface?", "Can an interface extend another interface?", "What are marker interfaces?"]
        },
        {
          "id": "java-core-005",
          "question": "Explain method overloading vs method overriding with examples",
          "difficulty": "Basic",
          "experienceLevel": ["0-2", "3-5"],
          "answer": "Overloading (Compile-time polymorphism): Same method name, different parameters (number, type, or order) in the same class. Overriding (Runtime polymorphism): Same method signature in parent and child class. Child class provides specific implementation of parent's method. Overloading is resolved at compile time, overriding at runtime.",
          "code": "// Method Overloading\nclass Calculator {\n    int add(int a, int b) {\n        return a + b;\n    }\n    \n    int add(int a, int b, int c) {\n        return a + b + c;\n    }\n    \n    double add(double a, double b) {\n        return a + b;\n    }\n}\n\n// Method Overriding\nclass Animal {\n    void sound() {\n        System.out.println(\"Animal makes sound\");\n    }\n}\n\nclass Dog extends Animal {\n    @Override\n    void sound() {\n        System.out.println(\"Dog barks\");\n    }\n}\n\n// Usage\nAnimal animal = new Dog();\nanimal.sound();  // Output: Dog barks (Runtime polymorphism)",
          "companies": ["Infosys", "TCS", "Wipro", "Cognizant", "HCL", "Tech Mahindra"],
          "topic": "Polymorphism",
          "followUp": ["Can we overload main method?", "Can we override static methods?", "What is covariant return type?"]
        },
        {
          "id": "java-core-006",
          "question": "What are Collections in Java? Explain List, Set, and Map with differences",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "Collections Framework provides architecture to store and manipulate groups of objects. List: Ordered collection, allows duplicates (ArrayList, LinkedList, Vector). Set: Unordered collection, no duplicates (HashSet, TreeSet, LinkedHashSet). Map: Key-value pairs, no duplicate keys (HashMap, TreeMap, LinkedHashMap). List maintains insertion order, Set doesn't allow duplicates, Map stores key-value associations.",
          "code": "// List - Ordered, allows duplicates\nList<String> list = new ArrayList<>();\nlist.add(\"Java\");\nlist.add(\"Python\");\nlist.add(\"Java\");  // Duplicate allowed\nSystem.out.println(list);  // [Java, Python, Java]\n\n// Set - No duplicates\nSet<String> set = new HashSet<>();\nset.add(\"Java\");\nset.add(\"Python\");\nset.add(\"Java\");  // Duplicate ignored\nSystem.out.println(set);  // [Java, Python]\n\n// Map - Key-value pairs\nMap<String, Integer> map = new HashMap<>();\nmap.put(\"Java\", 1);\nmap.put(\"Python\", 2);\nmap.put(\"Java\", 3);  // Overrides previous value\nSystem.out.println(map);  // {Java=3, Python=2}",
          "companies": ["Google", "Microsoft", "Amazon", "Adobe", "Oracle", "Salesforce"],
          "topic": "Collections Framework",
          "followUp": ["Explain ArrayList vs LinkedList in detail", "How does HashMap work internally?", "What is the difference between HashSet and TreeSet?"]
        },
        {
          "id": "java-core-007",
          "question": "Explain ArrayList vs LinkedList - when to use which?",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "ArrayList uses dynamic array internally - better for random access O(1), slower for insertions/deletions O(n) in middle. LinkedList uses doubly-linked list - slower for random access O(n), faster for insertions/deletions O(1) at beginning/end. Use ArrayList when: frequent access/search operations. Use LinkedList when: frequent insertions/deletions, implementing queue/deque.",
          "code": "// ArrayList - Fast access, slow insertion\nArrayList<String> arrayList = new ArrayList<>();\narrayList.add(\"A\");  // O(1) amortized\narrayList.get(2);    // O(1) access\narrayList.add(1, \"B\");  // O(n) insertion in middle\n\n// LinkedList - Slow access, fast insertion\nLinkedList<String> linkedList = new LinkedList<>();\nlinkedList.addFirst(\"A\");  // O(1)\nlinkedList.addLast(\"B\");   // O(1)\nlinkedList.get(2);         // O(n) access\n\n// Performance Comparison\nlong start = System.currentTimeMillis();\nfor (int i = 0; i < 100000; i++) {\n    arrayList.get(i % arrayList.size());  // Fast\n}\nlong end = System.currentTimeMillis();\nSystem.out.println(\"ArrayList access: \" + (end - start) + \"ms\");",
          "companies": ["Amazon", "Flipkart", "Google", "Microsoft", "Uber", "Ola"],
          "topic": "Collections Performance",
          "followUp": ["What is the time complexity of remove() in ArrayList?", "How does ArrayList grow when it reaches capacity?", "What is Vector and how is it different from ArrayList?"]
        },
        {
          "id": "java-core-008",
          "question": "How does HashMap work internally? Explain hashing, collisions, and Java 8 improvements",
          "difficulty": "Hard",
          "experienceLevel": ["6-8", "9-12"],
          "answer": "HashMap uses array of buckets. Each key's hashCode() determines bucket index. Collisions (same index) handled by linked list/tree. Process: 1) Calculate hashCode() 2) Apply hash function 3) Find bucket index 4) Check equals() for key match. Java 8 improvement: When bucket size > 8, linked list converts to balanced tree (O(log n) instead of O(n)). Default capacity: 16, load factor: 0.75.",
          "code": "// HashMap Internal Structure\nclass HashMapDemo {\n    public static void main(String[] args) {\n        HashMap<String, Integer> map = new HashMap<>();\n        \n        // put() operation\n        map.put(\"John\", 25);  // 1. hashCode() of \"John\"\n                               // 2. Calculate index: hash % capacity\n                               // 3. Check if key exists using equals()\n                               // 4. If exists, replace value\n                               // 5. Else, add new entry\n        \n        // get() operation\n        Integer age = map.get(\"John\");  // 1. hashCode() of \"John\"\n                                         // 2. Find bucket\n                                         // 3. Traverse linked list/tree\n                                         // 4. Return value if key matches\n        \n        // Collision Example\n        map.put(\"John\", 25);\n        map.put(\"Jane\", 30);  // May hash to same bucket\n    }\n}\n\n// Custom Object as Key\nclass Employee {\n    int id;\n    String name;\n    \n    @Override\n    public int hashCode() {\n        return Objects.hash(id, name);\n    }\n    \n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) return true;\n        if (obj == null || getClass() != obj.getClass()) return false;\n        Employee emp = (Employee) obj;\n        return id == emp.id && Objects.equals(name, emp.name);\n    }\n}",
          "companies": ["Google", "Amazon", "Microsoft", "Adobe", "Salesforce", "Oracle"],
          "topic": "HashMap Internals",
          "followUp": ["What happens if two keys have the same hashCode()?", "Why must we override both hashCode() and equals()?", "What is the difference between HashMap and ConcurrentHashMap?"]
        },
        {
          "id": "java-core-009",
          "question": "Explain exception handling in Java - checked vs unchecked exceptions, try-catch-finally",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "Exception handling uses try-catch-finally blocks. Checked exceptions (compile-time) must be caught or declared - IOException, SQLException. Unchecked exceptions (runtime) are subclasses of RuntimeException - NullPointerException, ArrayIndexOutOfBoundsException. Finally block always executes (even if exception occurs or return statement). Try-with-resources (Java 7+) auto-closes resources.",
          "code": "// Checked Exception\npublic void readFile() throws IOException {\n    try {\n        FileReader file = new FileReader(\"file.txt\");\n        BufferedReader reader = new BufferedReader(file);\n        System.out.println(reader.readLine());\n    } catch (FileNotFoundException e) {\n        System.out.println(\"File not found: \" + e.getMessage());\n    } catch (IOException e) {\n        System.out.println(\"Error reading file: \" + e.getMessage());\n    } finally {\n        System.out.println(\"Always executes\");\n    }\n}\n\n// Unchecked Exception\npublic int divide(int a, int b) {\n    try {\n        return a / b;\n    } catch (ArithmeticException e) {\n        System.out.println(\"Division by zero\");\n        return 0;\n    }\n}\n\n// Custom Exception\nclass InvalidAgeException extends Exception {\n    public InvalidAgeException(String message) {\n        super(message);\n    }\n}\n\npublic void validateAge(int age) throws InvalidAgeException {\n    if (age < 18) {\n        throw new InvalidAgeException(\"Age must be 18 or above\");\n    }\n}\n\n// Try-with-resources\npublic void readFileNew() {\n    try (BufferedReader reader = new BufferedReader(new FileReader(\"file.txt\"))) {\n        System.out.println(reader.readLine());\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n    // Reader automatically closed\n}",
          "companies": ["Capgemini", "HCL", "Tech Mahindra", "LTI", "Mindtree", "L&T Infotech"],
          "topic": "Exception Handling",
          "followUp": ["What is the difference between throw and throws?", "Can we have try without catch?", "Can finally block be skipped?"]
        },
        {
          "id": "java-core-010",
          "question": "What is multithreading? Explain thread lifecycle, creation methods, and synchronization",
          "difficulty": "Hard",
          "experienceLevel": ["6-8", "9-12"],
          "answer": "Multithreading allows concurrent execution of multiple parts of a program. Thread lifecycle: New → Runnable → Running → Blocked/Waiting → Terminated. Creation: 1) Extend Thread class, 2) Implement Runnable, 3) Implement Callable, 4) ExecutorService. Synchronization prevents thread interference using synchronized keyword or locks. Critical section accessed by one thread at a time.",
          "code": "// Method 1: Extend Thread\nclass MyThread extends Thread {\n    public void run() {\n        System.out.println(\"Thread running: \" + Thread.currentThread().getName());\n    }\n}\n\n// Method 2: Implement Runnable\nclass MyRunnable implements Runnable {\n    public void run() {\n        System.out.println(\"Runnable running: \" + Thread.currentThread().getName());\n    }\n}\n\n// Method 3: Implement Callable\nclass MyCallable implements Callable<Integer> {\n    public Integer call() {\n        return 42;\n    }\n}\n\n// Synchronization\nclass Counter {\n    private int count = 0;\n    \n    public synchronized void increment() {\n        count++;\n    }\n    \n    public int getCount() {\n        return count;\n    }\n}\n\n// Using ExecutorService\npublic class ThreadDemo {\n    public static void main(String[] args) {\n        // Method 1\n        MyThread thread1 = new MyThread();\n        thread1.start();\n        \n        // Method 2\n        Thread thread2 = new Thread(new MyRunnable());\n        thread2.start();\n        \n        // Method 3 & 4: ExecutorService\n        ExecutorService executor = Executors.newFixedThreadPool(5);\n        Future<Integer> future = executor.submit(new MyCallable());\n        \n        executor.submit(() -> {\n            System.out.println(\"Lambda runnable\");\n        });\n        \n        executor.shutdown();\n    }\n}",
          "companies": ["Google", "Amazon", "Microsoft", "Uber", "Walmart Labs", "Netflix"],
          "topic": "Multithreading",
          "followUp": ["Explain deadlock and how to prevent it", "What is ThreadLocal?", "Difference between wait() and sleep()?"]
        }
      ]
    }
  ]
}
