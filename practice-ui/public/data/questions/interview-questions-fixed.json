{
  "version": "3.0.0",
  "lastUpdated": "2024-12-19",
  "totalQuestions": 81,
  "description": "Comprehensive Interview questions database for QA Automation Engineers - Enhanced with TestNG and Framework Design",
  "note": "Comprehensive question bank covering Java, Selenium, TestNG Framework, and Test Framework Design for all experience levels.",
  "categories": [
    {
      "id": "java",
      "name": "Java Programming",
      "icon": "‚òï",
      "totalQuestions": 5,
      "questions": [
        {
          "id": "java-001",
          "question": "Explain the difference between == and .equals() in Java",
          "difficulty": "Medium",
          "experienceLevel": ["0-2", "3-5"],
          "answer": "== compares references (memory addresses) while .equals() compares object content. For primitives, == compares values. String literals with same value may share memory (interning), but new String() creates new objects.",
          "companies": ["All Java applications", "Banking", "E-commerce"],
          "topic": "Java Fundamentals",
          "followUp": ["java-006", "java-007"]
        },
        {
          "id": "java-002",
          "question": "What is the difference between String, StringBuilder, and StringBuffer?",
          "difficulty": "Medium",
          "experienceLevel": ["0-2", "3-5"],
          "answer": "String is immutable - creates new objects on modification. StringBuilder is mutable and not thread-safe, best for single-threaded string building. StringBuffer is mutable and thread-safe but slower due to synchronization.",
          "companies": ["Performance-critical applications", "Banking", "Real-time systems"],
          "topic": "Java Fundamentals",
          "followUp": ["java-008", "java-009"]
        },
        {
          "id": "java-003",
          "question": "Explain Java exception handling and the difference between checked and unchecked exceptions",
          "difficulty": "Medium",
          "experienceLevel": ["0-2", "3-5"],
          "answer": "Exception handling manages runtime errors using try-catch-finally blocks. Checked exceptions (compile-time) must be caught or declared (IOException, SQLException). Unchecked exceptions (runtime) don't require explicit handling (NullPointerException, ArrayIndexOutOfBoundsException).",
          "companies": ["All Java applications", "Banking", "Healthcare", "E-commerce"],
          "topic": "Exception Handling",
          "followUp": ["java-010", "java-011"]
        },
        {
          "id": "java-004",
          "question": "What are Java Collections and explain the difference between List, Set, and Map",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "Collections framework provides data structures. List allows duplicates and maintains order (ArrayList, LinkedList). Set doesn't allow duplicates (HashSet, TreeSet). Map stores key-value pairs (HashMap, TreeMap). Choose based on use case: ArrayList for random access, LinkedList for frequent insertions, HashMap for key lookups.",
          "companies": ["All Java applications", "Data processing", "Enterprise applications"],
          "topic": "Collections",
          "followUp": ["java-012", "java-013"]
        },
        {
          "id": "java-005",
          "question": "Explain Java multithreading and synchronization",
          "difficulty": "Hard",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "Multithreading allows concurrent execution. Create threads by extending Thread or implementing Runnable. Synchronization prevents race conditions using synchronized keyword, locks, or concurrent collections. Thread states: NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED.",
          "companies": ["High-performance applications", "Real-time systems", "Banking"],
          "topic": "Multithreading",
          "followUp": ["java-014", "java-015"]
        },
        {
          "id": "java-006",
          "question": "What is String interning?",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "String interning is a method of storing only one copy of each distinct string value in memory. In Java, strings are stored in the String Pool (part of heap memory). When you create a string literal, JVM checks if an identical string already exists in the pool. If yes, it returns the reference to the existing string; otherwise, it creates a new string in the pool. You can manually intern strings using the intern() method. This saves memory but can impact performance if overused.",
          "companies": ["Memory optimization", "Performance tuning", "Large-scale applications"],
          "topic": "Java Fundamentals",
          "followUp": []
        },
        {
          "id": "java-007",
          "question": "When should you override equals()?",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "Override equals() when you need logical equality instead of reference equality. Required for: 1) Using objects as keys in HashMap/HashSet, 2) Comparing objects based on their content/state, 3) Working with collections that use equals() for searching. When overriding equals(), also override hashCode() to maintain the contract: objects that are equal must have the same hash code. Follow the equals() contract: reflexive, symmetric, transitive, consistent, and null-safe.",
          "companies": ["Object-oriented design", "Collections usage", "Framework development"],
          "topic": "Java Fundamentals",
          "followUp": []
        },
        {
          "id": "java-008",
          "question": "When would you use String, StringBuilder, or StringBuffer?",
          "difficulty": "Easy",
          "experienceLevel": ["0-2", "3-5"],
          "answer": "Use String for: immutable text, small number of concatenations, thread safety not a concern. Use StringBuilder for: heavy string manipulation, single-threaded environment, performance-critical string building. Use StringBuffer for: heavy string manipulation in multi-threaded environment, when thread safety is required. StringBuilder is faster than StringBuffer due to no synchronization overhead. String concatenation with + operator creates new objects, inefficient for loops.",
          "companies": ["Performance optimization", "String manipulation", "Multi-threaded applications"],
          "topic": "Java Fundamentals",
          "followUp": []
        },
        {
          "id": "java-009",
          "question": "What is string immutability?",
          "difficulty": "Easy",
          "experienceLevel": ["0-2", "3-5"],
          "answer": "String immutability means that once a String object is created, its value cannot be changed. Any operation that appears to modify a string actually creates a new String object. Benefits: 1) Thread safety - multiple threads can access immutable objects safely, 2) Security - string values cannot be changed after creation, 3) Caching - hashcode can be cached, 4) String pool optimization. Drawbacks: memory overhead when doing many string operations, which is why StringBuilder/StringBuffer exist for mutable string operations.",
          "companies": ["Thread safety", "Memory management", "Security"],
          "topic": "Java Fundamentals",
          "followUp": []
        },
        {
          "id": "java-010",
          "question": "What is try-with-resources?",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "Try-with-resources is a try statement that declares one or more resources automatically closed at the end of the statement. Introduced in Java 7. Syntax: try (FileReader fr = new FileReader(file)) { // use resource }. Resources must implement AutoCloseable interface. Benefits: 1) Automatic resource cleanup, 2) No explicit finally block needed, 3) Handles multiple resources, 4) Exception suppression if both try and close throw exceptions. Multiple resources separated by semicolons.",
          "companies": ["Resource management", "File handling", "Database connections"],
          "topic": "Exception Handling",
          "followUp": []
        },
        {
          "id": "java-011",
          "question": "When should you create custom exceptions?",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "Create custom exceptions when: 1) You need specific error information not provided by existing exceptions, 2) You want to group related exceptions under a common hierarchy, 3) You need to add additional data/methods to exceptions, 4) You want better error handling granularity, 5) Domain-specific errors that need special handling. Extend Exception for checked exceptions, RuntimeException for unchecked. Include meaningful error messages, cause chaining, and additional context data.",
          "companies": ["Enterprise applications", "API development", "Framework design"],
          "topic": "Exception Handling",
          "followUp": []
        },
        {
          "id": "java-012",
          "question": "What's the difference between ArrayList and LinkedList?",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "ArrayList: Array-based, O(1) random access, O(1) add at end, O(n) insert/delete at middle, better cache locality, less memory per element. LinkedList: Doubly-linked list, O(n) random access, O(1) insert/delete at known position, O(1) add at beginning/end, more memory per element due to node overhead. Use ArrayList for: frequent random access, iteration, small lists. Use LinkedList for: frequent insertions/deletions, queue/deque operations, when you don't need random access.",
          "companies": ["Algorithm optimization", "Data structure design", "Performance tuning"],
          "topic": "Collections",
          "followUp": []
        },
        {
          "id": "java-013",
          "question": "When to use HashMap vs TreeMap?",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "HashMap: Hash table based, O(1) average access time, no ordering, allows null key/values, not thread-safe, better performance. TreeMap: Red-black tree based, O(log n) access time, maintains sorted order, no null keys, implements NavigableMap with range operations. Use HashMap for: fast lookups, no ordering needed, general-purpose mapping. Use TreeMap for: sorted keys, range queries, natural ordering needed, NavigableMap operations like subMap(), headMap(), tailMap().",
          "companies": ["Data structure optimization", "Sorted data requirements", "Performance-critical applications"],
          "topic": "Collections",
          "followUp": []
        },
        {
          "id": "java-014",
          "question": "What is deadlock and how to prevent it?",
          "difficulty": "Hard",
          "experienceLevel": ["6-8", "9+"],
          "answer": "Deadlock occurs when two or more threads wait indefinitely for each other to release resources. Conditions: 1) Mutual exclusion, 2) Hold and wait, 3) No preemption, 4) Circular wait. Prevention techniques: 1) Always acquire locks in same order, 2) Use timeout with tryLock(), 3) Avoid nested locks, 4) Use concurrent collections, 5) Use higher-level concurrency utilities (CountDownLatch, Semaphore). Detection: ThreadMXBean, VisualVM, jstack. Recovery: interrupt threads, use deadlock detection algorithms.",
          "companies": ["Multi-threaded applications", "Concurrent programming", "High-performance systems"],
          "topic": "Multithreading",
          "followUp": []
        },
        {
          "id": "java-015",
          "question": "Explain volatile keyword",
          "difficulty": "Hard",
          "experienceLevel": ["6-8", "9+"],
          "answer": "Volatile ensures visibility of changes to a variable across threads. When a variable is declared volatile: 1) Reads/writes go directly to main memory, not CPU cache, 2) Prevents instruction reordering around volatile operations, 3) Guarantees happens-before relationship. Use cases: flags, status indicators, single-writer multiple-reader scenarios. Limitations: not atomic for compound operations (i++), doesn't provide mutual exclusion. Volatile is lighter than synchronized but provides weaker guarantees.",
          "companies": ["Concurrent programming", "Lock-free algorithms", "Performance optimization"],
          "topic": "Multithreading",
          "followUp": []
        }
      ]
    },
    {
      "id": "selenium",
      "name": "Selenium WebDriver",
      "icon": "üåê",
      "totalQuestions": 9,
      "questions": [
        {
          "id": "selenium-001",
          "question": "What is Selenium WebDriver and how does it work?",
          "difficulty": "Easy",
          "experienceLevel": ["0-2", "3-5"],
          "answer": "Selenium WebDriver is a web automation tool that controls browsers programmatically. It sends HTTP requests to browser drivers (ChromeDriver, GeckoDriver) which translate commands to browser-specific actions. Supports multiple languages and browsers.",
          "companies": ["QA teams", "Automation companies", "E-commerce"],
          "topic": "Selenium Basics",
          "followUp": ["selenium-004", "selenium-005"]
        },
        {
          "id": "selenium-002",
          "question": "Explain different types of waits in Selenium",
          "difficulty": "Medium",
          "experienceLevel": ["0-2", "3-5"],
          "answer": "Implicit Wait: Global timeout for element location. Explicit Wait: Wait for specific conditions using WebDriverWait and ExpectedConditions. Fluent Wait: Configurable polling interval and exceptions to ignore. Avoid Thread.sleep() as it's not dynamic.",
          "companies": ["Automation testing", "Web applications", "E-commerce"],
          "topic": "Selenium Waits",
          "followUp": ["selenium-006", "selenium-007"]
        },
        {
          "id": "selenium-003",
          "question": "How do you handle dynamic elements and synchronization issues?",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "Use explicit waits with expected conditions, implement custom wait conditions, use fluent waits for complex scenarios. Handle AJAX with WebDriverWait. For SPAs, wait for specific elements or JavaScript completion. Implement retry mechanisms and proper exception handling.",
          "companies": ["Modern web applications", "SPA testing", "Complex UI testing"],
          "topic": "Advanced Selenium",
          "followUp": ["selenium-008", "selenium-009"]
        },
        {
          "id": "selenium-004",
          "question": "What are the different Selenium components?",
          "difficulty": "Easy",
          "experienceLevel": ["0-2", "3-5"],
          "answer": "Selenium suite consists of: 1) Selenium WebDriver - for browser automation, 2) Selenium IDE - record and playback tool for Firefox/Chrome, 3) Selenium Grid - for parallel execution across multiple machines/browsers, 4) Selenium RC (deprecated) - original remote control approach. WebDriver is the most commonly used component for test automation, providing direct browser communication without external server.",
          "companies": ["All automation companies", "QA teams", "Testing frameworks"],
          "topic": "Selenium Basics",
          "followUp": []
        },
        {
          "id": "selenium-005",
          "question": "How do you handle different browsers in Selenium?",
          "difficulty": "Medium",
          "experienceLevel": ["0-2", "3-5"],
          "answer": "Use WebDriverManager or manually download browser drivers. Create WebDriver instances: ChromeDriver, FirefoxDriver, SafariDriver, EdgeDriver. Set browser-specific capabilities using DesiredCapabilities or Options classes. Use WebDriverFactory pattern for cross-browser testing. Configure headless mode for CI/CD. Handle browser-specific behaviors with conditional logic based on driver type.",
          "companies": ["Cross-browser testing", "Multi-environment testing", "CI/CD pipelines"],
          "topic": "Browser Management",
          "followUp": []
        },
        {
          "id": "selenium-006",
          "question": "When would you use each type of wait?",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "Implicit Wait: Use for global timeout when elements are consistently slow to load. Set once, applies to all elements. Explicit Wait: Use for specific conditions like element visibility, clickability, or text presence. More reliable than implicit. Fluent Wait: Use when you need custom polling intervals, specific exceptions to ignore, or complex wait conditions. Avoid Thread.sleep() as it's static and inefficient.",
          "companies": ["Dynamic applications", "AJAX-heavy sites", "Performance testing"],
          "topic": "Wait Strategies",
          "followUp": []
        },
        {
          "id": "selenium-007",
          "question": "How do you handle dynamic elements?",
          "difficulty": "Hard",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "Use robust locator strategies: XPath with contains(), starts-with(), CSS selectors with partial attribute matching. Implement WebDriverWait with ExpectedConditions. Use dynamic XPath with variables. Implement retry mechanisms for stale elements. Handle elements that change attributes/properties. Use JavaScript executor for complex scenarios. Implement Page Object Model with dynamic element factories.",
          "companies": ["Modern web applications", "SPA testing", "Dynamic content sites"],
          "topic": "Dynamic Elements",
          "followUp": []
        },
        {
          "id": "selenium-008",
          "question": "How do you test single-page applications?",
          "difficulty": "Hard",
          "experienceLevel": ["6-8", "9+"],
          "answer": "Wait for JavaScript execution completion using JavaScriptExecutor. Monitor AJAX requests with custom waits. Handle route changes without page refresh. Use explicit waits for DOM updates. Implement custom ExpectedConditions for SPA states. Handle virtual DOM frameworks like React/Angular with component-specific waits. Use browser developer tools to understand application lifecycle. Implement helper methods for SPA navigation patterns.",
          "companies": ["Modern web frameworks", "React/Angular testing", "Progressive web apps"],
          "topic": "SPA Testing",
          "followUp": []
        },
        {
          "id": "selenium-009",
          "question": "What are Page Object Models?",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "Page Object Model (POM) is a design pattern that creates object repository for web elements. Each page class represents a web page with its elements and actions. Benefits: code reusability, maintainability, reduced duplication. Use @FindBy annotations with PageFactory for element initialization. Implement BasePage class for common functionality. Follow single responsibility principle - one class per page. Return new page objects from action methods for method chaining.",
          "companies": ["Maintainable test frameworks", "Large-scale automation", "Team collaboration"],
          "topic": "Design Patterns",
          "followUp": []
        }
      ]
    },
    {
      "id": "testng",
      "name": "TestNG Framework",
      "icon": "üß™",
      "totalQuestions": 46,
      "questions": [
        {
          "id": "testng-001",
          "question": "What is TestNG and what are its key advantages over JUnit?",
          "difficulty": "Easy",
          "experienceLevel": ["0-2", "3-5"],
          "answer": "TestNG (Test Next Generation) is a testing framework inspired by JUnit and NUnit, designed to cover all categories of tests: unit, functional, end-to-end, integration, etc. Key advantages: 1) Annotations for better test configuration (@BeforeSuite, @BeforeTest, @BeforeClass, @BeforeMethod), 2) Parallel execution support, 3) Data-driven testing with @DataProvider, 4) Test dependencies with dependsOnMethods, 5) Grouping tests, 6) Built-in reporting, 7) Flexible test configuration with XML files, 8) Support for parameters and multiple test instances.",
          "companies": ["All automation companies", "TCS", "Infosys", "Wipro", "Accenture"],
          "topic": "TestNG Basics",
          "followUp": ["testng-011", "testng-012"]
        },
        {
          "id": "testng-002",
          "question": "Explain the hierarchy and execution order of TestNG annotations",
          "difficulty": "Medium",
          "experienceLevel": ["0-2", "3-5"],
          "answer": "TestNG annotations execute in this order: @BeforeSuite ‚Üí @BeforeTest ‚Üí @BeforeClass ‚Üí @BeforeMethod ‚Üí @Test ‚Üí @AfterMethod ‚Üí @AfterClass ‚Üí @AfterTest ‚Üí @AfterSuite. Suite level runs once per suite, Test level runs once per <test> tag, Class level runs once per test class, Method level runs before/after each test method. This hierarchy ensures proper setup and teardown at different levels of test execution.",
          "companies": ["Automation frameworks", "Banking", "E-commerce", "Healthcare"],
          "topic": "TestNG Annotations",
          "followUp": ["What happens if multiple classes have @BeforeClass?", "How to handle exceptions in setup methods?"]
        },
        {
          "id": "testng-003",
          "question": "How do you implement data-driven testing using @DataProvider in TestNG?",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "@DataProvider supplies data to test methods. Example: @DataProvider(name=\"loginData\") public Object[][] getData() { return new Object[][]{{\"user1\",\"pass1\"},{\"user2\",\"pass2\"}}; } @Test(dataProvider=\"loginData\") public void testLogin(String user, String pass) { //test logic }. DataProvider can read from Excel, CSV, database, or return arrays/iterators. Supports parallel execution with parallel=true parameter. Can be in same class or external class using dataProviderClass attribute.",
          "companies": ["Data-heavy applications", "Banking", "Insurance", "E-commerce"],
          "topic": "Data-Driven Testing",
          "followUp": ["How to read data from Excel files?", "How to handle large datasets efficiently?"]
        },
        {
          "id": "testng-004",
          "question": "How do you configure parallel execution in TestNG and what are the different levels?",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "TestNG supports parallel execution at multiple levels: 1) parallel=\"tests\" - different <test> tags run in parallel, 2) parallel=\"classes\" - test classes run in parallel, 3) parallel=\"methods\" - test methods run in parallel, 4) parallel=\"instances\" - instances of same test class run in parallel. Configure in testng.xml: <suite parallel=\"methods\" thread-count=\"5\">. Use ThreadLocal for WebDriver to ensure thread safety. Set data-provider-thread-count for DataProvider parallelization.",
          "companies": ["Performance testing", "Large test suites", "CI/CD pipelines"],
          "topic": "Parallel Execution",
          "followUp": ["How to handle shared resources in parallel execution?", "What is ThreadLocal and why is it important?"]
        },
        {
          "id": "testng-005",
          "question": "Explain test dependencies in TestNG using dependsOnMethods and dependsOnGroups",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "Test dependencies ensure tests run in specific order. dependsOnMethods: @Test(dependsOnMethods=\"loginTest\") - current test runs only if loginTest passes. dependsOnGroups: @Test(dependsOnGroups=\"smoke\") - runs after all tests in 'smoke' group complete. If dependency fails, dependent tests are skipped. Use alwaysRun=true to run dependent tests even if dependencies fail. Hard dependencies (default) vs soft dependencies with ignoreMissingDependencies=true.",
          "companies": ["Integration testing", "End-to-end testing", "Workflow testing"],
          "topic": "Test Dependencies",
          "followUp": ["What happens when a dependency test fails?", "How to handle circular dependencies?"]
        },
        {
          "id": "testng-006",
          "question": "How do you group tests in TestNG and run specific groups?",
          "difficulty": "Easy",
          "experienceLevel": ["0-2", "3-5"],
          "answer": "Group tests using @Test(groups={\"smoke\", \"regression\"}). Run specific groups in testng.xml: <groups><run><include name=\"smoke\"/></run></groups>. Groups can be nested and inherited. Use @BeforeGroups/@AfterGroups for group-level setup/teardown. Command line: mvn test -Dgroups=\"smoke,regression\". Groups help organize tests by functionality, priority, or execution environment (smoke, regression, sanity, etc.).",
          "companies": ["Test organization", "CI/CD", "Release testing"],
          "topic": "Test Grouping",
          "followUp": ["How to exclude certain groups?", "Can a test belong to multiple groups?"]
        },
        {
          "id": "testng-007",
          "question": "What are TestNG listeners and how do you implement custom listeners?",
          "difficulty": "Hard",
          "experienceLevel": ["6-8", "9-12"],
          "answer": "TestNG listeners respond to events during test execution. Types: ITestListener (test events), ISuiteListener (suite events), IReporter (custom reporting), IAnnotationTransformer (modify annotations at runtime). Implement: public class CustomListener implements ITestListener { public void onTestStart(ITestResult result) { //logic } }. Register via @Listeners({CustomListener.class}) or testng.xml <listeners><listener class-name=\"CustomListener\"/></listeners>. Use for screenshots on failure, custom reporting, test retry logic.",
          "companies": ["Advanced frameworks", "Custom reporting", "Test monitoring"],
          "topic": "TestNG Listeners",
          "followUp": ["How to take screenshots on test failure?", "What is IRetryAnalyzer?"]
        },
        {
          "id": "testng-008",
          "question": "How do you implement test retry mechanism using IRetryAnalyzer in TestNG?",
          "difficulty": "Hard",
          "experienceLevel": ["6-8", "9-12"],
          "answer": "IRetryAnalyzer retries failed tests. Implement: public class RetryAnalyzer implements IRetryAnalyzer { private int count = 0; private int maxTry = 2; public boolean retry(ITestResult result) { if(count < maxTry) { count++; return true; } return false; } }. Use: @Test(retryAnalyzer = RetryAnalyzer.class). For all tests, use IAnnotationTransformer to set retry analyzer globally. Helps handle flaky tests but should be used judiciously.",
          "companies": ["Flaky test handling", "Stable automation", "Production frameworks"],
          "topic": "Test Retry",
          "followUp": ["When should you use retry mechanism?", "How to implement global retry for all tests?"]
        },
        {
          "id": "testng-009",
          "question": "Explain TestNG XML configuration and its key elements",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "TestNG XML configures test execution. Key elements: <suite> (top level, defines parallel execution), <test> (logical grouping), <classes>/<methods> (specify what to run), <groups> (include/exclude groups), <parameter> (pass parameters). Example: <suite name=\"TestSuite\" parallel=\"methods\" thread-count=\"3\"><test name=\"SmokeTest\"><classes><class name=\"LoginTest\"/></classes></test></suite>. Supports multiple test tags, package inclusion, method selection, and parameter passing.",
          "companies": ["Test configuration", "CI/CD", "Multiple environments"],
          "topic": "TestNG XML",
          "followUp": ["How to pass parameters from XML to tests?", "How to run different XML files for different environments?"]
        },
        {
          "id": "testng-010",
          "question": "How do you pass parameters to TestNG tests using @Parameters annotation?",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "Use @Parameters to pass values from testng.xml to test methods. XML: <parameter name=\"browser\" value=\"chrome\"/>. Test: @Parameters({\"browser\"}) @Test public void testLogin(String browser) { //use browser }. Parameters can be defined at suite, test, or class level. For optional parameters, provide default values. Combine with @DataProvider for complex data scenarios. Useful for environment-specific configurations, browser selection, URLs, etc.",
          "companies": ["Multi-environment testing", "Cross-browser testing", "Configuration management"],
          "topic": "Test Parameters",
          "followUp": ["How to handle optional parameters?", "Can parameters be passed to @DataProvider methods?"]
        },
        {
          "id": "testng-011",
          "question": "What are TestNG annotations hierarchy?",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "TestNG annotations execute in hierarchical order: @BeforeSuite (once per suite) ‚Üí @BeforeTest (once per <test> tag) ‚Üí @BeforeClass (once per test class) ‚Üí @BeforeMethod (before each test method) ‚Üí @Test ‚Üí @AfterMethod ‚Üí @AfterClass ‚Üí @AfterTest ‚Üí @AfterSuite. Groups: @BeforeGroups/@AfterGroups run before/after group execution. Each level has specific scope and execution context, enabling proper setup and cleanup at different granularities.",
          "companies": ["Test framework design", "Automation architecture", "Setup/teardown management"],
          "topic": "TestNG Annotations",
          "followUp": []
        },
        {
          "id": "testng-012",
          "question": "How does TestNG XML configuration work?",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "TestNG XML (testng.xml) configures test execution: <suite> defines test suite with parallel execution settings, <test> groups related classes, <classes> specifies which test classes to run, <methods> includes/excludes specific methods, <groups> defines group inclusion/exclusion, <parameters> pass runtime values. Supports multiple test tags, package inclusion, method-level control, and parameter injection. Essential for CI/CD integration and environment-specific test execution.",
          "companies": ["CI/CD pipelines", "Test execution management", "Environment configuration"],
          "topic": "TestNG XML",
          "followUp": []
        },
        {
          "id": "testng-013",
          "question": "What happens if multiple classes have @BeforeClass?",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "Each @BeforeClass method runs once before its respective class's test methods execute. If multiple classes are in same test, each @BeforeClass runs before its class tests. Execution order depends on class loading order (not guaranteed). Use @BeforeTest for shared setup across classes, @BeforeSuite for suite-wide setup. For controlled order, use dependsOnMethods or priority attributes. Consider using inheritance with base test class for common setup.",
          "companies": ["Multi-class test suites", "Setup management", "Test organization"],
          "topic": "TestNG Annotations",
          "followUp": []
        },
        {
          "id": "testng-014",
          "question": "How to handle exceptions in setup methods?",
          "difficulty": "Hard",
          "experienceLevel": ["6-8", "9+"],
          "answer": "Setup method exceptions skip dependent tests. Use try-catch blocks with proper logging and cleanup. Implement configuration failure policy with configfailurepolicy=\"continue\" in testng.xml. Use soft assertions for non-critical setup. Implement retry mechanism for flaky setup operations. Create fallback configurations for environment issues. Use IConfigurationListener to handle setup failures gracefully and provide meaningful error reports.",
          "companies": ["Robust test frameworks", "Error handling", "Test reliability"],
          "topic": "Exception Handling",
          "followUp": []
        },
        {
          "id": "testng-015",
          "question": "How to read data from Excel files?",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "Use Apache POI library: Create Workbook (XSSFWorkbook for .xlsx, HSSFWorkbook for .xls), get Sheet by index/name, iterate through Rows and Cells. Handle different cell types (STRING, NUMERIC, BOOLEAN). Create utility class with methods like getCellData(), getRowCount(). Implement data provider that reads from Excel: @DataProvider returns Object[][] from Excel data. Handle file paths, sheet names, and data ranges as parameters.",
          "companies": ["Data-driven testing", "Excel integration", "Test data management"],
          "topic": "Data-Driven Testing",
          "followUp": []
        },
        {
          "id": "testng-016",
          "question": "How to handle large datasets efficiently?",
          "difficulty": "Hard",
          "experienceLevel": ["6-8", "9+"],
          "answer": "Use Iterator<Object[]> instead of Object[][] for large datasets to avoid memory issues. Implement lazy loading with Iterator pattern. Use streaming APIs for file reading. Implement data chunking for parallel execution. Cache frequently used data. Use database connection pooling for DB-driven tests. Implement data filtering at source level. Use @Factory for test instance creation with different data sets. Consider using TestNG's @DataProvider(parallel=true) for parallel data processing.",
          "companies": ["Performance testing", "Large-scale automation", "Memory optimization"],
          "topic": "Data-Driven Testing",
          "followUp": []
        },
        {
          "id": "testng-017",
          "question": "How to handle shared resources in parallel execution?",
          "difficulty": "Hard",
          "experienceLevel": ["6-8", "9+"],
          "answer": "Use ThreadLocal for WebDriver instances to ensure thread safety. Implement thread-safe singleton patterns for shared utilities. Use concurrent collections (ConcurrentHashMap, CopyOnWriteArrayList). Synchronize access to shared resources with synchronized blocks/methods. Use separate test data for each thread. Implement resource pooling for database connections. Use @BeforeMethod/@AfterMethod for thread-specific setup/cleanup. Avoid shared state between test methods.",
          "companies": ["Parallel testing", "Thread safety", "Performance optimization"],
          "topic": "Parallel Execution",
          "followUp": []
        },
        {
          "id": "testng-018",
          "question": "What is ThreadLocal and why is it important?",
          "difficulty": "Hard",
          "experienceLevel": ["6-8", "9+"],
          "answer": "ThreadLocal provides thread-confined variables - each thread has its own copy of the variable. Essential for parallel test execution where each thread needs its own WebDriver instance. Usage: ThreadLocal<WebDriver> driver = new ThreadLocal<>(). Set value: driver.set(new ChromeDriver()). Get value: driver.get(). Always clean up: driver.remove() in @AfterMethod. Prevents thread interference and ensures test isolation in parallel execution.",
          "companies": ["Parallel automation", "Thread management", "Selenium Grid"],
          "topic": "Parallel Execution",
          "followUp": []
        },
        {
          "id": "testng-019",
          "question": "What happens when a dependency test fails?",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "When a dependency test fails, all dependent tests are skipped by default. TestNG marks them as SKIP status. Use alwaysRun=true in @Test annotation to run dependent tests even if dependencies fail. Configure ignoreMissingDependencies=true for soft dependencies. Check ITestResult.getStatus() to handle different outcomes. Implement ITestListener to customize behavior on dependency failures. Use groups with dependencies for complex dependency chains.",
          "companies": ["Test reliability", "Dependency management", "Error handling"],
          "topic": "Test Dependencies",
          "followUp": []
        },
        {
          "id": "testng-020",
          "question": "How to handle circular dependencies?",
          "difficulty": "Hard",
          "experienceLevel": ["6-8", "9+"],
          "answer": "TestNG detects and throws CircularDependencyException for circular dependencies. Avoid by redesigning test structure: use @BeforeMethod for common setup, create helper methods instead of test dependencies, use groups without circular references. Implement proper test hierarchy with base setup methods. Use composition over inheritance for test organization. Consider breaking circular logic into separate test suites or using factory pattern for complex test scenarios.",
          "companies": ["Test architecture", "Design patterns", "Framework reliability"],
          "topic": "Test Dependencies",
          "followUp": []
        },
        {
          "id": "testng-021",
          "question": "How to take screenshots on test failure?",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "Implement ITestListener interface and override onTestFailure() method. Use TakesScreenshot interface: WebDriver driver = (TakesScreenshot)this.driver; File screenshot = driver.getScreenshotAs(OutputType.FILE); FileUtils.copyFile(screenshot, new File(path)). Generate unique filename with timestamp and test name. Attach screenshots to TestNG reports using System.setProperty(\"org.uncommons.reportng.escape-output\", \"false\") and HTML tags in test descriptions. Integrate with extent reports for better visualization.",
          "companies": ["Visual debugging", "Test reporting", "Failure analysis"],
          "topic": "TestNG Listeners",
          "followUp": []
        },
        {
          "id": "testng-022",
          "question": "What is IRetryAnalyzer?",
          "difficulty": "Hard",
          "experienceLevel": ["6-8", "9+"],
          "answer": "IRetryAnalyzer interface allows automatic retry of failed tests. Implement retry() method returning boolean - true to retry, false to stop. Track retry count to avoid infinite loops. Usage: @Test(retryAnalyzer = RetryAnalyzer.class). For global retry, use IAnnotationTransformer to set retry analyzer for all tests. Useful for handling flaky tests but should be used judiciously. Configure maximum retry count and implement proper logging for retry attempts.",
          "companies": ["Flaky test handling", "Test stability", "Robust frameworks"],
          "topic": "Test Retry",
          "followUp": []
        },
        {
          "id": "testng-023",
          "question": "When should you use retry mechanism?",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "Use retry for: network timeouts, browser crashes, environment instability, third-party service failures. Don't use for: application bugs, test logic errors, data issues. Implement with caution - excessive retries can mask real issues. Set reasonable retry limits (1-3 attempts). Log retry reasons for analysis. Monitor retry patterns to identify systemic issues. Consider fixing root causes instead of masking with retries. Use in combination with proper waits and error handling.",
          "companies": ["Test reliability", "Continuous integration", "Stable automation"],
          "topic": "Test Retry",
          "followUp": []
        },
        {
          "id": "testng-024",
          "question": "How to implement global retry for all tests?",
          "difficulty": "Hard",
          "experienceLevel": ["6-8", "9+"],
          "answer": "Implement IAnnotationTransformer interface and override transform() method. Check if annotation is @Test and set retry analyzer: ((TestNG)annotation).setRetryAnalyzer(RetryAnalyzer.class). Register transformer in testng.xml using <listeners> or programmatically. Create base retry class implementing IRetryAnalyzer with configurable retry count. Use factory pattern for different retry strategies. Ensure thread safety for parallel execution. Provide configuration options for enabling/disabling retry globally.",
          "companies": ["Framework architecture", "Global configuration", "Advanced TestNG"],
          "topic": "Test Retry",
          "followUp": []
        },
        {
          "id": "testng-025",
          "question": "How to pass parameters from XML to tests?",
          "difficulty": "Easy",
          "experienceLevel": ["0-2", "3-5"],
          "answer": "Define parameters in testng.xml: <parameter name=\"browser\" value=\"chrome\"/>. Use @Parameters annotation in test method: @Parameters({\"browser\"}) public void test(String browser). Parameters can be defined at suite, test, or class level with inheritance. For optional parameters: @Optional(\"defaultValue\") String param. Combine with @BeforeMethod for setup configuration. Access parameters in @DataProvider methods by declaring them as method parameters.",
          "companies": ["Configuration management", "Environment testing", "Parameterized execution"],
          "topic": "TestNG XML",
          "followUp": []
        },
        {
          "id": "testng-026",
          "question": "How to run different XML files for different environments?",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "Create environment-specific XML files (testng-dev.xml, testng-prod.xml) with different parameters and configurations. Use Maven profiles to specify which XML file to run: mvn test -Denv=prod. Implement TestNG suite factory to dynamically load configurations. Use system properties to override XML parameters: -Dbrowser=firefox. Create base XML with common configuration and environment-specific XMLs extending it. Use programmatic TestNG configuration for dynamic suite creation based on environment variables.",
          "companies": ["Multi-environment testing", "CI/CD", "Configuration management"],
          "topic": "TestNG XML",
          "followUp": []
        },
        {
          "id": "testng-027",
          "question": "How to handle optional parameters?",
          "difficulty": "Easy",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "Use @Optional annotation with default value: @Parameters({\"browser\"}) @Test public void test(@Optional(\"chrome\") String browser). If parameter not found in XML, default value is used. Check for null values in method and provide fallback logic. Use conditional logic based on parameter presence. Combine with environment variables for flexible configuration. Document optional parameters and their defaults for team clarity.",
          "companies": ["Flexible testing", "Configuration management", "Default handling"],
          "topic": "Test Parameters",
          "followUp": []
        },
        {
          "id": "testng-028",
          "question": "Can parameters be passed to @DataProvider methods?",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "Yes, @DataProvider methods can receive parameters from XML. Declare parameters in DataProvider method signature: @DataProvider @Parameters({\"env\"}) public Object[][] getData(@Optional(\"dev\") String env). Use parameters to customize data source (different files, databases, URLs). TestNG automatically injects XML parameters into DataProvider methods. Useful for environment-specific test data, dynamic data generation based on configuration, and flexible data source selection.",
          "companies": ["Dynamic data testing", "Environment-specific data", "Flexible frameworks"],
          "topic": "Test Parameters",
          "followUp": []
        }
      ]
    },
    {
      "id": "framework-design",
      "name": "Test Framework Design",
      "icon": "üèóÔ∏è",
      "totalQuestions": 25,
      "questions": [
        {
          "id": "framework-001",
          "question": "What are the key components of a robust test automation framework architecture?",
          "difficulty": "Hard",
          "experienceLevel": ["6-8", "9-12"],
          "answer": "Key components: 1) Driver Management Layer (WebDriver factory, browser configuration), 2) Page Object Layer (page classes, element repositories), 3) Test Data Layer (Excel, JSON, database readers), 4) Utility Layer (common functions, helpers), 5) Configuration Layer (environment settings, properties), 6) Reporting Layer (test results, screenshots, logs), 7) Test Layer (actual test classes), 8) Base Classes (common setup/teardown), 9) Exception Handling Layer, 10) Logging Framework. Architecture should follow SOLID principles and design patterns like Factory, Singleton, Builder.",
          "companies": ["Framework architects", "Senior automation engineers", "Tech leads"],
          "topic": "Framework Architecture",
          "followUp": ["How do you ensure framework scalability?", "What design patterns are most useful in automation frameworks?"]
        },
        {
          "id": "framework-002",
          "question": "How do you design a framework to support multiple browsers, environments, and platforms?",
          "difficulty": "Hard",
          "experienceLevel": ["6-8", "9-12"],
          "answer": "Multi-platform design: 1) Browser Factory pattern with WebDriverManager for automatic driver management, 2) Configuration files (properties/JSON) for environment-specific settings, 3) Maven profiles or TestNG parameters for runtime configuration, 4) Abstract base classes for common functionality, 5) Strategy pattern for platform-specific implementations, 6) Docker containers for consistent environments, 7) Selenium Grid for distributed execution, 8) CI/CD pipeline integration with environment variables. Use dependency injection for loose coupling and easy configuration switching.",
          "companies": ["Cross-platform testing", "Enterprise applications", "Global teams"],
          "topic": "Multi-Platform Design",
          "followUp": ["How to handle platform-specific test data?", "How to manage different browser capabilities?"]
        },
        {
          "id": "framework-003",
          "question": "Explain the implementation of Page Object Model with Page Factory and its advantages",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "POM with Page Factory implementation: Use @FindBy annotations for element declaration, PageFactory.initElements() for lazy initialization, separate page classes for each application page. Advantages: 1) Lazy element initialization (elements found when accessed), 2) Cleaner code with annotations, 3) Automatic element caching with @CacheLookup, 4) Better maintainability, 5) Reduced code duplication. Example: @FindBy(id=\"username\") WebElement usernameField; Constructor: PageFactory.initElements(driver, this). Supports dynamic locators with @FindBy(how=How.XPATH, using=\"//div[@id='%s']\").",
          "companies": ["UI automation", "Maintainable frameworks", "Page-heavy applications"],
          "topic": "Page Object Model",
          "followUp": ["How to handle dynamic elements in POM?", "What are alternatives to Page Factory?"]
        },
        {
          "id": "framework-004",
          "question": "How do you implement data-driven testing framework with multiple data sources?",
          "difficulty": "Hard",
          "experienceLevel": ["6-8", "9-12"],
          "answer": "Data-driven framework implementation: 1) Create data reader interfaces (ExcelReader, JSONReader, DatabaseReader), 2) Implement factory pattern for data source selection, 3) Use TestNG @DataProvider with external data sources, 4) Create data models/POJOs for structured data, 5) Implement data validation and error handling, 6) Support parameterized test execution, 7) Enable data filtering and selection. Example: @DataProvider public Object[][] getData() { return DataFactory.getTestData(\"login\", \"excel\"); }. Supports Excel, CSV, JSON, XML, databases.",
          "companies": ["Data-heavy applications", "Enterprise testing", "Comprehensive validation"],
          "topic": "Data-Driven Framework",
          "followUp": ["How to handle large datasets efficiently?", "How to implement data dependencies between tests?"]
        },
        {
          "id": "framework-005",
          "question": "What are the best practices for implementing logging and reporting in automation frameworks?",
          "difficulty": "Medium",
          "experienceLevel": ["3-5", "6-8"],
          "answer": "Logging and reporting best practices: 1) Use logging frameworks (Log4j, SLF4J) with proper log levels, 2) Implement structured logging with correlation IDs, 3) Capture screenshots on failures automatically, 4) Create detailed test execution reports with ExtentReports/Allure, 5) Log test steps and assertions clearly, 6) Implement real-time reporting dashboards, 7) Store logs and reports in centralized location, 8) Include environment and configuration details in reports, 9) Implement log rotation and cleanup, 10) Provide filtering and search capabilities in reports.",
          "companies": ["Enterprise frameworks", "Debugging", "Stakeholder reporting"],
          "topic": "Logging and Reporting",
          "followUp": ["How to implement centralized logging?", "How to create real-time test dashboards?"]
        }
      ]
    }
  ]
}